[
  {
    "errata_id": 3335,
    "doc-id": "RFC6506",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 4.5,
    "orig_text": "If the Protocol-Specific Authentication Key (Ks) is L octets \r\nlong, then Ko is equal to K. ",
    "correct_text": "If the Protocol-Specific Authentication Key (Ks) is L octets \r\nlong, then Ko is equal to Ks. ",
    "notes": "The key K is never used in computing the digest. There is a class of cross protocol attacks that can be prevented if the original key K is appended with a few well known bytes. As a result, the key K is appended with a 2 octet crypto protocol ID to derive a new key Ks. Its this key that must always be used.",
    "submit_date": "2012-09-05",
    "submitter_name": "Manav Bhatia",
    "verifier_id": 122,
    "verifier_name": "Stewart Bryant",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3394,
    "doc-id": "RFC6506",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 4.5,
    "orig_text": "The OSPFv3 Cryptographic Protocol ID is appended to the\r\nAuthentication Key (K) yielding a Protocol-Specific\r\nAuthentication Key (Ks). In this application, Ko is always L\r\noctets long and is computed as follows:\r\n\r\nIf the Protocol-Specific Authentication Key (Ks) is L octets\r\nlong, then Ko is equal to K. If the Protocol-Specific\r\nAuthentication Key (Ks) is more than L octets long, then Ko is\r\nset to H(Ks). If the Protocol-Specific Authentication Key\r\n(Ks) is less than L octets long, then Ko is set to the\r\nProtocol-Specific Authentication Key (Ks) with zeros appended\r\nto the end of the Protocol-Specific Authentication Key (Ks)\r\nsuch that Ko is L octets long.",
    "correct_text": "Please see - notes\r\n\r\n====\r\n\r\nThe OSPFv3 Cryptographic Protocol ID is appended to the\r\nAuthentication Key (K) yielding a Protocol-Specific\r\nAuthentication Key (Ks). In this application, Ko is always B\r\noctets long and is computed as follows:\r\n\r\nIf the Protocol-Specific Authentication Key (Ks) is B octets\r\nlong, then Ko is equal to Ks. If the Protocol-Specific\r\nAuthentication Key (Ks) is more than B octets long, then Ko is\r\nset to H(Ks) and then appended with (B-L) zeroes to create a \r\nB octets long string Ko. If the Protocol-Specific Authentication\r\nKey (Ks) is less than B octets long, then Ko is set to the\r\nProtocol-Specific Authentication Key (Ks) with zeros appended\r\nto the end of the Protocol-Specific Authentication Key (Ks)\r\nsuch that Ko is B octets long.",
    "notes": "Readers should consult: draft-ietf-ospf-rfc6506bis for the resolution of this Erratum\r\n\r\n=====\r\n\r\nThis is in accordance with RFC2104(HMAC: Keyed-Hashing for Message Authentication). Reproducing the relevant text below:\r\n\r\n2. Definition of HMAC\r\n\r\n   The definition of HMAC requires a cryptographic hash function, which\r\n   we denote by H, and a secret key K. We assume H to be a cryptographic\r\n   hash function where data is hashed by iterating a basic compression\r\n   function on blocks of data.   We denote by B the byte-length of such\r\n   blocks (B=64 for all the above mentioned examples of hash functions),\r\n   and by L the byte-length of hash outputs (L=16 for MD5, L=20 for\r\n   SHA-1).  The authentication key K can be of any length up to B, the\r\n   block length of the hash function.  Applications that use keys longer\r\n   than B bytes will first hash the key using H and then use the\r\n   resultant L byte string as the actual key to HMAC. In any case the\r\n   minimal recommended length for K is L bytes (as the hash output\r\n   length). See section 3 for more information on keys.\r\n\r\n\r\nAlso, according to FIPS PUB 198, section 5(HMAC SPECIFICATION) :\r\n\r\nSTEPS\r\nSTEP-BY-STEP DESCRIPTION\r\nStep 1\r\nIf the length of K = B: set K0 = K. Go to step 4.\r\nStep 2\r\nIf the length of K > B: hash K to obtain an L byte string, then append (B-L) zeros to create a B-byte string K0 (i.e., K0 = H(K) || 00...00). Go to step 4.\r\nStep 3\r\nIf the length of K < B: append zeros to the end of K to create a B-byte string K0 (e.g., if K is 20 bytes in length and B = 64, then K will be appended with 44 zero bytes 0x00).\r\nStep 4\r\nExclusive-Or K0 with ipad to produce a B-byte string: K0 ¯ ipad.\r\nStep 5\r\nAppend the stream of data 'text' to the string resulting from step 4: (K0 ¯ ipad) || text.\r\nStep 6\r\nApply H to the stream generated in step 5: H((K0 ¯ ipad) || text).\r\nStep 7\r\nExclusive-Or K0 with opad: K0 ¯ opad.\r\nStep 8\r\nAppend the result from step 6 to step 7: (K0 ¯ opad) || H((K0 ¯ ipad) || text).\r\nStep 9\r\nApply H to the result from step 8: H((K0 ¯ opad )|| H((K0 &#65455; ipad) || text)).\r\nStep 10\r\nSelect the leftmost t bytes of the result of step 9 as the MAC.",
    "submit_date": "2012-10-25",
    "submitter_name": "Srinivasan K L",
    "verifier_id": 122,
    "verifier_name": "Stewart Bryant",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3567,
    "doc-id": "RFC6506",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 2.2,
    "orig_text": "   Consistent with OSPFv2 Cryptographic Authentication [RFC2328], both\r\n   OSPFv3 header checksum calculation and verification are omitted when\r\n   the OSPFv3 authentication mechanism described in this specification\r\n   is used.\r\n",
    "correct_text": "Please see notes\r\n\r\n=====\r\n\r\nOSPFv3 authentication mechanism provides capability to detect \r\ncorruption of OSPFv3 packet, which is under non authenticated \r\noperation achieved using OSPFv3 header checksum [RFC 5340] \r\nand LLS data block checksum [RFC 5613]. In spirit of OSPFv2 \r\nCryptographic Authentication [RFC2328], OSPFv3 header checksum \r\nand LLS Data Block Checksum calculation and verification \r\nare omitted when the OSPFv3 authentication mechanism \r\ndescribed in this specification is used.",
    "notes": "Readers should consult: draft-ietf-ospf-rfc6506bis for the \r\nresolution of this Erratum\r\n\r\n======\r\n\r\nRFC does not specify how to work with LLS Data Block Checksum. \r\nErrata suggests omit checksum calculation/verification in the \r\nsame way like for OSPFv3 header checksum.",
    "submit_date": "2013-03-27",
    "submitter_name": "Marek Karasek",
    "verifier_id": 122,
    "verifier_name": "Stewart Bryant",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3568,
    "doc-id": "RFC6506",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 4.2,
    "orig_text": "OSPFv3 Header Checksum\r\n\r\n   Both OSPFv3 header checksum calculation and verification are omitted\r\n   when the OSPFv3 authentication mechanism described in this\r\n   specification is used.  This implies:\r\n\r\n   o  For OSPFv3 packets to be transmitted, the OSPFv3 header checksum\r\n      computation is omitted, and the OSPFv3 header checksum SHOULD be\r\n      set to 0 prior to computation of the OSPFv3 Authentication Trailer\r\n      message digest.\r\n\r\n   o  For received OSPFv3 packets including an OSPFv3 Authentication\r\n      Trailer, OSPFv3 header checksum verification MUST be omitted.\r\n      However, if the OSPFv3 packet does include a non-zero OSPFv3\r\n      header checksum, it will not be modified by the receiver and will\r\n      simply be included in the OSPFv3 Authentication Trailer message\r\n      digest verification.\r\n",
    "correct_text": "Please see notes\r\n\r\n======\r\n\r\nOSPFv3 Header Checksum and LLS Data Block Checksum\r\n\r\nOSPFv3 Header Checksum and LLS Data Block Checksum calculation\r\nand verification are omitted when the OSPFv3 authentication \r\nmechanism described in this specification is used.  This \r\nimplies:\r\n\r\no  For OSPFv3 packets to be transmitted, the OSPFv3 header \r\nchecksum and LLS Data Block checksum computation is omitted, \r\nand the checksums SHOULD be set to 0 prior to computation \r\nof the OSPFv3 Authentication Trailer message digest.\r\n\r\no  For received OSPFv3 packets including an OSPFv3 \r\nAuthentication Trailer, OSPFv3 header checksum and LLS Data \r\nBlock checksum verification MUST be omitted.  However, \r\nif the OSPFv3 packet does include a non-zero OSPFv3 header \r\nor LLS Data Block checksum, it will not be modified by \r\nthe receiver and will simply be included in the OSPFv3 \r\nAuthentication Trailer message digest verification.",
    "notes": "The reader should consult draft-ietf-ospf-rfc6506bis for \r\nthe resolution of this erratum\r\n\r\n======\r\n\r\nRFC does not specify how to work with LLS Data Block \r\nChecksum. Errata suggests omit checksum calculation/\r\nverification in the same way like for OSPFv3 header \r\nchecksum.",
    "submit_date": "2013-03-27",
    "submitter_name": "Marek Karasek",
    "verifier_id": 122,
    "verifier_name": "Stewart Bryant",
    "update_date": "2019-09-10 09:09:03"
  }
]
