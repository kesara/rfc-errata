[
  {
    "errata_id": 1365,
    "doc-id": "RFC5162",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "1. (ff.)",
    "orig_text": "   A client making use of this extension MUST issue \"ENABLE QRESYNC\"\r\n   once it is authenticated.  A server MUST respond with a tagged BAD\r\n   response if the QRESYNC parameter to the SELECT/EXAMINE command or\r\n   the VANISHED UID FETCH modifier is specified and the client hasn't\r\n   issued \"ENABLE QRESYNC\" in the current connection.",
    "correct_text": "   A client making use of this extension MUST issue \"ENABLE QRESYNC\"\r\n   once it is authenticated.  A server MUST respond with a tagged BAD\r\n   response if the QRESYNC parameter to the SELECT/EXAMINE command or\r\n   the VANISHED UID FETCH modifier is specified and the client hasn't\r\n|  issued \"ENABLE QRESYNC\", or the server has not positively responded\r\n|  to that command with \"ENABLED QRESYNC\", in the current connection.",
    "notes": "Rationale:\r\nAccording to RFC 5161, the option enablement handshake is only\r\ncomplete, and hence the option(s) enabled on the server, if the\r\nserver has sent a positive (untagged) \"ENABLED <option>\" response\r\nto the ENABLE command.\r\nFor clarity, RFC 5162 should unambiguously reflect this causality\r\nchain.\r\n\r\nThis same issue recurs in Section 3.1 (last paragraph on page 4)\r\nand Section 3.6 (4th paragraph on page 13).",
    "submit_date": "2008-03-11",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 127,
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1807,
    "doc-id": "RFC5162",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 1,
    "orig_text": null,
    "correct_text": "   Once a \"CONDSTORE enabling command\" is issued by the client, the\r\n   server MUST automatically include both UID and mod-sequence data in\r\n   all subsequent untagged FETCH responses (until the connection is\r\n   closed), whether they were caused by a regular STORE/UID STORE, a\r\n   STORE/UID STORE with UNCHANGEDSINCE modifier, or an external agent.\r\n   Note that this rule doesn't affect untagged FETCH responses caused by\r\n   a FETCH command that doesn't include UID and/or MODSEQ FETCH data\r\n   item, or UID FETCH without the MODSEQ FETCH data item.",
    "notes": "Rationale:\r\n\r\nIt's very difficult for clients to make use of unsolicited FETCH responses without the UID field. This is made even worse by the text that says \"servers SHOULD NOT send UIDs for previously expunged messages [in VANISHED replies]\". Since it's not a MUST NOT, a conversation with an RFC compliant server could be for example:\r\n\r\nA1 NOOP\r\n* 0 EXISTS\r\nA1 OK\r\nA2 NOOP\r\n* 10 EXISTS\r\n* VANISHED 1000:2000\r\n* 3 FETCH (FLAGS (\\Seen) MODSEQ (14749))\r\n* 5 FETCH (FLAGS (\\Seen) MODSEQ (14749))\r\n* VANISHED 2000:3000\r\nA2 OK NOOP Completed\r\n\r\nThe client couldn't do anything with the information from FETCH replies, because it can't know what messages they refer to.",
    "submit_date": "2009-07-14",
    "submitter_name": "Timo Sirainen",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1808,
    "doc-id": "RFC5162",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 3.4,
    "orig_text": "   If at least one message got expunged, the server MUST send\r\n   the updated per-mailbox modification\r\n   sequence using the HIGHESTMODSEQ response code (defined in\r\n   [CONDSTORE]) in the tagged OK response.\r\n\r\n      Example:    C: A202 CLOSE\r\n                  S: A202 OK [HIGHESTMODSEQ 20010715194045319] done",
    "correct_text": "   The server MUST NOT send the updated per-mailbox modification\r\n   sequence using the HIGHESTMODSEQ response code (defined in\r\n   [CONDSTORE]) in the tagged OK response, as this might cause loss of\r\n   synchronization on the client.\r\n\r\n      Example:    C: A202 CLOSE\r\n                  S: A202 OK done",
    "notes": "Rationale:\r\n\r\nThe HIGHESTMODSEQ can't be used reliably unless server sends to client all changes done by other clients. Even then it's difficult for both clients and servers to implement this. For example:\r\n\r\nC1: 2 STORE 1 +FLAGS.SILENT \\Deleted\r\nS1: * 1 FETCH (MODSEQ 1)\r\nS1: 2 OK\r\n\r\nC2: 1 STORE 2 +FLAGS.SILENT \\Deleted\r\nS1: * 2 FETCH (MODSEQ 2)\r\nS2: 1 OK\r\n\r\nC1: 3 CLOSE\r\nS1: 3 [HIGHESTMODSEQ 3]\r\n\r\nThe client probably thought that only message 1 was expunged, so it\r\ndoesn't register the second expunge. And it probably never will if it\r\nuses QRESYNC to find out only about new expunges.\r\n\r\nAnd even worse example would be if the second client had also removed\r\nthe \\Deleted flag from message 1. Then the first client would have\r\nregistered wrong message to be expunged.",
    "submit_date": "2009-07-14",
    "submitter_name": "Timo Sirainen",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1809,
    "doc-id": "RFC5162",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 5,
    "orig_text": "   After completing a full synchronization, the client MUST also take\r\n   note of any unsolicited MODSEQ FETCH data items received from the\r\n   server.  Whenever the client receives a tagged response to a command,\r\n   it calculates the highest value among all MODSEQ FETCH data items\r\n   received since the last tagged response.  If this value is bigger\r\n   than the client's copy of the HIGHESTMODSEQ value, then the client\r\n   MUST use this value as its new HIGHESTMODSEQ value.\r\n\r\n   Note: It is not safe to update the client's copy of the HIGHESTMODSEQ\r\n   value with a MODSEQ FETCH data item value as soon as it is received\r\n   because servers are not required to send MODSEQ FETCH data items in\r\n   increasing modseqence order.  This can lead to the client missing\r\n   some changes in case of connectivity loss.",
    "correct_text": "   After completing a full synchronization, the client MUST also take\r\n   note of any unsolicited MODSEQ FETCH data items and HIGHESTMODSEQ\r\n   response codes received from the server.  Whenever the client receives\r\n   a tagged response to a command, it checks the received unsolicited\r\n   responses to calculate the new HIGHESTMODSEQ value.  If the\r\n   HIGHESTMODSEQ response code is received, the client MUST use it even\r\n   if it has seen higher mod-sequences.  Otherwise, the client calculates\r\n   the highest value among all MODSEQ FETCH data items received since the\r\n   last tagged response.  If this value is bigger than the client's copy\r\n   of the HIGHESTMODSEQ value, then the client MUST use this value as its\r\n   new HIGHESTMODSEQ value.\r\n\r\n      Example:    C: A1 STORE 1:2 (UNCHANGEDSINCE 96) +FLAGS.SILENT \\Seen\r\n                  S: * 1 FETCH (UID 6 MODSEQ (103))\r\n                  S: * 2 FETCH (UID 7 MODSEQ (101))\r\n                  S: * OK [HIGHESTMODSEQ 99] VANISHED reply with\r\n\t\t      MODSEQ 100 is delayed\r\n                  S: A1 OK [MODIFIED 3] done\r\n\r\n                  C: A2 STORE 3 +FLAGS.SILENT \\Seen\r\n                  S: * 3 FETCH (UID 8 MODSEQ (104))\r\n                  S: A2 OK [HIGHESTMODSEQ 99] Still delaying VANISHED\r\n\r\n                  C: A3 NOOP\r\n                  S: * VANISHED 8\r\n                  S: A3 OK [HIGHESTMODSEQ 104] done\r\n\r\n   Note: It is not safe to update the client's copy of the HIGHESTMODSEQ\r\n   value with a MODSEQ FETCH data item value as soon as it is received\r\n   because servers are not required to send MODSEQ FETCH data items in\r\n   increasing modseqence order.  Some commands may also delay EXPUNGE\r\n   (or VANISHED) replies with smaller mod-sequences. These can lead to\r\n   the client missing some changes in case of connectivity loss.",
    "notes": "Rationale:\r\n\r\nOtherwise clients could lose changes in case of connectivity loss.",
    "submit_date": "2009-07-14",
    "submitter_name": "Timo Sirainen",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1810,
    "doc-id": "RFC5162",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 1,
    "orig_text": null,
    "correct_text": "   Server implementing QRESYNC MUST send untagged events to client in a\r\n   way that client doesn't lose any changes in case of connectivity loss.\r\n   In particular this means that if server sends MODSEQ FETCH data items\r\n   while EXPUNGE (or VANISHED) replies with lower mod-sequences are being\r\n   delayed, the server MUST send HIGHESTMODSEQ response code with a lower\r\n   value than the EXPUNGE's mod-sequence. See example in section 5.",
    "notes": "This is related to the other errata in section 5, which describes what the client's behavior should be. This describes what the server's behavior should be. Would have been nice to put them into the same section, but that probably would require larger changes.",
    "submit_date": "2009-07-14",
    "submitter_name": "Timo Sirainen",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3322,
    "doc-id": "RFC5162",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.6,
    "orig_text": "A VANISHED response sent because of an EXPUNGE or UID EXPUNGE command\r\nor because messages were expunged in other connections (i.e., the\r\nVANISHED response without the EARLIER tag) also decrements the number\r\nof messages in the mailbox; it is not necessary for the server to\r\nsend an EXISTS response with the new value.  It also decrements\r\nmessage sequence numbers for each successive message in the mailbox\r\n(see the example at the end of this section).  Note that a VANISHED\r\nresponse caused by EXPUNGE, UID EXPUNGE, or messages expunged in\r\nother connections SHOULD only contain UIDs for messages expunged\r\nsince the last VANISHED/EXPUNGE response sent for the currently\r\nopened mailbox or since the mailbox was opened.  That is, servers\r\nSHOULD NOT send UIDs for previously expunged messages, unless\r\nexplicitly requested to do so by the UID FETCH (VANISHED) command.\r\n\r\nNote that client implementors must take care to properly decrement\r\nthe number of messages in the mailbox even if a server violates this\r\nlast SHOULD or repeats the same UID multiple times in the returned\r\nUID set.  In general, this means that a client using this extension\r\nshould either avoid using message numbers entirely, or have a\r\ncomplete mapping of UIDs to message sequence numbers for the selected\r\nmailbox.",
    "correct_text": "A VANISHED response sent because of an EXPUNGE or UID EXPUNGE command\r\nor because messages were expunged in other connections (i.e., the\r\nVANISHED response without the EARLIER tag) also decrements the number\r\nof messages in the mailbox; it is not necessary for the server to\r\nsend an EXISTS response with the new value.  It also decrements\r\nmessage sequence numbers for each successive message in the mailbox\r\n(see the example at the end of this section).\r\n\r\nNote that a VANISHED response caused by EXPUNGE, UID EXPUNGE, or\r\nmessages expunged in other connections MUST only contain UIDs for\r\nmessages expunged since the last VANISHED/EXPUNGE response sent for\r\nthe currently opened mailbox or since the mailbox was opened.  That is,\r\nservers MUST NOT send UIDs for previously expunged messages, unless\r\nexplicitly requested to do so by the UID FETCH (VANISHED) command.\r\nThis is required to prevent a possible race condition where new arrivals\r\nfor which the UID is not yet known by the client are expunged.",
    "notes": "If the servers were allowed to send VANISHED responses referring to non-existing UIDs, there's a possible race condition when new arrivals are expunged.  This is due to the sequence-UID assymetry of EXISTS vs. VANISHED.\r\n\r\nNew arrivals are reported through EXISTS and their UIDs are not known to the client. Suppose the following scenario where two messages exist and their UIDs are 10 and 11. Two more messages arrive:\r\n\r\n* 4 EXISTS\r\n* VANISHED 12:20\r\n\r\nThe client has no way of knowing whether the two new arrivals have UIDs falling into the 12:20 range. As such, the client doesn't know whether there are two, three or four messages in the mailbox at this point.\r\n\r\nSee http://mailman2.u.washington.edu/pipermail/imap-protocol/2012-June/001781.html for details.\n --VERIFIER NOTES-- \nThis is a clear change to the intention of the document and is too large a change to be appropriate to an erratum. There is a problem here, but it is more properly handled by new work, which is being undertaken as http://datatracker.ietf.org/doc/draft-kundrat-qresync-arrived/",
    "submit_date": "2012-08-16",
    "submitter_name": "Jan Kundrát",
    "verifier_id": 127,
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3323,
    "doc-id": "RFC5162",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "GLOBAL",
    "orig_text": "The \"ENABLE QRESYNC\"/\"ENABLE QRESYNC CONDSTORE\" command\r\nalso tells the server that it SHOULD start sending VANISHED responses\r\n(see Section 3.6) instead of EXPUNGE responses.",
    "correct_text": "The \"ENABLE QRESYNC\"/\"ENABLE QRESYNC CONDSTORE\" command\r\nalso tells the server that it MUST start sending VANISHED responses\r\n(see Section 3.6) instead of EXPUNGE responses.",
    "notes": "The explicit allowance for EXPUNGE being sent instead of VANISHED means that clients still have to maintain a full sequence-to-UID mapping, otherwise there is a risk of losing synchronization. Given that QRESYNC itself is an optional extension, I find it hard to imagine a case where the server cannot send a proper VANISHED response.\r\n\r\nIf this errata gets accepted, it will require rather heavy editing of the document; the notion of EXPUNGE responses being allowed is followed throughout the whole RFC, including the examples.\n --VERIFIER NOTES-- \nThe fact that this is a change to a normative requirement of the document, and (as the notes say) the fact that it would cause extensive changes to the rest of the document, makes it inappropriate as an erratum.",
    "submit_date": "2012-08-16",
    "submitter_name": "Jan Kundrát",
    "verifier_id": 127,
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  }
]
