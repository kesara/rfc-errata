[
  {
    "errata_id": 6701,
    "doc-id": "RFC6521",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "The 2021 NGINX Annual Community Survey is now open.\r\nShare your opinion and feedback on NGINX\r\nnginx\r\n\r\nenglish\r\nрусский\r\n\r\nnews\r\nabout\r\ndownload\r\nsecurity\r\ndocumentation\r\nfaq\r\nbooks\r\nsupport\r\n\r\ntrac\r\ntwitter\r\nblog\r\n\r\nunit\r\nnjs\r\nModule ngx_http_core_module\r\n\r\nDirectives\r\n     absolute_redirect\r\n     aio\r\n     aio_write\r\n     alias\r\n     auth_delay\r\n     chunked_transfer_encoding\r\n     client_body_buffer_size\r\n     client_body_in_file_only\r\n     client_body_in_single_buffer\r\n     client_body_temp_path\r\n     client_body_timeout\r\n     client_header_buffer_size\r\n     client_header_timeout\r\n     client_max_body_size\r\n     connection_pool_size\r\n     default_type\r\n     directio\r\n     directio_alignment\r\n     disable_symlinks\r\n     error_page\r\n     etag\r\n     http\r\n     if_modified_since\r\n     ignore_invalid_headers\r\n     internal\r\n     keepalive_disable\r\n     keepalive_requests\r\n     keepalive_time\r\n     keepalive_timeout\r\n     large_client_header_buffers\r\n     limit_except\r\n     limit_rate\r\n     limit_rate_after\r\n     lingering_close\r\n     lingering_time\r\n     lingering_timeout\r\n     listen\r\n     location\r\n     log_not_found\r\n     log_subrequest\r\n     max_ranges\r\n     merge_slashes\r\n     msie_padding\r\n     msie_refresh\r\n     open_file_cache\r\n     open_file_cache_errors\r\n     open_file_cache_min_uses\r\n     open_file_cache_valid\r\n     output_buffers\r\n     port_in_redirect\r\n     postpone_output\r\n     read_ahead\r\n     recursive_error_pages\r\n     request_pool_size\r\n     reset_timedout_connection\r\n     resolver\r\n     resolver_timeout\r\n     root\r\n     satisfy\r\n     send_lowat\r\n     send_timeout\r\n     sendfile\r\n     sendfile_max_chunk\r\n     server\r\n     server_name\r\n     server_name_in_redirect\r\n     server_names_hash_bucket_size\r\n     server_names_hash_max_size\r\n     server_tokens\r\n     subrequest_output_buffer_size\r\n     tcp_nodelay\r\n     tcp_nopush\r\n     try_files\r\n     types\r\n     types_hash_bucket_size\r\n     types_hash_max_size\r\n     underscores_in_headers\r\n     variables_hash_bucket_size\r\n     variables_hash_max_size\r\nEmbedded Variables\r\nDirectives\r\n\r\nSyntax:\tabsolute_redirect on | off;\r\nDefault:\t\r\nabsolute_redirect on;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.11.8.\r\nIf disabled, redirects issued by nginx will be relative.\r\n\r\nSee also server_name_in_redirect and port_in_redirect directives.\r\n\r\nSyntax:\taio on | off | threads[=pool];\r\nDefault:\t\r\naio off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.8.11.\r\nEnables or disables the use of asynchronous file I/O (AIO) on FreeBSD and Linux:\r\n\r\nlocation /video/ {\r\n    aio            on;\r\n    output_buffers 1 64k;\r\n}\r\nOn FreeBSD, AIO can be used starting from FreeBSD 4.3. Prior to FreeBSD 11.0, AIO can either be linked statically into a kernel:\r\n\r\noptions VFS_AIO\r\nor loaded dynamically as a kernel loadable module:\r\n\r\nkldload aio\r\nOn Linux, AIO can be used starting from kernel version 2.6.22. Also, it is necessary to enable directio, or otherwise reading will be blocking:\r\n\r\nlocation /video/ {\r\n    aio            on;\r\n    directio       512;\r\n    output_buffers 1 128k;\r\n}\r\nOn Linux, directio can only be used for reading blocks that are aligned on 512-byte boundaries (or 4K for XFS). File’s unaligned end is read in blocking mode. The same holds true for byte range requests and for FLV requests not from the beginning of a file: reading of unaligned data at the beginning and end of a file will be blocking.\r\n\r\nWhen both AIO and sendfile are enabled on Linux, AIO is used for files that are larger than or equal to the size specified in the directio directive, while sendfile is used for files of smaller sizes or when directio is disabled.\r\n\r\nlocation /video/ {\r\n    sendfile       on;\r\n    aio            on;\r\n    directio       8m;\r\n}\r\nFinally, files can be read and sent using multi-threading (1.7.11), without blocking a worker process:\r\n\r\nlocation /video/ {\r\n    sendfile       on;\r\n    aio            threads;\r\n}\r\nRead and send file operations are offloaded to threads of the specified pool. If the pool name is omitted, the pool with the name “default” is used. The pool name can also be set with variables:\r\n\r\naio threads=pool$disk;\r\nBy default, multi-threading is disabled, it should be enabled with the --with-threads configuration parameter. Currently, multi-threading is compatible only with the epoll, kqueue, and eventport methods. Multi-threaded sending of files is only supported on Linux.\r\n\r\nSee also the sendfile directive.\r\n\r\nSyntax:\taio_write on | off;\r\nDefault:\t\r\naio_write off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.9.13.\r\nIf aio is enabled, specifies whether it is used for writing files. Currently, this only works when using aio threads and is limited to writing temporary files with data received from proxied servers.\r\n\r\nSyntax:\talias path;\r\nDefault:\t—\r\nContext:\tlocation\r\nDefines a replacement for the specified location. For example, with the following configuration\r\n\r\nlocation /i/ {\r\n    alias /data/w3/images/;\r\n}\r\non request of “/i/top.gif”, the file /data/w3/images/top.gif will be sent.\r\n\r\nThe path value can contain variables, except $document_root and $realpath_root.\r\n\r\nIf alias is used inside a location defined with a regular expression then such regular expression should contain captures and alias should refer to these captures (0.7.40), for example:\r\n\r\nlocation ~ ^/users/(.+\\.(?:gif|jpe?g|png))$ {\r\n    alias /data/w3/images/$1;\r\n}\r\nWhen location matches the last part of the directive’s value:\r\n\r\nlocation /images/ {\r\n    alias /data/w3/images/;\r\n}\r\nit is better to use the root directive instead:\r\n\r\nlocation /images/ {\r\n    root /data/w3;\r\n}\r\nSyntax:\tauth_delay time;\r\nDefault:\t\r\nauth_delay 0s;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.17.10.\r\nDelays processing of unauthorized requests with 401 response code to prevent timing attacks when access is limited by password, by the result of subrequest, or by JWT.\r\n\r\nSyntax:\tchunked_transfer_encoding on | off;\r\nDefault:\t\r\nchunked_transfer_encoding on;\r\nContext:\thttp, server, location\r\nAllows disabling chunked transfer encoding in HTTP/1.1. It may come in handy when using a software failing to support chunked encoding despite the standard’s requirement.\r\n\r\nSyntax:\tclient_body_buffer_size size;\r\nDefault:\t\r\nclient_body_buffer_size 8k|16k;\r\nContext:\thttp, server, location\r\nSets buffer size for reading client request body. In case the request body is larger than the buffer, the whole body or only its part is written to a temporary file. By default, buffer size is equal to two memory pages. This is 8K on x86, other 32-bit platforms, and x86-64. It is usually 16K on other 64-bit platforms.\r\n\r\nSyntax:\tclient_body_in_file_only on | clean | off;\r\nDefault:\t\r\nclient_body_in_file_only off;\r\nContext:\thttp, server, location\r\nDetermines whether nginx should save the entire client request body into a file. This directive can be used during debugging, or when using the $request_body_file variable, or the $r->request_body_file method of the module ngx_http_perl_module.\r\n\r\nWhen set to the value on, temporary files are not removed after request processing.\r\n\r\nThe value clean will cause the temporary files left after request processing to be removed.\r\n\r\nSyntax:\tclient_body_in_single_buffer on | off;\r\nDefault:\t\r\nclient_body_in_single_buffer off;\r\nContext:\thttp, server, location\r\nDetermines whether nginx should save the entire client request body in a single buffer. The directive is recommended when using the $request_body variable, to save the number of copy operations involved.\r\n\r\nSyntax:\tclient_body_temp_path path [level1 [level2 [level3]]];\r\nDefault:\t\r\nclient_body_temp_path client_body_temp;\r\nContext:\thttp, server, location\r\nDefines a directory for storing temporary files holding client request bodies. Up to three-level subdirectory hierarchy can be used under the specified directory. For example, in the following configuration\r\n\r\nclient_body_temp_path /spool/nginx/client_temp 1 2;\r\na path to a temporary file might look like this:\r\n\r\n/spool/nginx/client_temp/7/45/00000123457\r\nSyntax:\tclient_body_timeout time;\r\nDefault:\t\r\nclient_body_timeout 60s;\r\nContext:\thttp, server, location\r\nDefines a timeout for reading client request body. The timeout is set only for a period between two successive read operations, not for the transmission of the whole request body. If a client does not transmit anything within this time, the request is terminated with the 408 (Request Time-out) error.\r\n\r\nSyntax:\tclient_header_buffer_size size;\r\nDefault:\t\r\nclient_header_buffer_size 1k;\r\nContext:\thttp, server\r\nSets buffer size for reading client request header. For most requests, a buffer of 1K bytes is enough. However, if a request includes long cookies, or comes from a WAP client, it may not fit into 1K. If a request line or a request header field does not fit into this buffer then larger buffers, configured by the large_client_header_buffers directive, are allocated.\r\n\r\nSyntax:\tclient_header_timeout time;\r\nDefault:\t\r\nclient_header_timeout 60s;\r\nContext:\thttp, server\r\nDefines a timeout for reading client request header. If a client does not transmit the entire header within this time, the request is terminated with the 408 (Request Time-out) error.\r\n\r\nSyntax:\tclient_max_body_size size;\r\nDefault:\t\r\nclient_max_body_size 1m;\r\nContext:\thttp, server, location\r\nSets the maximum allowed size of the client request body. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size.\r\n\r\nSyntax:\tconnection_pool_size size;\r\nDefault:\t\r\nconnection_pool_size 256|512;\r\nContext:\thttp, server\r\nAllows accurate tuning of per-connection memory allocations. This directive has minimal impact on performance and should not generally be used. By default, the size is equal to 256 bytes on 32-bit platforms and 512 bytes on 64-bit platforms.\r\n\r\nPrior to version 1.9.8, the default value was 256 on all platforms.\r\nSyntax:\tdefault_type mime-type;\r\nDefault:\t\r\ndefault_type text/plain;\r\nContext:\thttp, server, location\r\nDefines the default MIME type of a response. Mapping of file name extensions to MIME types can be set with the types directive.\r\n\r\nSyntax:\tdirectio size | off;\r\nDefault:\t\r\ndirectio off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.7.7.\r\nEnables the use of the O_DIRECT flag (FreeBSD, Linux), the F_NOCACHE flag (macOS), or the directio() function (Solaris), when reading files that are larger than or equal to the specified size. The directive automatically disables (0.7.15) the use of sendfile for a given request. It can be useful for serving large files:\r\n\r\ndirectio 4m;\r\nor when using aio on Linux.\r\n\r\nSyntax:\tdirectio_alignment size;\r\nDefault:\t\r\ndirectio_alignment 512;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.8.11.\r\nSets the alignment for directio. In most cases, a 512-byte alignment is enough. However, when using XFS under Linux, it needs to be increased to 4K.\r\n\r\nSyntax:\tdisable_symlinks off;\r\ndisable_symlinks on | if_not_owner [from=part];\r\nDefault:\t\r\ndisable_symlinks off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.1.15.\r\nDetermines how symbolic links should be treated when opening files:\r\n\r\noff\r\nSymbolic links in the pathname are allowed and not checked. This is the default behavior.\r\non\r\nIf any component of the pathname is a symbolic link, access to a file is denied.\r\nif_not_owner\r\nAccess to a file is denied if any component of the pathname is a symbolic link, and the link and object that the link points to have different owners.\r\nfrom=part\r\nWhen checking symbolic links (parameters on and if_not_owner), all components of the pathname are normally checked. Checking of symbolic links in the initial part of the pathname may be avoided by specifying additionally the from=part parameter. In this case, symbolic links are checked only from the pathname component that follows the specified initial part. If the value is not an initial part of the pathname checked, the whole pathname is checked as if this parameter was not specified at all. If the value matches the whole file name, symbolic links are not checked. The parameter value can contain variables.\r\nExample:\r\n\r\ndisable_symlinks on from=$document_root;\r\nThis directive is only available on systems that have the openat() and fstatat() interfaces. Such systems include modern versions of FreeBSD, ",
    "correct_text": "The 2021 NGINX Annual Community Survey is now open.\r\nShare your opinion and feedback on NGINX\r\nnginx\r\n\r\nenglish\r\nрусский\r\n\r\nnews\r\nabout\r\ndownload\r\nsecurity\r\ndocumentation\r\nfaq\r\nbooks\r\nsupport\r\n\r\ntrac\r\ntwitter\r\nblog\r\n\r\nunit\r\nnjs\r\nModule ngx_http_core_module\r\n\r\nDirectives\r\n     absolute_redirect\r\n     aio\r\n     aio_write\r\n     alias\r\n     auth_delay\r\n     chunked_transfer_encoding\r\n     client_body_buffer_size\r\n     client_body_in_file_only\r\n     client_body_in_single_buffer\r\n     client_body_temp_path\r\n     client_body_timeout\r\n     client_header_buffer_size\r\n     client_header_timeout\r\n     client_max_body_size\r\n     connection_pool_size\r\n     default_type\r\n     directio\r\n     directio_alignment\r\n     disable_symlinks\r\n     error_page\r\n     etag\r\n     http\r\n     if_modified_since\r\n     ignore_invalid_headers\r\n     internal\r\n     keepalive_disable\r\n     keepalive_requests\r\n     keepalive_time\r\n     keepalive_timeout\r\n     large_client_header_buffers\r\n     limit_except\r\n     limit_rate\r\n     limit_rate_after\r\n     lingering_close\r\n     lingering_time\r\n     lingering_timeout\r\n     listen\r\n     location\r\n     log_not_found\r\n     log_subrequest\r\n     max_ranges\r\n     merge_slashes\r\n     msie_padding\r\n     msie_refresh\r\n     open_file_cache\r\n     open_file_cache_errors\r\n     open_file_cache_min_uses\r\n     open_file_cache_valid\r\n     output_buffers\r\n     port_in_redirect\r\n     postpone_output\r\n     read_ahead\r\n     recursive_error_pages\r\n     request_pool_size\r\n     reset_timedout_connection\r\n     resolver\r\n     resolver_timeout\r\n     root\r\n     satisfy\r\n     send_lowat\r\n     send_timeout\r\n     sendfile\r\n     sendfile_max_chunk\r\n     server\r\n     server_name\r\n     server_name_in_redirect\r\n     server_names_hash_bucket_size\r\n     server_names_hash_max_size\r\n     server_tokens\r\n     subrequest_output_buffer_size\r\n     tcp_nodelay\r\n     tcp_nopush\r\n     try_files\r\n     types\r\n     types_hash_bucket_size\r\n     types_hash_max_size\r\n     underscores_in_headers\r\n     variables_hash_bucket_size\r\n     variables_hash_max_size\r\nEmbedded Variables\r\nDirectives\r\n\r\nSyntax:\tabsolute_redirect on | off;\r\nDefault:\t\r\nabsolute_redirect on;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.11.8.\r\nIf disabled, redirects issued by nginx will be relative.\r\n\r\nSee also server_name_in_redirect and port_in_redirect directives.\r\n\r\nSyntax:\taio on | off | threads[=pool];\r\nDefault:\t\r\naio off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.8.11.\r\nEnables or disables the use of asynchronous file I/O (AIO) on FreeBSD and Linux:\r\n\r\nlocation /video/ {\r\n    aio            on;\r\n    output_buffers 1 64k;\r\n}\r\nOn FreeBSD, AIO can be used starting from FreeBSD 4.3. Prior to FreeBSD 11.0, AIO can either be linked statically into a kernel:\r\n\r\noptions VFS_AIO\r\nor loaded dynamically as a kernel loadable module:\r\n\r\nkldload aio\r\nOn Linux, AIO can be used starting from kernel version 2.6.22. Also, it is necessary to enable directio, or otherwise reading will be blocking:\r\n\r\nlocation /video/ {\r\n    aio            on;\r\n    directio       512;\r\n    output_buffers 1 128k;\r\n}\r\nOn Linux, directio can only be used for reading blocks that are aligned on 512-byte boundaries (or 4K for XFS). File’s unaligned end is read in blocking mode. The same holds true for byte range requests and for FLV requests not from the beginning of a file: reading of unaligned data at the beginning and end of a file will be blocking.\r\n\r\nWhen both AIO and sendfile are enabled on Linux, AIO is used for files that are larger than or equal to the size specified in the directio directive, while sendfile is used for files of smaller sizes or when directio is disabled.\r\n\r\nlocation /video/ {\r\n    sendfile       on;\r\n    aio            on;\r\n    directio       8m;\r\n}\r\nFinally, files can be read and sent using multi-threading (1.7.11), without blocking a worker process:\r\n\r\nlocation /video/ {\r\n    sendfile       on;\r\n    aio            threads;\r\n}\r\nRead and send file operations are offloaded to threads of the specified pool. If the pool name is omitted, the pool with the name “default” is used. The pool name can also be set with variables:\r\n\r\naio threads=pool$disk;\r\nBy default, multi-threading is disabled, it should be enabled with the --with-threads configuration parameter. Currently, multi-threading is compatible only with the epoll, kqueue, and eventport methods. Multi-threaded sending of files is only supported on Linux.\r\n\r\nSee also the sendfile directive.\r\n\r\nSyntax:\taio_write on | off;\r\nDefault:\t\r\naio_write off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.9.13.\r\nIf aio is enabled, specifies whether it is used for writing files. Currently, this only works when using aio threads and is limited to writing temporary files with data received from proxied servers.\r\n\r\nSyntax:\talias path;\r\nDefault:\t—\r\nContext:\tlocation\r\nDefines a replacement for the specified location. For example, with the following configuration\r\n\r\nlocation /i/ {\r\n    alias /data/w3/images/;\r\n}\r\non request of “/i/top.gif”, the file /data/w3/images/top.gif will be sent.\r\n\r\nThe path value can contain variables, except $document_root and $realpath_root.\r\n\r\nIf alias is used inside a location defined with a regular expression then such regular expression should contain captures and alias should refer to these captures (0.7.40), for example:\r\n\r\nlocation ~ ^/users/(.+\\.(?:gif|jpe?g|png))$ {\r\n    alias /data/w3/images/$1;\r\n}\r\nWhen location matches the last part of the directive’s value:\r\n\r\nlocation /images/ {\r\n    alias /data/w3/images/;\r\n}\r\nit is better to use the root directive instead:\r\n\r\nlocation /images/ {\r\n    root /data/w3;\r\n}\r\nSyntax:\tauth_delay time;\r\nDefault:\t\r\nauth_delay 0s;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.17.10.\r\nDelays processing of unauthorized requests with 401 response code to prevent timing attacks when access is limited by password, by the result of subrequest, or by JWT.\r\n\r\nSyntax:\tchunked_transfer_encoding on | off;\r\nDefault:\t\r\nchunked_transfer_encoding on;\r\nContext:\thttp, server, location\r\nAllows disabling chunked transfer encoding in HTTP/1.1. It may come in handy when using a software failing to support chunked encoding despite the standard’s requirement.\r\n\r\nSyntax:\tclient_body_buffer_size size;\r\nDefault:\t\r\nclient_body_buffer_size 8k|16k;\r\nContext:\thttp, server, location\r\nSets buffer size for reading client request body. In case the request body is larger than the buffer, the whole body or only its part is written to a temporary file. By default, buffer size is equal to two memory pages. This is 8K on x86, other 32-bit platforms, and x86-64. It is usually 16K on other 64-bit platforms.\r\n\r\nSyntax:\tclient_body_in_file_only on | clean | off;\r\nDefault:\t\r\nclient_body_in_file_only off;\r\nContext:\thttp, server, location\r\nDetermines whether nginx should save the entire client request body into a file. This directive can be used during debugging, or when using the $request_body_file variable, or the $r->request_body_file method of the module ngx_http_perl_module.\r\n\r\nWhen set to the value on, temporary files are not removed after request processing.\r\n\r\nThe value clean will cause the temporary files left after request processing to be removed.\r\n\r\nSyntax:\tclient_body_in_single_buffer on | off;\r\nDefault:\t\r\nclient_body_in_single_buffer off;\r\nContext:\thttp, server, location\r\nDetermines whether nginx should save the entire client request body in a single buffer. The directive is recommended when using the $request_body variable, to save the number of copy operations involved.\r\n\r\nSyntax:\tclient_body_temp_path path [level1 [level2 [level3]]];\r\nDefault:\t\r\nclient_body_temp_path client_body_temp;\r\nContext:\thttp, server, location\r\nDefines a directory for storing temporary files holding client request bodies. Up to three-level subdirectory hierarchy can be used under the specified directory. For example, in the following configuration\r\n\r\nclient_body_temp_path /spool/nginx/client_temp 1 2;\r\na path to a temporary file might look like this:\r\n\r\n/spool/nginx/client_temp/7/45/00000123457\r\nSyntax:\tclient_body_timeout time;\r\nDefault:\t\r\nclient_body_timeout 60s;\r\nContext:\thttp, server, location\r\nDefines a timeout for reading client request body. The timeout is set only for a period between two successive read operations, not for the transmission of the whole request body. If a client does not transmit anything within this time, the request is terminated with the 408 (Request Time-out) error.\r\n\r\nSyntax:\tclient_header_buffer_size size;\r\nDefault:\t\r\nclient_header_buffer_size 1k;\r\nContext:\thttp, server\r\nSets buffer size for reading client request header. For most requests, a buffer of 1K bytes is enough. However, if a request includes long cookies, or comes from a WAP client, it may not fit into 1K. If a request line or a request header field does not fit into this buffer then larger buffers, configured by the large_client_header_buffers directive, are allocated.\r\n\r\nSyntax:\tclient_header_timeout time;\r\nDefault:\t\r\nclient_header_timeout 60s;\r\nContext:\thttp, server\r\nDefines a timeout for reading client request header. If a client does not transmit the entire header within this time, the request is terminated with the 408 (Request Time-out) error.\r\n\r\nSyntax:\tclient_max_body_size size;\r\nDefault:\t\r\nclient_max_body_size 1m;\r\nContext:\thttp, server, location\r\nSets the maximum allowed size of the client request body. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size.\r\n\r\nSyntax:\tconnection_pool_size size;\r\nDefault:\t\r\nconnection_pool_size 256|512;\r\nContext:\thttp, server\r\nAllows accurate tuning of per-connection memory allocations. This directive has minimal impact on performance and should not generally be used. By default, the size is equal to 256 bytes on 32-bit platforms and 512 bytes on 64-bit platforms.\r\n\r\nPrior to version 1.9.8, the default value was 256 on all platforms.\r\nSyntax:\tdefault_type mime-type;\r\nDefault:\t\r\ndefault_type text/plain;\r\nContext:\thttp, server, location\r\nDefines the default MIME type of a response. Mapping of file name extensions to MIME types can be set with the types directive.\r\n\r\nSyntax:\tdirectio size | off;\r\nDefault:\t\r\ndirectio off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.7.7.\r\nEnables the use of the O_DIRECT flag (FreeBSD, Linux), the F_NOCACHE flag (macOS), or the directio() function (Solaris), when reading files that are larger than or equal to the specified size. The directive automatically disables (0.7.15) the use of sendfile for a given request. It can be useful for serving large files:\r\n\r\ndirectio 4m;\r\nor when using aio on Linux.\r\n\r\nSyntax:\tdirectio_alignment size;\r\nDefault:\t\r\ndirectio_alignment 512;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.8.11.\r\nSets the alignment for directio. In most cases, a 512-byte alignment is enough. However, when using XFS under Linux, it needs to be increased to 4K.\r\n\r\nSyntax:\tdisable_symlinks off;\r\ndisable_symlinks on | if_not_owner [from=part];\r\nDefault:\t\r\ndisable_symlinks off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.1.15.\r\nDetermines how symbolic links should be treated when opening files:\r\n\r\noff\r\nSymbolic links in the pathname are allowed and not checked. This is the default behavior.\r\non\r\nIf any component of the pathname is a symbolic link, access to a file is denied.\r\nif_not_owner\r\nAccess to a file is denied if any component of the pathname is a symbolic link, and the link and object that the link points to have different owners.\r\nfrom=part\r\nWhen checking symbolic links (parameters on and if_not_owner), all components of the pathname are normally checked. Checking of symbolic links in the initial part of the pathname may be avoided by specifying additionally the from=part parameter. In this case, symbolic links are checked only from the pathname component that follows the specified initial part. If the value is not an initial part of the pathname checked, the whole pathname is checked as if this parameter was not specified at all. If the value matches the whole file name, symbolic links are not checked. The parameter value can contain variables.\r\nExample:\r\n\r\ndisable_symlinks on from=$document_root;\r\nThis directive is only available on systems that have the openat() and fstatat() interfaces. Such systems include modern versions of FreeBSD, ",
    "notes": "The 2021 NGINX Annual Community Survey is now open.\r\nShare your opinion and feedback on NGINX\r\nnginx\r\n\r\nenglish\r\nрусский\r\n\r\nnews\r\nabout\r\ndownload\r\nsecurity\r\ndocumentation\r\nfaq\r\nbooks\r\nsupport\r\n\r\ntrac\r\ntwitter\r\nblog\r\n\r\nunit\r\nnjs\r\nModule ngx_http_core_module\r\n\r\nDirectives\r\n     absolute_redirect\r\n     aio\r\n     aio_write\r\n     alias\r\n     auth_delay\r\n     chunked_transfer_encoding\r\n     client_body_buffer_size\r\n     client_body_in_file_only\r\n     client_body_in_single_buffer\r\n     client_body_temp_path\r\n     client_body_timeout\r\n     client_header_buffer_size\r\n     client_header_timeout\r\n     client_max_body_size\r\n     connection_pool_size\r\n     default_type\r\n     directio\r\n     directio_alignment\r\n     disable_symlinks\r\n     error_page\r\n     etag\r\n     http\r\n     if_modified_since\r\n     ignore_invalid_headers\r\n     internal\r\n     keepalive_disable\r\n     keepalive_requests\r\n     keepalive_time\r\n     keepalive_timeout\r\n     large_client_header_buffers\r\n     limit_except\r\n     limit_rate\r\n     limit_rate_after\r\n     lingering_close\r\n     lingering_time\r\n     lingering_timeout\r\n     listen\r\n     location\r\n     log_not_found\r\n     log_subrequest\r\n     max_ranges\r\n     merge_slashes\r\n     msie_padding\r\n     msie_refresh\r\n     open_file_cache\r\n     open_file_cache_errors\r\n     open_file_cache_min_uses\r\n     open_file_cache_valid\r\n     output_buffers\r\n     port_in_redirect\r\n     postpone_output\r\n     read_ahead\r\n     recursive_error_pages\r\n     request_pool_size\r\n     reset_timedout_connection\r\n     resolver\r\n     resolver_timeout\r\n     root\r\n     satisfy\r\n     send_lowat\r\n     send_timeout\r\n     sendfile\r\n     sendfile_max_chunk\r\n     server\r\n     server_name\r\n     server_name_in_redirect\r\n     server_names_hash_bucket_size\r\n     server_names_hash_max_size\r\n     server_tokens\r\n     subrequest_output_buffer_size\r\n     tcp_nodelay\r\n     tcp_nopush\r\n     try_files\r\n     types\r\n     types_hash_bucket_size\r\n     types_hash_max_size\r\n     underscores_in_headers\r\n     variables_hash_bucket_size\r\n     variables_hash_max_size\r\nEmbedded Variables\r\nDirectives\r\n\r\nSyntax:\tabsolute_redirect on | off;\r\nDefault:\t\r\nabsolute_redirect on;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.11.8.\r\nIf disabled, redirects issued by nginx will be relative.\r\n\r\nSee also server_name_in_redirect and port_in_redirect directives.\r\n\r\nSyntax:\taio on | off | threads[=pool];\r\nDefault:\t\r\naio off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.8.11.\r\nEnables or disables the use of asynchronous file I/O (AIO) on FreeBSD and Linux:\r\n\r\nlocation /video/ {\r\n    aio            on;\r\n    output_buffers 1 64k;\r\n}\r\nOn FreeBSD, AIO can be used starting from FreeBSD 4.3. Prior to FreeBSD 11.0, AIO can either be linked statically into a kernel:\r\n\r\noptions VFS_AIO\r\nor loaded dynamically as a kernel loadable module:\r\n\r\nkldload aio\r\nOn Linux, AIO can be used starting from kernel version 2.6.22. Also, it is necessary to enable directio, or otherwise reading will be blocking:\r\n\r\nlocation /video/ {\r\n    aio            on;\r\n    directio       512;\r\n    output_buffers 1 128k;\r\n}\r\nOn Linux, directio can only be used for reading blocks that are aligned on 512-byte boundaries (or 4K for XFS). File’s unaligned end is read in blocking mode. The same holds true for byte range requests and for FLV requests not from the beginning of a file: reading of unaligned data at the beginning and end of a file will be blocking.\r\n\r\nWhen both AIO and sendfile are enabled on Linux, AIO is used for files that are larger than or equal to the size specified in the directio directive, while sendfile is used for files of smaller sizes or when directio is disabled.\r\n\r\nlocation /video/ {\r\n    sendfile       on;\r\n    aio            on;\r\n    directio       8m;\r\n}\r\nFinally, files can be read and sent using multi-threading (1.7.11), without blocking a worker process:\r\n\r\nlocation /video/ {\r\n    sendfile       on;\r\n    aio            threads;\r\n}\r\nRead and send file operations are offloaded to threads of the specified pool. If the pool name is omitted, the pool with the name “default” is used. The pool name can also be set with variables:\r\n\r\naio threads=pool$disk;\r\nBy default, multi-threading is disabled, it should be enabled with the --with-threads configuration parameter. Currently, multi-threading is compatible only with the epoll, kqueue, and eventport methods. Multi-threaded sending of files is only supported on Linux.\r\n\r\nSee also the sendfile directive.\r\n\r\nSyntax:\taio_write on | off;\r\nDefault:\t\r\naio_write off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.9.13.\r\nIf aio is enabled, specifies whether it is used for writing files. Currently, this only works when using aio threads and is limited to writing temporary files with data received from proxied servers.\r\n\r\nSyntax:\talias path;\r\nDefault:\t—\r\nContext:\tlocation\r\nDefines a replacement for the specified location. For example, with the following configuration\r\n\r\nlocation /i/ {\r\n    alias /data/w3/images/;\r\n}\r\non request of “/i/top.gif”, the file /data/w3/images/top.gif will be sent.\r\n\r\nThe path value can contain variables, except $document_root and $realpath_root.\r\n\r\nIf alias is used inside a location defined with a regular expression then such regular expression should contain captures and alias should refer to these captures (0.7.40), for example:\r\n\r\nlocation ~ ^/users/(.+\\.(?:gif|jpe?g|png))$ {\r\n    alias /data/w3/images/$1;\r\n}\r\nWhen location matches the last part of the directive’s value:\r\n\r\nlocation /images/ {\r\n    alias /data/w3/images/;\r\n}\r\nit is better to use the root directive instead:\r\n\r\nlocation /images/ {\r\n    root /data/w3;\r\n}\r\nSyntax:\tauth_delay time;\r\nDefault:\t\r\nauth_delay 0s;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.17.10.\r\nDelays processing of unauthorized requests with 401 response code to prevent timing attacks when access is limited by password, by the result of subrequest, or by JWT.\r\n\r\nSyntax:\tchunked_transfer_encoding on | off;\r\nDefault:\t\r\nchunked_transfer_encoding on;\r\nContext:\thttp, server, location\r\nAllows disabling chunked transfer encoding in HTTP/1.1. It may come in handy when using a software failing to support chunked encoding despite the standard’s requirement.\r\n\r\nSyntax:\tclient_body_buffer_size size;\r\nDefault:\t\r\nclient_body_buffer_size 8k|16k;\r\nContext:\thttp, server, location\r\nSets buffer size for reading client request body. In case the request body is larger than the buffer, the whole body or only its part is written to a temporary file. By default, buffer size is equal to two memory pages. This is 8K on x86, other 32-bit platforms, and x86-64. It is usually 16K on other 64-bit platforms.\r\n\r\nSyntax:\tclient_body_in_file_only on | clean | off;\r\nDefault:\t\r\nclient_body_in_file_only off;\r\nContext:\thttp, server, location\r\nDetermines whether nginx should save the entire client request body into a file. This directive can be used during debugging, or when using the $request_body_file variable, or the $r->request_body_file method of the module ngx_http_perl_module.\r\n\r\nWhen set to the value on, temporary files are not removed after request processing.\r\n\r\nThe value clean will cause the temporary files left after request processing to be removed.\r\n\r\nSyntax:\tclient_body_in_single_buffer on | off;\r\nDefault:\t\r\nclient_body_in_single_buffer off;\r\nContext:\thttp, server, location\r\nDetermines whether nginx should save the entire client request body in a single buffer. The directive is recommended when using the $request_body variable, to save the number of copy operations involved.\r\n\r\nSyntax:\tclient_body_temp_path path [level1 [level2 [level3]]];\r\nDefault:\t\r\nclient_body_temp_path client_body_temp;\r\nContext:\thttp, server, location\r\nDefines a directory for storing temporary files holding client request bodies. Up to three-level subdirectory hierarchy can be used under the specified directory. For example, in the following configuration\r\n\r\nclient_body_temp_path /spool/nginx/client_temp 1 2;\r\na path to a temporary file might look like this:\r\n\r\n/spool/nginx/client_temp/7/45/00000123457\r\nSyntax:\tclient_body_timeout time;\r\nDefault:\t\r\nclient_body_timeout 60s;\r\nContext:\thttp, server, location\r\nDefines a timeout for reading client request body. The timeout is set only for a period between two successive read operations, not for the transmission of the whole request body. If a client does not transmit anything within this time, the request is terminated with the 408 (Request Time-out) error.\r\n\r\nSyntax:\tclient_header_buffer_size size;\r\nDefault:\t\r\nclient_header_buffer_size 1k;\r\nContext:\thttp, server\r\nSets buffer size for reading client request header. For most requests, a buffer of 1K bytes is enough. However, if a request includes long cookies, or comes from a WAP client, it may not fit into 1K. If a request line or a request header field does not fit into this buffer then larger buffers, configured by the large_client_header_buffers directive, are allocated.\r\n\r\nSyntax:\tclient_header_timeout time;\r\nDefault:\t\r\nclient_header_timeout 60s;\r\nContext:\thttp, server\r\nDefines a timeout for reading client request header. If a client does not transmit the entire header within this time, the request is terminated with the 408 (Request Time-out) error.\r\n\r\nSyntax:\tclient_max_body_size size;\r\nDefault:\t\r\nclient_max_body_size 1m;\r\nContext:\thttp, server, location\r\nSets the maximum allowed size of the client request body. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size.\r\n\r\nSyntax:\tconnection_pool_size size;\r\nDefault:\t\r\nconnection_pool_size 256|512;\r\nContext:\thttp, server\r\nAllows accurate tuning of per-connection memory allocations. This directive has minimal impact on performance and should not generally be used. By default, the size is equal to 256 bytes on 32-bit platforms and 512 bytes on 64-bit platforms.\r\n\r\nPrior to version 1.9.8, the default value was 256 on all platforms.\r\nSyntax:\tdefault_type mime-type;\r\nDefault:\t\r\ndefault_type text/plain;\r\nContext:\thttp, server, location\r\nDefines the default MIME type of a response. Mapping of file name extensions to MIME types can be set with the types directive.\r\n\r\nSyntax:\tdirectio size | off;\r\nDefault:\t\r\ndirectio off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.7.7.\r\nEnables the use of the O_DIRECT flag (FreeBSD, Linux), the F_NOCACHE flag (macOS), or the directio() function (Solaris), when reading files that are larger than or equal to the specified size. The directive automatically disables (0.7.15) the use of sendfile for a given request. It can be useful for serving large files:\r\n\r\ndirectio 4m;\r\nor when using aio on Linux.\r\n\r\nSyntax:\tdirectio_alignment size;\r\nDefault:\t\r\ndirectio_alignment 512;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 0.8.11.\r\nSets the alignment for directio. In most cases, a 512-byte alignment is enough. However, when using XFS under Linux, it needs to be increased to 4K.\r\n\r\nSyntax:\tdisable_symlinks off;\r\ndisable_symlinks on | if_not_owner [from=part];\r\nDefault:\t\r\ndisable_symlinks off;\r\nContext:\thttp, server, location\r\nThis directive appeared in version 1.1.15.\r\nDetermines how symbolic links should be treated when opening files:\r\n\r\noff\r\nSymbolic links in the pathname are allowed and not checked. This is the default behavior.\r\non\r\nIf any component of the pathname is a symbolic link, access to a file is denied.\r\nif_not_owner\r\nAccess to a file is denied if any component of the pathname is a symbolic link, and the link and object that the link points to have different owners.\r\nfrom=part\r\nWhen checking symbolic links (parameters on and if_not_owner), all components of the pathname are normally checked. Checking of symbolic links in the initial part of the pathname may be avoided by specifying additionally the from=part parameter. In this case, symbolic links are checked only from the pathname component that follows the specified initial part. If the value is not an initial part of the pathname checked, the whole pathname is checked as if this parameter was not specified at all. If the value matches the whole file name, symbolic links are not checked. The parameter value can contain variables.\r\nExample:\r\n\r\ndisable_symlinks on from=$document_root;\r\nThis directive is only available on systems that have the openat() and fstatat() interfaces. Such systems include modern versions of FreeBSD,",
    "submit_date": "2021-10-02",
    "submitter_name": "杜顺涛",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
