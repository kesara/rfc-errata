[
  {
    "errata_id": 572,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 2.1,
    "orig_text": "The format of data blocks exchanged within the a network will generally not \r\nbe of concern to us.",
    "correct_text": "The format of data blocks exchanged within the network will generally not \r\nbe of concern to us.",
    "notes": "from pending",
    "submit_date": "2006-02-18",
    "submitter_name": "\"Yin Shuming\"",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 573,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "99A number of details in RFC 793 were corrected, modified, or clarified in RFC 1122.  Familiarity with RFC 1122 and more recent TCP documents is imperative before any implementation of RFC 793 is attempted.",
    "orig_text": "TCP Feature             RFC 793 Ref       See RFC 1122 Section\r\n\r\nReceived PUSH bit\tSection 2.8\t\t4.2.2.2\t\r\nUrgent Pointer\t\tSection 3.1\t\t4.2.2.4\r\nTCP state diagram\tSection 3.2, p.23\t4.2.2.8\r\nSimultaneous Open\tSection 3.4, Fig 8\t4.2.2.10\r\nRetransmission Timeout\tSection 3.7\t\t4.2.2.15, 4.2.3.1\r\nEvent Processing\tSection 3.9\t\t4.2.2.20\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2007-02-22",
    "submitter_name": "Robert Braden",
    "verifier_id": 2,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 574,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "99In Section 3.7, page 43, it says:",
    "orig_text": "                     If the the user signals a push function then the\r\n      data must be sent even if it is a small segment.",
    "correct_text": "                     If the user signals a push function then the\r\n      data must be sent even if it is a small segment.\r\n",
    "notes": "",
    "submit_date": "2005-05-22",
    "submitter_name": "Yin Shuming",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 575,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 2.7,
    "orig_text": "    If there are several pending passive OPENs (recorded in TCBs) with the\r\n    same local socket, an foreign active OPEN ...",
    "correct_text": "    If there are several pending passive OPENs (recorded in TCBs) with\r\n    the same local socket, a foreign active OPEN ...\r\n",
    "notes": "",
    "submit_date": "2003-10-29",
    "submitter_name": "Morris M. Keesan",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 700,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 3.7,
    "orig_text": "One procedure for determining a retransmission time out is given here as an \r\nillustration.",
    "correct_text": "One procedure for determining a retransmission timeout is given here as an \r\nillustration.",
    "notes": "from pending",
    "submit_date": "2006-02-18",
    "submitter_name": "\"Yin Shuming\"",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 701,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 3.8,
    "orig_text": "since it will be specified in detail by the specification of the lowel \r\nlevel protocol.",
    "correct_text": "since it will be specified in detail by the specification of the lower \r\nlevel protocol.",
    "notes": "from pending",
    "submit_date": "2006-02-18",
    "submitter_name": "\"Yin Shuming\"",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 784,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.2,
    "orig_text": "                              +---------+ ---------\\      active OPEN  \r\n                              |  CLOSED |            \\    -----------  \r\n                              +---------+<---------\\   \\   create TCB  \r\n                                |     ^              \\   \\  snd SYN    \r\n                   passive OPEN |     |   CLOSE        \\   \\           \r\n                   ------------ |     | ----------       \\   \\         \r\n                    create TCB  |     | delete TCB         \\   \\       \r\n                                V     |                      \\   \\     \r\n                              +---------+            CLOSE    |    \\   \r\n                              |  LISTEN |          ---------- |     |  \r\n                              +---------+          delete TCB |     |  \r\n                   rcv SYN      |     |     SEND              |     |  \r\n                  -----------   |     |    -------            |     V  \r\n +---------+      snd SYN,ACK  /       \\   snd SYN          +---------+\r\n |         |<-----------------           ------------------>|         |\r\n |   SYN   |                    rcv SYN                     |   SYN   |\r\n |   RCVD  |<-----------------------------------------------|   SENT  |\r\n |         |                    snd ACK                     |         |\r\n |         |------------------           -------------------|         |\r\n +---------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +---------+\r\n   |           --------------   |     |   -----------                  \r\n   |                  x         |     |     snd ACK                    \r\n   |                            V     V                                \r\n   |  CLOSE                   +---------+                              \r\n   | -------                  |  ESTAB  |                              \r\n   | snd FIN                  +---------+                              \r\n   |                   CLOSE    |     |    rcv FIN                     \r\n   V                  -------   |     |    -------                     \r\n +---------+          snd FIN  /       \\   snd ACK          +---------+\r\n |  FIN    |<-----------------           ------------------>|  CLOSE  |\r\n | WAIT-1  |------------------                              |   WAIT  |\r\n +---------+          rcv FIN  \\                            +---------+\r\n   | rcv ACK of FIN   -------   |                            CLOSE  |  \r\n   | --------------   snd ACK   |                           ------- |  \r\n   V        x                   V                           snd FIN V  \r\n +---------+                  +---------+                   +---------+\r\n |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|\r\n +---------+                  +---------+                   +---------+\r\n   |                rcv ACK of FIN |                 rcv ACK of FIN |  \r\n   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  \r\n   |  -------              x       V    ------------        x       V  \r\n    \\ snd ACK                 +---------+delete TCB         +---------+\r\n     ------------------------>|TIME WAIT|------------------>| CLOSED  |\r\n                              +---------+                   +---------+\r\n\r\n                      TCP Connection State Diagram\r\n                               Figure 6.",
    "correct_text": "[not supplied]",
    "notes": "Compare with RFC 1122:\r\n\r\n\" 4.2.2.8  TCP Connection State Diagram: RFC-793 Section 3.2,\r\n    page 23\r\n\r\n    There are several problems with this diagram:\r\n\r\n    (a)  The arrow from SYN-SENT to SYN-RCVD should be labeled\r\n         with \"snd SYN,ACK\", to agree with the text on page 68\r\n         and with Figure 8.\"\r\n\r\nEither RFC1122 is wrong (in which case *it* needs an Errata entry), or\r\nRFC793 is wrong, in which case *it* needs an Errata entry.  They can't\r\nboth be right!\r\n\r\nBecause of the above protocol diagram change given in RFC1122 (and others\r\nin the same section), RFC1122 should also be mentioned as \"updating\"\r\nRFC793, and RFC793 should be documented as being \"updated by\" RFC1122.\r\n\r\nfrom pending\n --VERIFIER NOTES-- \nThe RFC Editor has been instructed to indicate in their database and web pages that RFC1122 updates RFC0793. This errata has hence been addressed.   ",
    "submit_date": "2006-09-22",
    "submitter_name": "Ian D. Allen",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1283,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 3.3,
    "orig_text": " One way to deal with this problem is to deliberately delay emitting\r\n    segments for one MSL after recovery from a crash- this is the \"quite\r\n    time\" specification.  Hosts which prefer to avoid waiting are\r\n    willing to risk possible confusion of old and new packets at a given\r\n    destination may choose not to wait for the \"quite time\".\r\n    Implementors may provide TCP users with the ability to select on a\r\n    connection by connection basis whether to wait after a crash, or may\r\n    informally implement the \"quite time\" for all connections.\r\n    Obviously, even where a user selects to \"wait,\" this is not\r\n    necessary after the host has been \"up\" for at least MSL seconds.",
    "correct_text": " One way to deal with this problem is to deliberately delay emitting\r\n    segments for one MSL after recovery from a crash- this is the \"quiet\r\n    time\" specification.  Hosts which prefer to avoid waiting are\r\n    willing to risk possible confusion of old and new packets at a given\r\n    destination may choose not to wait for the \"quiet time\".\r\n    Implementors may provide TCP users with the ability to select on a\r\n    connection by connection basis whether to wait after a crash, or may\r\n    informally implement the \"quiet time\" for all connections.\r\n    Obviously, even where a user selects to \"wait,\" this is not\r\n    necessary after the host has been \"up\" for at least MSL seconds.",
    "notes": "\"quite time\" should be \"quiet time\"",
    "submit_date": "2008-01-14",
    "submitter_name": "Pei-chun Cheng",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1496,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "CLOSE CALL\r\n\r\n\r\n  CLOSE-WAIT STATE\r\n    Queue this request until all preceding SENDs have been segmentized;then send a FIN segment,enter CLOSING state.\r\n\r\n  CLOSING STATE\r\n  LAST-ACK STATE\r\n  TIME-WAIT STATE\r\n  \r\n    Respond with \"error: connection closing\".",
    "correct_text": "CLOSE CALL\r\n\r\n\r\n  CLOSE-WAIT STATE\r\n    Queue this request until all preceding SENDs have been segmentized;then send a FIN segment,enter LAST-ACK  state.\r\n\r\n  CLOSING STATE\r\n  LAST-ACK STATE\r\n  TIME-WAIT STATE\r\n  \r\n    Respond with \"error: connection closing\".",
    "notes": "In Page 23,Figure 6.\"TCP Connection State Diagram\",illustrates the state change from \"CLOSE-WAIT\" TO \"LAST-ACK\",together with the causing event \"CLOSE\".\n --VERIFIER NOTES-- \nRFC 1122 updates RFC 793 and includes the changes noted in this errata already in section 4.2.2.20.",
    "submit_date": "2008-08-27",
    "submitter_name": "Yin Shuming",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1561,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 3.2,
    "orig_text": "    LAST-ACK - represents waiting for an acknowledgment of the\r\n    connection termination request previously sent to the remote TCP\r\n    (which includes an acknowledgment of its connection termination\r\n    request).\r\n",
    "correct_text": "    LAST-ACK - represents waiting for an acknowledgment of the\r\n    connection termination request previously sent to the remote TCP\r\n    (The connection termination request sent to the remote TCP included\r\n    an acknowledgment of the connection termination request sent from\r\n    the remote TCP).\r\n",
    "notes": "It is unclear what 'which' and 'its' refers to.",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1562,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 3.3,
    "orig_text": "Remember that each segment is bound to as many consecutive sequence numbers as\r\nthere are octets of data in the segment.\r\n...\r\nthe numbers occupied by a segment are \"busy\" or \"in use\" until MSL seconds have\r\npassed, upon crashing a block of space-time is occupied by the octets of the\r\nlast emitted segment,",
    "correct_text": "Remember that each segment is bound to as many consecutive sequence numbers as\r\nthere are octets of data and SYN or FIN flags in the segment.\r\n...\r\nthe numbers occupied by a segment are \"busy\" or \"in use\" until MSL seconds have\r\npassed, upon crashing a block of space-time is occupied by the octets and SYN or\r\nFIN flags of the last emitted segment,",
    "notes": "I changed this text to specifically include the SYN and FIN bits, rather than the previous errata wording which was unclear since other control flags are not part of the sequence space, based on discussion on the TCPM mailing list which indicated that the prior wording was confusing.",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 2,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1563,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.4,
    "orig_text": "Reset Generation\r\n    3.  If the connection is in a synchronized state (ESTABLISHED,\r\n    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),\r\n    any unacceptable segment (out of window sequence number or\r\n    unacceptible acknowledgment number) must elicit only an empty\r\n    acknowledgment segment containing the current send-sequence number\r\n    and an acknowledgment indicating the next sequence number expected\r\n    to be received, and the connection remains in the same state.\r\n\r\n    If an incoming segment has a security level, or compartment, or\r\n    precedence which does not exactly match the level, and compartment,\r\n    and precedence requested for the connection,a reset is sent and\r\n    connection goes to the CLOSED state. The reset takes its sequence\r\n    number from the ACK field of the incoming segment.",
    "correct_text": "Reset Generation\r\n    3.  If the connection is in a synchronized state (ESTABLISHED,\r\n    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),\r\n    any unacceptable segment (out of window sequence number or\r\n    unacceptable acknowledgment number) must elicit only an empty\r\n    acknowledgment segment containing the current send-sequence number\r\n    and an acknowledgment indicating the next sequence number expected\r\n    to be received, and the connection remains in the same state.\r\n\r\n    If an incoming segment has a security level, or compartment, or\r\n    precedence which does not exactly match the level, and compartment,\r\n    and precedence requested for the connection, a reset is sent and\r\n    the connection goes to the CLOSED state.\r\n    If the incoming segment has the ACK bit set, the reset takes its\r\n    sequence number from the ACK field of the segment, otherwise the\r\n    reset has sequence number zero and the ACK field is set to the sum\r\n    of the sequence number and segment length of the incoming segment.\r\n    A SYN with a sequence number inside the receive window yields a\r\n    reset, too.",
    "notes": "Four errors, two editorial and two technical\r\n1. Typo unacceptible -> unacceptable\r\n2. wrong spacing and missing 'the'\r\n3. The ACK bit should be set. But this check comes later. See page 71.\r\n4. According to page 71 a SYN can cause a reset, too.\r\n --VERIFIER NOTES-- \r\nI split the editorial corrections into another errata report and accepted them as \"hold for document update\".  The technical corrections are being rejected due to RFC 1122 updating 793 and already including clarification on setting SEQ=0 and ACK=SEG.SEQ+SEG.LEN, as suggested by this errata submission.",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 2,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1564,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 3.7,
    "orig_text": "When the sender creates a segment and transmits it the sender advances\r\nSND.NXT.  When the receiver accepts a segment it advances RCV.NXT and\r\nsends an acknowledgment.  When the data sender receives an\r\nacknowledgment it advances SND.UNA.  The extent to which the values of\r\nthese variables differ is a measure of the delay in the communication.\r\nThe amount by which the variables are advanced is the length of the\r\ndata in the segment.  Note that once in the ESTABLISHED state all\r\nsegments must carry current acknowledgment information.\r\n",
    "correct_text": "When the sender creates a segment and transmits it the sender advances\r\nSND.NXT.  When the receiver accepts a segment it advances RCV.NXT and\r\nsends an acknowledgment.  When the data sender receives an\r\nacknowledgment it advances SND.UNA.  The extent to which the values of\r\nthese variables differ is a measure of the delay in the communication.\r\nThe amount by which the variables are advanced is the length of the\r\ndata and SYN or FIN flags in the segment.  Note that\r\nonce in the ESTABLISHED state all segments must carry current acknowledgment information.\r\n",
    "notes": "SYN and FIN are counted, too",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1565,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 3.8,
    "orig_text": "TCP/Lower-Level Interface\r\n\r\n      Type of Service = Precedence: routine, Delay: normal, Throughput:\r\n      normal, Reliability: normal; or 00000000.\r\n",
    "correct_text": "TCP/Lower-Level Interface\r\n\r\n      Type of Service = Precedence, Delay: normal, Throughput:\r\n      normal, Reliability: normal; or XXX00000.\r\n      where XXX are the three bits determining precedence, e.g. 000\r\n      means routine.\r\n",
    "notes": "The precedence is given by the user.",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1566,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "OPEN Call\r\nLISTEN STATE\r\n      Data associated with SEND may be sent with SYN segment or\r\n      queued for transmission after entering ESTABLISHED state.  The\r\n      urgent bit if requested in the command must be sent with the data\r\n      segments sent as a result of this command.",
    "correct_text": "OPEN Call\r\nLISTEN STATE\r\n      --delete this--",
    "notes": "This is an OPEN call. There is no data associated with a SEND.\r\nBTW, What WND to set in the SYN segment? Set RCV.WND=1?\n --VERIFIER NOTES-- \nThis is \"may\" and does not produce incorrect protocol behavior, so there is no reason to remove it.  This rejection was validated through consulting with the TCPM list.",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1567,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "SEND Call\r\nLISTEN STATE\r\n      If the foreign socket is specified, then change the connection\r\n      from passive to active, select an ISS.  Send a SYN segment, set\r\n      SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data\r\n      associated with SEND may be sent with SYN segment or queued for\r\n      transmission after entering ESTABLISHED state.  The urgent bit if\r\n      requested in the command must be sent with the data segments sent\r\n      as a result of this command.  If there is no room to queue the\r\n      request, respond with \"error:  insufficient resources\".  If\r\n      Foreign socket was not specified, then return \"error:  foreign\r\n      socket unspecified\".",
    "correct_text": "SEND Call\r\nLISTEN STATE\r\n      If the foreign socket is specified, then change the connection\r\n      from passive to active, select an ISS.  Send a SYN segment, set\r\n      SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data\r\n      associated with SEND may be sent with SYN segment or queued for\r\n      transmission after entering ESTABLISHED state. If data is sent with\r\n      the SYN segment, SND.NXT is advanced.    The urgent bit if\r\n      requested in the command must be sent with the data segments sent\r\n      as a result of this command.  If there is no room to queue the\r\n      request, respond with \"error:  insufficient resources\".  If\r\n      Foreign socket was not specified, then return \"error:  foreign\r\n      socket unspecified\".",
    "notes": "If data is sent, SND.NXT has to be advanced.\r\n\r\nBut there are more problems.\r\nWhat WND to set in the SYN segment? Set RCV.WND=1?\r\nHow much data may be put into the segment? There is no SND.WND yet.\r\nWhat about PUSH? May the data be queued if a PUSH is given?\n --VERIFIER NOTES-- \nAs discussed on the TCPM Working Group mailing list in 2012:\r\n\r\n   According to the errata, there is some ambiguity in RFC 793 regarding data in SYNs.\r\n   This requires changes beyond the suggested errata text, and thus we believe\r\n   this issue should be done in a separate RFC.   \r\n",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wesley Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1568,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "SEGMENT ARRIVES\r\n If the state is LISTEN then\r\n  third check for a SYN\r\n        The connection\r\n        state should be changed to SYN-RECEIVED.  Note that any other\r\n        incoming control or data (combined with SYN) will be processed\r\n        in the SYN-RECEIVED state, but processing of SYN and ACK should\r\n        not be repeated.\r\n  fourth other text or control\r\n        Any other control or text-bearing segment (not containing SYN)\r\n        must have an ACK and thus would be discarded by the ACK\r\n        processing.  An incoming RST segment could not be valid, since\r\n        it could not have been sent in response to anything sent by this\r\n        incarnation of the connection.  So you are unlikely to get here,\r\n If the state is SYN-SENT then\r\n  first check the ACK bit\r\n        If SND.UNA =< SEG.ACK =< SND.NXT then the ACK is acceptable.\r\n  fourth check the SYN bit\r\n        This step should be reached only if the ACK is ok, or there is\r\n        no ACK, and it the segment did not contain a RST.\r\n\r\n        If the SYN bit is on and the security/compartment and precedence\r\n        are acceptable then, RCV.NXT is set to SEG.SEQ+1, IRS is set to\r\n        SEG.SEQ.\r\n        ...\r\n        Data or controls which were queued for\r\n        transmission may be included.\r\n  fifth, if neither of the SYN or RST bits is set then drop the\r\n        segment and return.\r\n Otherwise,\r\n  third check security and precedence\r\n  fifth check the ACK field,\r\n   SYN-RECEIVED STATE\r\n    If SND.UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state\r\n    and continue processing.\r\n    If the segment acknowledgment is not acceptable, form a\r\n    reset segment,\r\n\r\n      <SEQ=SEG.ACK><CTL=RST>\r\n\r\n    and send it.\r\n   ESTABLISHED STATE\r\n    If SND.UNA < SEG.ACK =< SND.NXT then, set SND.UNA <- SEG.ACK.\r\n    Any segments on the retransmission queue which are thereby\r\n    entirely acknowledged are removed.  Users should receive\r\n    positive acknowledgments for buffers which have been SENT and\r\n    fully acknowledged (i.e., SEND buffer should be returned with\r\n    \"ok\" response).  If the ACK is a duplicate\r\n    (SEG.ACK < SND.UNA), it can be ignored.  If the ACK acks\r\n    something not yet sent (SEG.ACK > SND.NXT) then send an ACK,\r\n    drop the segment, and return.\r\n\r\n    If SND.UNA < SEG.ACK =< SND.NXT, the send window should be\r\n    updated.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ and\r\n    SND.WL2 =< SEG.ACK)), set SND.WND <- SEG.WND, set\r\n    SND.WL1 <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.\r\n  eighth, check the FIN bit,\r\n   Do not process the FIN if the state is CLOSED, LISTEN or SYN-SENT\r\n   since the SEG.SEQ cannot be validated; drop the segment and\r\n   return.\r\n",
    "correct_text": "SEGMENT ARRIVES\r\n If the state is LISTEN then\r\n  third check for a SYN\r\n        ??? No idea. But the original does not work.\r\n        If there is data in the SYN, we have a problem. We have to be\r\n        ESTABLISHED to get a buffer. And in ESTABLISHED the segment will be\r\n        dropped, because it has the ACK bit off.\r\n        We need to allocate a buffer. It's just for one segment. And we have\r\n        to adapt the event handling for the user's RECEIVE call. ???\r\n  fourth other text or control\r\n        Any other control or text-bearing segment (not containing SYN)\r\n        must have an ACK and thus would be discarded by the ACK\r\n        processing. So you are unlikely to get here,\r\n If the state is SYN-SENT then\r\n  first check the ACK bit\r\n        If SND.UNA < SEG.ACK =< SND.NXT then the ACK is acceptable.\r\n  fourth check the SYN bit\r\n        This step should be reached only if the ACK is ok, or there is\r\n        no ACK, and if the segment did not contain a RST.\r\n\r\n        If the SYN bit is on, RCV.NXT is set to SEG.SEQ+1, IRS is set to\r\n        SEG.SEQ.\r\n        ...\r\n        Data or controls which were queued for\r\n        transmission may be included and SND.NXT advanced accordingly.\r\n  fifth, because neither of the SYN or RST bits is set, drop the\r\n        segment and return.\r\n Otherwise,\r\n  third check security and precedence\r\n       Construct the RST in this way:\r\n          If there is an ACK\r\n\r\n            <SEQ=SEG.ACK><CTL=RST>\r\n\r\n          Otherwise\r\n\r\n            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\r\n  fifth check the ACK field,\r\n   SYN-RECEIVED STATE\r\n    If SND.UNA < SEG.ACK =< SND.NXT then enter ESTABLISHED state, set\r\n    SND.WND <- SEG.WND, SND.WL1 <- SEG.SEQ, SND.WL2 <- SEG.ACK,\r\n    and continue processing.\r\n    If the segment acknowledgment is not acceptable\r\n    (SEG.ACK =< ISS or SEG.ACK > SND.NXT), form a\r\n    reset segment,\r\n\r\n      <SEQ=SEG.ACK><CTL=RST>\r\n\r\n    and send it.\r\n    Drop the segment. Return.\r\n   ESTABLISHED STATE\r\n    If the ACK is a duplicate (SEG.ACK =< SND.UNA), it can be\r\n    ignored.  If the ACK acks something not yet sent\r\n    (SEG.ACK > SND.NXT) then send an ACK, drop the segment, and\r\n    return.\r\n    If SND.UNA =< SEG.ACK =< SND.NXT, the send window should be\r\n    updated.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ and\r\n    SND.WL2 =< SEG.ACK)), set SND.WND <- SEG.WND, set\r\n    SND.WL1 <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.\r\n    If SND.UNA < SEG.ACK =< SND.NXT, then set SND.UNA <- SEG.ACK.\r\n    Any segments on the retransmission queue which are thereby\r\n    entirely acknowledged are removed.  Users should receive\r\n    positive acknowledgments for buffers which have been SENT and\r\n    fully acknowledged (i.e., SEND buffer should be returned with\r\n    \"ok\" response).\r\n  eighth, check the FIN bit,\r\n   --delete this--\r\n",
    "notes": "If the state is LISTEN then\r\n fourth other text or control\r\n  Incoming RST are already thrown out. Don't diskuss about it here.\r\nIf the state is SYN-SENT then\r\n  first check the ACK bit\r\n   nearly the same as the correction in RFC-1122 4.2.2.20(g)\r\n  fourth check the SYN bit\r\n   typo it -> if\r\n   security/compartment and precedence are already checked. It is no mistake,\r\n    but it is superfluous and confusing.\r\n   don't forget to advance SND.NXT\r\n  fifth\r\n   No more testing is necessary. Superfluous testing is confusing.\r\nOtherwise,\r\n  third check security and precedence\r\n   The ACK bit is not yet checked.\r\n  fifth check the ACK field\r\n   SYN-RECEIVED STATE\r\n    SND.UNA == ISS. SEG.ACK == ISS does not ack our SYN.\r\n    SND.WND <- SEG.WND etc is corrected by RFC-1122.\r\n    explanation of not acceptable acknowledgment is helpful\r\n    'Drop the segment. Return.' is missing, too.\r\n   ESTABLISHED STATE\r\n    Corrections of RFC-1122 are included.\r\n    What about SEG.ACK =< ISS? I reccomend to send an ACK, drop the segment\r\n     and return. When SND.NXT overpaces ISS, ISS has to be adjusted somehow,\r\n     e.g. ISS <- ISS xor 0x80000000.\r\n    The updating of SND.UNA must be in the end, because the comparisations\r\n     need the old value of SND.UNA.\r\n  eighth, check the FIN bit,\r\n   If you are here, you are not in those states.\n --VERIFIER NOTES-- \nAs discussed on the TCPM Working Group mailing list in 2012:\r\n\r\n   This errata combines several different suggestions. Some of them repeat updates of RFC 1122,\r\n   some are subtle minor hints, and in some cases the errata does not propose better phrasing.\r\n   The errata cannot be accepted in this form. It might be worth to consider individual aspects\r\n   separately.   ",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wesley Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1569,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 2.4,
    "orig_text": "The TCP/internet interface provides calls to send and receive\r\ndatagrams addressed to TCP modules in hosts anywhere in the internet\r\nsystem.",
    "correct_text": "The TCP/internet interface provides calls to send datagrams addressed\r\nto and receive datagrams addressed from TCP modules in hosts anywhere\r\nin the internet system.",
    "notes": "scnr",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wesley Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1570,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 2.7,
    "orig_text": "There are two principal cases for matching the sockets in the local\r\npassive OPENs and an foreign active OPENs.  In the first case, the\r\nlocal passive OPENs has fully specified the foreign socket.  In this\r\ncase, the match must be exact.  In the second case, the local passive\r\nOPENs has left the foreign socket unspecified.  In this case, any\r\nforeign socket is acceptable as long as the local sockets match.",
    "correct_text": "There are two principal cases for matching the sockets in the local\r\npassive OPENs and a foreign active OPEN.  In the first case, there\r\nis exactly one local passive OPEN with matching local socket that\r\nhas fully specified the foreign socket.  In this case, the match must\r\nbe exact.  In the second case, there is exactly one local passive\r\nOPEN with matching local socket that has left the foreign socket\r\nunspecified.  In this case, any foreign socket is acceptable.\r\n",
    "notes": "In this passage singular or plural make a big difference.\n --VERIFIER NOTES-- \nAs discussed on the TCPM Working Group mailing list in 2012:\r\n\r\nWe believe that the original text is not confusing and a change of the meaning is not required.",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wesley Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1571,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 3.1,
    "orig_text": "Maximum Segment Size Option Data:  16 bits\r\n\r\n          If this option is present, then it communicates the maximum\r\n          receive segment size at the TCP which sends this segment.\r\n          This field must only be sent in the initial connection request\r\n          (i.e., in segments with the SYN control bit set).  If this\r\n          option is not used, any segment size is allowed.\r\n\r\n",
    "correct_text": "Maximum Segment Size Option Data:  16 bits\r\n\r\n          If this option is present, then it communicates the maximum\r\n          receive segment size at the TCP which sends this segment.\r\n          This field may be sent in the initial connection request\r\n          (i.e., in segments with the SYN control bit set) and must not\r\n          be sent in other segments.  If this option is not used, any\r\n          segment size is allowed.\r\n\r\n",
    "notes": "'must only' is ambiguous or even senseless.",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wesley Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1572,
    "doc-id": "RFC0793",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 3.4,
    "orig_text": "If the incoming segment has an ACK field, the reset takes its\r\nsequence number from the ACK field of the segment, otherwise the\r\nreset has sequence number zero and the ACK field is set to the sum\r\nof the sequence number and segment length of the incoming segment.\r\n",
    "correct_text": "If the incoming segment has the ACK bit set, the reset takes its\r\nsequence number from the ACK field of the segment, otherwise the\r\nreset has sequence number zero and the ACK field is set to the sum\r\nof the sequence number and segment length of the incoming segment.\r\n",
    "notes": "Every segment has an ACK field.",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2296,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3,
    "orig_text": "  The security paramaters may be used even in a non-secure environment\r\n  (the values would indicate unclassified data), thus hosts in\r\n  non-secure environments must be prepared to receive the security\r\n  parameters, though they need not send them.",
    "correct_text": "  The security parameters may be used even in a non-secure environment\r\n  (the values would indicate unclassified data), thus hosts in\r\n  non-secure environments must be prepared to receive the security\r\n  parameters, though they need not send them.",
    "notes": "s/paramaters/parameters/",
    "submit_date": "2010-06-03",
    "submitter_name": "Vishwas Manral",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2297,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.8,
    "orig_text": "    Any lower level protocol will have to provide the source address,\r\n    destination address, and protocol fields, and some way to determine\r\n    the \"TCP length\", both to provide the functional equivlent service\r\n    of IP and to be used in the TCP checksum.",
    "correct_text": "    Any lower level protocol will have to provide the source address,\r\n    destination address, and protocol fields, and some way to determine\r\n    the \"TCP length\", both to provide the functional equivalent service\r\n    of IP and to be used in the TCP checksum.",
    "notes": "s/equivlent/equivalent/",
    "submit_date": "2010-06-03",
    "submitter_name": "Vishwas Manral",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2298,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "Page 74",
    "orig_text": "Once the TCP takes responsibility for the data it advances\r\nRCV.NXT over the data accepted, and adjusts RCV.WND as\r\napporopriate to the current buffer availability",
    "correct_text": "Once the TCP takes responsibility for the data it advances\r\nRCV.NXT over the data accepted, and adjusts RCV.WND as\r\nappropriate to the current buffer availability",
    "notes": "s/apporopriate/appropriate/",
    "submit_date": "2010-06-03",
    "submitter_name": "Vishwas Manral",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2748,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 2.8,
    "orig_text": "2.8.  Data Communication\r\n\r\n  The data that flows on a connection may be thought of as a stream of\r\n  octets.  The sending user indicates in each SEND call whether the data\r\n  in that call (and any preceeding calls) should be immediately pushed\r\n  through to the receiving user by the setting of the PUSH flag.\r\n",
    "correct_text": "2.8.  Data Communication\r\n\r\n  The data that flows on a connection may be thought of as a stream of\r\n  octets.  The sending user indicates in each SEND call whether the data\r\n  in that call (and any preceding calls) should be immediately pushed\r\n  through to the receiving user by the setting of the PUSH flag.\r\n",
    "notes": "s/preceeding/preceding",
    "submit_date": "2011-03-13",
    "submitter_name": "Mykyta Yevstifeyev",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2749,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.2,
    "orig_text": " NOTE BENE:  this diagram is only a summary and must not be taken as\r\n the total specification.\r\n\r\n",
    "correct_text": " NOTA BENE:  this diagram is only a summary and must not be taken as\r\n the total specification.\r\n\r\n",
    "notes": "The Latin phrase is correctly written 'Nota bene', but not 'Note bene'.",
    "submit_date": "2011-03-13",
    "submitter_name": "Mykyta Yevstifeyev",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2771,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "GLOBAL",
    "orig_text": null,
    "correct_text": null,
    "notes": "RFC 793 has no regulations whether it should obsolete RFC 761, which, however, is logically obvious.  RFC 761 (http://tools.ietf.org/html/rfc761) is the previous version of RFC 793 and, if this errata report is verified, should be marked as obsoleted by RFC 793.\n --VERIFIER NOTES-- \nThis is not a technical matter, and should refer to the RFC metadata rather than the document.",
    "submit_date": "2011-04-08",
    "submitter_name": "Mykyta Yevstifeyev",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2934,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.4,
    "orig_text": "Reset Generation\r\n    3.  If the connection is in a synchronized state (ESTABLISHED,\r\n    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),\r\n    any unacceptable segment (out of window sequence number or\r\n    unacceptible acknowledgment number) must elicit only an empty\r\n    acknowledgment segment containing the current send-sequence number\r\n    and an acknowledgment indicating the next sequence number expected\r\n    to be received, and the connection remains in the same state.\r\n\r\n    If an incoming segment has a security level, or compartment, or\r\n    precedence which does not exactly match the level, and compartment,\r\n    and precedence requested for the connection,a reset is sent and\r\n    connection goes to the CLOSED state. The reset takes its sequence\r\n    number from the ACK field of the incoming segment.",
    "correct_text": "Reset Generation\r\n    3.  If the connection is in a synchronized state (ESTABLISHED,\r\n    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),\r\n    any unacceptable segment (out of window sequence number or\r\n    unacceptable acknowledgment number) must elicit only an empty\r\n    acknowledgment segment containing the current send-sequence number\r\n    and an acknowledgment indicating the next sequence number expected\r\n    to be received, and the connection remains in the same state.\r\n\r\n    If an incoming segment has a security level, or compartment, or\r\n    precedence which does not exactly match the level, and compartment,\r\n    and precedence requested for the connection, a reset is sent and\r\n    the connection goes to the CLOSED state.  The reset takes its sequence\r\n    number from the ACK field of the incoming segment.\r\n  ",
    "notes": "Editorial errors:\r\n1. Typo unacceptible -> unacceptable\r\n2. wrong spacing and missing 'the'\r\n",
    "submit_date": "2008-10-11",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 2,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3213,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.9,
    "orig_text": "Segments with higher begining sequence\r\nnumbers may be held for later processing.\r\n",
    "correct_text": "Segments with higher beginning sequence\r\nnumbers may be held for later processing.\r\n",
    "notes": "\"begning\" should be \"beginning\"",
    "submit_date": "2012-05-05",
    "submitter_name": "Yi, EungJun",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3300,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "SEGMENT ARRIVES\r\nSYN-SENT STATE\r\n\r\nIf the ACK bit is set\r\n\r\n          If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless\r\n          the RST bit is set, if so drop the segment and return)\r\n\r\n            <SEQ=SEG.ACK><CTL=RST>\r\n\r\n          and discard the segment.  Return.\r\n\r\n          If SND.UNA =< SEG.ACK =< SND.NXT then the ACK is acceptable.",
    "correct_text": "SEGMENT ARRIVES\r\nSYN-SENT STATE\r\n\r\nIf the ACK bit is set\r\n\r\n          If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless\r\n          the RST bit is set, if so drop the segment and return)\r\n\r\n            <SEQ=SEG.ACK><CTL=RST>\r\n\r\n          and discard the segment.  Return.\r\n\r\n          If SND.UNA < SEG.ACK =< SND.NXT then the ACK is acceptable.",
    "notes": "In SYN-SENT, SND.UNA == ISS, so the first line is contradictory to the last.\r\n\r\nVerifier Notes:\r\n\r\nThis is being Held for Document Update rather than Verified because technically the algorithm is still correct, as the first check against ISS will fail and cause a reset to be generated.  The second sentence that has an off-by-one error appears to be merely a paraphrasing.\r\n\r\nIn practice today, much code seems to be simplifying further and checking that SEG.ACK == SND.NXT, for stacks that are not sending data on the SYN, so I do not believe this text is leading to any significant issue with bugs or interoperability in the wild.\r\n",
    "submit_date": "2012-07-30",
    "submitter_name": "Botong Huang",
    "verifier_id": 2,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3301,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "SEGMENT ARRIVES\r\nOtherwise (Other States)\r\nfifth check the ACK field\r\np71\r\n\r\n     if the ACK bit is on\r\n\r\n        SYN-RECEIVED STATE\r\n\r\n          If SND.UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state\r\n          and continue processing.\r\n\r\n\r\n            If the segment acknowledgment is not acceptable, form a\r\n            reset segment,\r\n\r\n              <SEQ=SEG.ACK><CTL=RST>\r\n\r\n            and send it.",
    "correct_text": "SEGMENT ARRIVES\r\nOtherwise (Other States)\r\nfifth check the ACK field\r\np71\r\n\r\n     if the ACK bit is on\r\n\r\n        SYN-RECEIVED STATE\r\n\r\n          If SND.UNA < SEG.ACK =< SND.NXT then enter ESTABLISHED state\r\n          and continue processing.\r\n\r\n\r\n            If the segment acknowledgment is not acceptable, form a\r\n            reset segment,\r\n\r\n              <SEQ=SEG.ACK><CTL=RST>\r\n\r\n            and send it.",
    "notes": "In SYN-RECEIVE, SND.UNA == ISS. When the first ACK arrive with SEG.ACK == SND.UNA, it should be not accepted and thus transfer to ESTABLISHED state. This doesn't seem to be in rfc1122. Not sure if it is reported somewhere.\r\n\r\n\r\nVerifier Note:\r\nThe side sending generating a packet that would erroneously check out would either be in error itself for generating the packet (not following the standard), or the packet would be extremely old (from a prior connection), and the responses should generate RSTs.  Existing code seems to already be implementing this correctly, so I do not think there is an interoperability issue.",
    "submit_date": "2012-07-30",
    "submitter_name": "Botong Huang",
    "verifier_id": 129,
    "verifier_name": "Wes Eddy",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3305,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "p70\r\nSEGMENT ARRIVES\r\n   Otherwise,\r\n   first check sequence number\r\n\r\n      SYN-RECEIVED STATE\r\n      ESTABLISHED STATE\r\n      FIN-WAIT-1 STATE\r\n      FIN-WAIT-2 STATE\r\n      CLOSE-WAIT STATE\r\n      CLOSING STATE\r\n      LAST-ACK STATE\r\n      TIME-WAIT STATE\r\n\r\n        Segments are processed in sequence.  Initial tests on arrival\r\n        are used to discard old duplicates, but further processing is\r\n        done in SEG.SEQ order.  If a segment's contents straddle the\r\n        boundary between old and new, only the new parts should be\r\n        processed.\r\n\r\n        There are four cases for the acceptability test for an incoming\r\n        segment:\r\n\r\n        Segment Receive  Test\r\n        Length  Window\r\n        ------- -------  -------------------------------------------\r\n\r\n           0       0     SEG.SEQ = RCV.NXT\r\n\r\n           0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\r\n\r\n          >0       0     not acceptable\r\n\r\n          >0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\r\n                      or RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND\r\n",
    "correct_text": "Added my Martin Stiemerling (TSV AD):\r\nA document update will address this problem and the TCPM working is\r\nexpected to find a solution. ",
    "notes": "Not sure how to correct it systemmatically, so I just present the problem. \r\n\r\nIf in SYN-RECEIVED state, and received a SYN-ACK packet with no data as:\r\nSEG.SEQ = IRS\r\nSEG.ACK = ISS + 1\r\n\r\nHowever in SYN-RECEIVED state, RCV.NXT = IRS + 1, which means the SYN-ACK packet will fail on the second test above. The SYN-ACK packet will be dropped and a ACK packet is sent in reply. As a result, we lost the SYN part, but it is fine because we've already received SYN packet once. However, we also lost the ACK part which is supposed to be the ACK of our SYN. Thus we will never reach the ESTABLISH state.",
    "submit_date": "2012-07-31",
    "submitter_name": "Botong Huang",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3602,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.4,
    "orig_text": "5. SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...\r\n\r\n6. ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED\r\n\r\n7.              ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED\r\n\r\n              Simultaneous Connection Synchronization\r\n\r\n                             Figure 8.",
    "correct_text": "5. SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...\r\n\r\n6. ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED\r\n\r\n7.              ... <SEQ=100><ACK=301><CTL=SYN,ACK> --> ESTABLISHED\r\n\r\n              Simultaneous Connection Synchronization\r\n\r\n                             Figure 8.",
    "notes": "\n --VERIFIER NOTES-- \nSee errata 573. Already done, thanks.",
    "submit_date": "2013-04-21",
    "submitter_name": "Dahai Jiang",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3972,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.1,
    "orig_text": " Reserved:  6 bits\r\n\r\n    Reserved for future use.  Must be zero.\r\n",
    "correct_text": " Reserved:  6 bits\r\n\r\n    Reserved for future use.  SHOULD be zero.\r\n",
    "notes": "RFC3168 specifies 2 additional bits (ECE and CWR), RFC3540 specifies one additional bit (NS). Even though RFC793 predates RFC2119, and section 2.10 states\r\n\" be conservative in what you do, be liberal in what you accept from others.\", any\r\nupdate to this RFC should adjust the wording apropriately.\n --VERIFIER NOTES-- \nThe text is correct, as is. For implementations implementing RFC 793 purely the have to set this to zero.",
    "submit_date": "2014-04-23",
    "submitter_name": "Richard Scheffenegger",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4314,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.3,
    "orig_text": "Since the maximum segment\r\nlifetime in the net is not likely to exceed a few tens of seconds,\r\nthis is deemed ample protection for foreseeable nets, even if data\r\nrates escalate to l0's of megabits/sec.  At 100 megabits/sec, the\r\ncycle time is 5.4 minutes which may be a little short, but still\r\nwithin reason.",
    "correct_text": "Since the maximum segment\r\nlifetime in the net is not likely to exceed a few tens of seconds,\r\nthis is deemed ample protection for foreseeable nets, even if data\r\nrates escalate to 10's of megabits/sec.  At 100 megabits/sec, the\r\ncycle time is 5.4 minutes which may be a little short, but still\r\nwithin reason.",
    "notes": "s/l0/10",
    "submit_date": "2015-03-26",
    "submitter_name": "Ramakrishna Rao DTV",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4566,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.9,
    "orig_text": "If the segment empties and carries an PUSH flag,",
    "correct_text": "If the segment empties and carries a PUSH flag,",
    "notes": null,
    "submit_date": "2015-12-16",
    "submitter_name": "Michael Welzl",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4580,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 2.7,
    "orig_text": "This exchange has been termed a three-way hand shake.",
    "correct_text": "This exchange has been termed a three-way handshake.",
    "notes": null,
    "submit_date": "2016-01-05",
    "submitter_name": "Masoud Valizadeh",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4753,
    "doc-id": "RFC0793",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 1.5,
    "orig_text": "A pair of sockets uniquely identifies each connection.\r\nThat is, a socket may be simultaneously used in multiple\r\nconnections",
    "correct_text": "A pair of sockets uniquely identifies each connection. Sockets can be\r\nclassified into client and server sockets. Typically a server socket \r\nmay be simultaneously used in multiple connections.",
    "notes": "TCP is connection oriented therefore when we say \"sockets used in multiple connections\" it implies that the context is TCP.  Considering their use in TCP,  though a single client socket can be implemented in a way to multiplex it for connection with multiple server sockets and exchange different SYN segments but then its  same what a server process listening for connections on server port does typically. \r\n\r\nI feel classification of sockets here is vital to facilitate understand implicitly that in what use-case can a socket be typically multiplexed while still keeping generality of the statement.\n --VERIFIER NOTES-- \n   TCP sockets don't have a client/server concept therefore this clarification is inappropriate.",
    "submit_date": "2016-07-30",
    "submitter_name": "Sanjeev Ranot",
    "verifier_id": 153,
    "verifier_name": "Mirja Kühlewind",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4785,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "3.9  p. 72",
    "orig_text": "\r\nIf the ACK is a duplicate\r\n(SEG.ACK < SND.UNA), it can be ignored.",
    "correct_text": "If the ACK is a duplicate\r\n(SEG.ACK =< SND.UNA), it can be ignored except when equality is met, \r\nthen window should be updated. This can happen when there are \r\nsegments in flight but the receiver shrinks its RCV.BUF to drop all \r\nof them and send an ACK carrying zero window update. Upon its \r\narrival at the sending TCP, condition SND.UNA = SEG.ACK is met and \r\nwe must update SND.WND <- 0. Then sender starts persist timer for \r\nsending zero-window probes [Ref. RFC 1122 Section 4.2.2.17, page 92]\r\n\r\n\r\n\r\n",
    "notes": "The condition is corrected as Duplicate ACK in \r\nRFC 1122, Section 4.2.2.20 (g) p. 94. Accordingly old text must be \r\nmodified and new text should also be present to support the corrected \r\ncondition in RFC 793. \r\n\r\nThis is one case where duplicate acknowledgment cannot be ignored. i.e. \r\nwhen SEG.ACK == SND.UNA and advertised window in the incoming ACK is 0\r\nin which case sender needs to :\r\n1. update window\r\n2. start persist timer\r\n3. send zero window probe segments. \r\n\r\n\r\nNote:\r\nSuch ACKs should not be called as duplicates as it fails condition (e) \r\nof definition of \"DUPLICATE ACKNOWLEDGMENT\" in Ref 5681 Section 2, pg 4",
    "submit_date": "2016-08-20",
    "submitter_name": "Sanjeev Ranot",
    "verifier_id": 153,
    "verifier_name": "Mirja Kühlewind",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 6222,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.4,
    "orig_text": "  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\r\n\r\n  8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED\r\n\r\n                    Recovery from Old Duplicate SYN\r\n\r\n                               Figure 9.",
    "correct_text": "  7.  ESTABLISHED <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\r\n\r\n  8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED\r\n\r\n                    Recovery from Old Duplicate SYN\r\n\r\n                               Figure 9.",
    "notes": "To align with figure 7 in the same section, after TCP A get the SYN+ACK from TCP B, TCP A should enter ESTABLISHED state instead stay in SYN-SENT state.",
    "submit_date": "2020-07-06",
    "submitter_name": "Charles Deng",
    "verifier_id": 167,
    "verifier_name": "Martin Duke",
    "update_date": "2020-07-06 17:11:22"
  },
  {
    "errata_id": 6281,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.4,
    "orig_text": "  At line 4, TCP A responds with an empty segment containing an ACK for\r\n  TCP B's SYN; and in line 5, TCP A sends some data.  Note that the\r\n  sequence number of the segment in line 5 is the same as in line 4\r\n  because the ACK does not occupy sequence number space (if it did, we\r\n  would wind up ACKing ACK's!).\r\n",
    "correct_text": "  At line 4, TCP A responds with an empty segment containing an ACK for\r\n  TCP B's SYN; and in line 5, TCP A sends some data.  Note that the\r\n  sequence number of the segment in line 5 is the same as in line 4\r\n  because the ACK does not occupy sequence number space (if it did, we\r\n  would wind up ACKing ACKs!).\r\n",
    "notes": "last line: \"ACK's\" -> \"ACKs\"",
    "submit_date": "2020-09-06",
    "submitter_name": "Merlin Büge",
    "verifier_id": 167,
    "verifier_name": "Martin Duke",
    "update_date": "2020-10-12 14:14:02"
  },
  {
    "errata_id": 6282,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.3,
    "orig_text": "  To avoid confusion we must prevent segments from one incarnation of a\r\n  connection from being used while the same sequence numbers may still\r\n  be present in the network from an earlier incarnation.  We want to\r\n  assure this, even if a TCP crashes and loses all knowledge of the\r\n  sequence numbers it has been using.  When new connections are created,\r\n  an initial sequence number (ISN) generator is employed which selects a\r\n  new 32 bit ISN.  The generator is bound to a (possibly fictitious) 32\r\n  bit clock whose low order bit is incremented roughly every 4\r\n  microseconds.  Thus, the ISN cycles approximately every 4.55 hours.\r\n  Since we assume that segments will stay in the network no more than\r\n  the Maximum Segment Lifetime (MSL) and that the MSL is less than 4.55\r\n  hours we can reasonably assume that ISN's will be unique.\r\n\r\n  For each connection there is a send sequence number and a receive\r\n  sequence number.  The initial send sequence number (ISS) is chosen by\r\n  the data sending TCP, and the initial receive sequence number (IRS) is\r\n  learned during the connection establishing procedure.\r\n\r\n  For a connection to be established or initialized, the two TCPs must\r\n  synchronize on each other's initial sequence numbers.  This is done in\r\n  an exchange of connection establishing segments carrying a control bit\r\n  called \"SYN\" (for synchronize) and the initial sequence numbers.  As a\r\n  shorthand, segments carrying the SYN bit are also called \"SYNs\".\r\n  Hence, the solution requires a suitable mechanism for picking an\r\n  initial sequence number and a slightly involved handshake to exchange\r\n  the ISN's.\r\n\r\n  The synchronization requires each side to send it's own initial\r\n  sequence number and to receive a confirmation of it in acknowledgment\r\n  from the other side.  Each side must also receive the other side's\r\n  initial sequence number and send a confirming acknowledgment.\r\n\r\n    1) A --> B  SYN my sequence number is X\r\n    2) A <-- B  ACK your sequence number is X\r\n    3) A <-- B  SYN my sequence number is Y\r\n    4) A --> B  ACK your sequence number is Y\r\n\r\n  Because steps 2 and 3 can be combined in a single message this is\r\n  called the three way (or three message) handshake.\r\n\r\n  A three way handshake is necessary because sequence numbers are not\r\n  tied to a global clock in the network, and TCPs may have different\r\n  mechanisms for picking the ISN's.  The receiver of the first SYN has\r\n  no way of knowing whether the segment was an old delayed one or not,\r\n  unless it remembers the last sequence number used on the connection\r\n  (which is not always possible), and so it must ask the sender to\r\n  verify this SYN.  The three way handshake and the advantages of a\r\n  clock-driven scheme are discussed in [3].\r\n",
    "correct_text": "  To avoid confusion we must prevent segments from one incarnation of a\r\n  connection from being used while the same sequence numbers may still\r\n  be present in the network from an earlier incarnation.  We want to\r\n  assure this, even if a TCP crashes and loses all knowledge of the\r\n  sequence numbers it has been using.  When new connections are created,\r\n  an initial sequence number (ISN) generator is employed which selects a\r\n  new 32 bit ISN.  The generator is bound to a (possibly fictitious) 32\r\n  bit clock whose low order bit is incremented roughly every 4\r\n  microseconds.  Thus, the ISN cycles approximately every 4.55 hours.\r\n  Since we assume that segments will stay in the network no more than\r\n  the Maximum Segment Lifetime (MSL) and that the MSL is less than 4.55\r\n  hours we can reasonably assume that ISNs will be unique.\r\n\r\n  For each connection there is a send sequence number and a receive\r\n  sequence number.  The initial send sequence number (ISS) is chosen by\r\n  the data sending TCP, and the initial receive sequence number (IRS) is\r\n  learned during the connection establishing procedure.\r\n\r\n  For a connection to be established or initialized, the two TCPs must\r\n  synchronize on each other's initial sequence numbers.  This is done in\r\n  an exchange of connection establishing segments carrying a control bit\r\n  called \"SYN\" (for synchronize) and the initial sequence numbers.  As a\r\n  shorthand, segments carrying the SYN bit are also called \"SYNs\".\r\n  Hence, the solution requires a suitable mechanism for picking an\r\n  initial sequence number and a slightly involved handshake to exchange\r\n  the ISNs.\r\n\r\n  The synchronization requires each side to send it's own initial\r\n  sequence number and to receive a confirmation of it in acknowledgment\r\n  from the other side.  Each side must also receive the other side's\r\n  initial sequence number and send a confirming acknowledgment.\r\n\r\n    1) A --> B  SYN my sequence number is X\r\n    2) A <-- B  ACK your sequence number is X\r\n    3) A <-- B  SYN my sequence number is Y\r\n    4) A --> B  ACK your sequence number is Y\r\n\r\n  Because steps 2 and 3 can be combined in a single message this is\r\n  called the three way (or three message) handshake.\r\n\r\n  A three way handshake is necessary because sequence numbers are not\r\n  tied to a global clock in the network, and TCPs may have different\r\n  mechanisms for picking the ISNs.  The receiver of the first SYN has\r\n  no way of knowing whether the segment was an old delayed one or not,\r\n  unless it remembers the last sequence number used on the connection\r\n  (which is not always possible), and so it must ask the sender to\r\n  verify this SYN.  The three way handshake and the advantages of a\r\n  clock-driven scheme are discussed in [3].\r\n",
    "notes": "The only change: s/ISN's/ISNs/g\r\n\"ISN's\" has three matches in the whole RFC, all of them in this section, and all matches refer to the plural form of ISN.\r\nISN stands for \"initial sequence number\".\r\nSorry for all the bulk text.",
    "submit_date": "2020-09-06",
    "submitter_name": "Merlin Büge",
    "verifier_id": 167,
    "verifier_name": "Martin Duke",
    "update_date": "2020-10-12 14:18:08"
  },
  {
    "errata_id": 6305,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "3.9 Page 67",
    "orig_text": "      fourth check the SYN bit\r\n\r\n        This step should be reached only if the ACK is ok, or there is\r\n        no ACK, and it the segment did not contain a RST.\r\n",
    "correct_text": "      fourth check the SYN bit\r\n\r\n        This step should be reached only if the ACK is ok, or there is\r\n        no ACK, and the segment did not contain a RST.\r\n",
    "notes": "In the last sentence, the 'it' in 'and it the segment' is redundant.",
    "submit_date": "2020-10-12",
    "submitter_name": "Shuo Chen",
    "verifier_id": 167,
    "verifier_name": "Martin Duke",
    "update_date": "2020-10-12 14:24:42"
  },
  {
    "errata_id": 6476,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.8,
    "orig_text": "        connection.Implementers may want to give the user control of",
    "correct_text": "        connection. Implementers may want to give the user control of",
    "notes": "Missing space. 793bis is in progress and this text no longer exists.",
    "submit_date": "2021-03-12",
    "submitter_name": "Ivan Panchenko",
    "verifier_id": 167,
    "verifier_name": "Martin Duke",
    "update_date": "2021-03-16 16:36:26"
  },
  {
    "errata_id": 6477,
    "doc-id": "RFC0793",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "GLOSSARY",
    "orig_text": "          unit of data transfered between a pair of TCP modules.",
    "correct_text": "          unit of data transferred between a pair of TCP modules.",
    "notes": "Misspelled \"transferred\".\r\n\r\n(text does not exist in ongoing 793bis)",
    "submit_date": "2021-03-12",
    "submitter_name": "Ivan Panchenko",
    "verifier_id": 167,
    "verifier_name": "Martin Duke",
    "update_date": "2021-03-16 16:42:28"
  }
]
