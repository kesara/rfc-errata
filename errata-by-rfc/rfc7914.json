[
  {
    "errata_id": "5871",
    "doc-id": "RFC7914",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.1",
    "orig_text": "   scrypt-0 {1 3 6 1 4 1 11591 4 10}\r\n\r\n   DEFINITIONS ::= BEGIN\r\n\r\n   id-scrypt OBJECT IDENTIFIER ::= {1 3 6 1 4 1 11591 4 11}\r\n\r\n   scrypt-params ::= SEQUENCE {\r\n       salt OCTET STRING,\r\n       costParameter INTEGER (1..MAX),\r\n       blockSize INTEGER (1..MAX),\r\n       parallelizationParameter INTEGER (1..MAX),\r\n       keyLength INTEGER (1..MAX) OPTIONAL\r\n   }\r\n\r\n   PBES2-KDFs ALGORITHM-IDENTIFIER ::=\r\n          { {scrypt-params IDENTIFIED BY id-scrypt}, ... }\r\n\r\n   END",
    "correct_text": "   Module-scrypt-0 {1 3 6 1 4 1 11591 4 10}\r\n\r\n   DEFINITIONS ::= BEGIN\r\n\r\n   IMPORTS\r\n     ALGORITHM-IDENTIFIER\r\n       FROM PKCS5v2-0 -- [RFC2898]\r\n         { iso(1) member-body(2) us(840) rsadsi(113549)\r\n           pkcs(1) pkcs-5(5) modules(16) pkcs5v2-0(1) } ;\r\n\r\n   id-scrypt OBJECT IDENTIFIER ::= {1 3 6 1 4 1 11591 4 11}\r\n\r\n   Scrypt-params ::= SEQUENCE {\r\n       salt OCTET STRING,\r\n       costParameter INTEGER (1..MAX),\r\n       blockSize INTEGER (1..MAX),\r\n       parallelizationParameter INTEGER (1..MAX),\r\n       keyLength INTEGER (1..MAX) OPTIONAL\r\n   }\r\n\r\n   PBES2-KDFs ALGORITHM-IDENTIFIER ::=\r\n          { {Scrypt-params IDENTIFIED BY id-scrypt}, ... }\r\n\r\n   END",
    "notes": "The ASN.1 module does not compile without some minor corrections.\r\n\r\nFirst, ALGORITHM-IDENTIFIER needs to be defined.  The simplest solution is to IMPORT it from RFC 2898.\r\n\r\nSecond, the module name and the scrypt-params structure name must begin with capital letters.  Small changes are made to meet these ASN.1 requirements.",
    "submit_date": "2019-10-07",
    "submitter_name": "Russ Housley",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-10-10 00:44:31"
  },
  {
    "errata_id": "5971",
    "doc-id": "RFC7914",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "2",
    "orig_text": "The CPU/Memory cost parameter N (\"costParameter\") must be larger than 1, a power of 2, and less than 2^(128 * r / 8).",
    "correct_text": "The CPU/Memory cost parameter N (\"costParameter\") must be larger than 1, and a power of 2.",
    "notes": "The presented limit on N was incorrectly derived from the original scrypt publication. The correct theoretical upper limit on N is 2^(128 * r) for r < 5, and 2^512 for all other values of r. Thus, the least upper bound is 2^128, which far exceeds all possible values for N in the foreseeable future, making the limit irrelevant for current implementations.",
    "submit_date": "2020-02-02",
    "submitter_name": "Tobias Nießen",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2020-02-24 19:52:25"
  },
  {
    "errata_id": "5972",
    "doc-id": "RFC7914",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5",
    "orig_text": "Input:\r\n         r       Block size parameter.\r\n         B       Input octet vector of length 128 * r octets.\r\n         N       CPU/Memory cost parameter, must be larger than 1,\r\n                 a power of 2, and less than 2^(128 * r / 8).",
    "correct_text": "Input:\r\n         r       Block size parameter.\r\n         B       Input octet vector of length 128 * r octets.\r\n         N       CPU/Memory cost parameter, must be larger than 1,\r\n                 and a power of 2.",
    "notes": "The presented limit on N was incorrectly derived from the original scrypt publication. The correct theoretical upper limit on N is 2^(128 * r) for r < 5, and 2^512 for all other values of r. Thus, the least upper bound is 2^128, which far exceeds all possible values for N in the foreseeable future, making the limit irrelevant for current implementations.",
    "submit_date": "2020-02-02",
    "submitter_name": "Tobias Nießen",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2020-02-24 19:52:46"
  },
  {
    "errata_id": "5973",
    "doc-id": "RFC7914",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "6",
    "orig_text": "Input:\r\n         P       Passphrase, an octet string.\r\n         S       Salt, an octet string.\r\n         N       CPU/Memory cost parameter, must be larger than 1,\r\n                 a power of 2, and less than 2^(128 * r / 8).\r\n         r       Block size parameter.\r\n         p       Parallelization parameter, a positive integer\r\n                 less than or equal to ((2^32-1) * hLen) / MFLen\r\n                 where hLen is 32 and MFlen is 128 * r.\r\n         dkLen   Intended output length in octets of the derived\r\n                 key; a positive integer less than or equal to\r\n                 (2^32 - 1) * hLen where hLen is 32.",
    "correct_text": "Input:\r\n         P       Passphrase, an octet string.\r\n         S       Salt, an octet string.\r\n         N       CPU/Memory cost parameter, must be larger than 1,\r\n                 and a power of 2.\r\n         r       Block size parameter.\r\n         p       Parallelization parameter, a positive integer\r\n                 less than or equal to ((2^32-1) * hLen) / MFLen\r\n                 where hLen is 32 and MFlen is 128 * r.\r\n         dkLen   Intended output length in octets of the derived\r\n                 key; a positive integer less than or equal to\r\n                 (2^32 - 1) * hLen where hLen is 32.",
    "notes": "The presented limit on N was incorrectly derived from the original scrypt publication. The correct theoretical upper limit on N is 2^(128 * r) for r < 5, and 2^512 for all other values of r. Thus, the least upper bound is 2^128, which far exceeds all possible values for N in the foreseeable future, making the limit irrelevant for current implementations.",
    "submit_date": "2020-02-02",
    "submitter_name": "Tobias Nießen",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2020-02-24 19:53:06"
  },
  {
    "errata_id": "6452",
    "doc-id": "RFC7914",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5",
    "orig_text": "     3. for i = 0 to N - 1 do\r\n          j = Integerify (X) mod N\r\n                 where Integerify (B[0] ... B[2 * r - 1]) is defined\r\n                 as the result of interpreting B[2 * r - 1] as a\r\n                 little-endian integer.",
    "correct_text": "     3. for i = 0 to N - 1 do\r\n          j = Integerify (X) mod N\r\n                 where Integerify (B[0] ... B[2 * r - 1]) is defined\r\n                 as the result of interpreting B[r] ... B[r + 3] as a\r\n                 little-endian integer.",
    "notes": "The original description of Integerify looks, to a programmer, as though a single byte (the final octet) is being converted to an integer (as with the Python `ord` operation). But that wouldn't make sense with the term \"little-endian\", which has meaning only with multiple-byte words. So the likely conclusion would be that this was a typographical error, and that the entire string X (or B) should be treated as an integer [e.g., Python3 int.from_bytes(b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff', 'little')]. However, this interpretation of Integerify gives results that do not match the test vectors.\r\n\r\nBy looking at other people's code (https://github.com/ricmoo/pyscrypt in particular) I found that using the 4 bytes beginning halfway through the octet string gives results which do match the test vectors.",
    "submit_date": "2021-03-05",
    "submitter_name": "John Comeau",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "6972",
    "doc-id": "RFC7914",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "2",
    "orig_text": "At the current time, r=8 and p=1 appears to yield good results, but as memory latency and CPU parallelism increase, it is likely that the optimum values for both r and p will increase.",
    "correct_text": "At the current time, r=8 and p=1 appears to yield good results, but as memory latency decrease and CPU parallelism increase, it is likely that the optimum values for both r and p will increase.",
    "notes": "The wording in itself is a bit unclear, but the phrase \"but as memory latency and CPU parallelism increase\" might be interpreted as \"but as memory latency increase and CPU parallelism increase\", which in combination with the following phrase \"it is likely that the optimum values for both r and p will increase\" is inconsistent with how scrypt operates. All other things being equal (including but not limited to the parameters used and CPU or ASIC performance), the scrypt algorithm have an inverse-proportional relationship to memory latency, especially if the low-latency memory can contain all of the temporary computational data the algorithm needs.\r\n\r\nPaul Wouters(AD): This seems correct, but as scrypt has been surpassed by argon2 (RFC9106) marked as Verified as no document update is expected for scrypt.",
    "submit_date": "2022-05-11",
    "submitter_name": "Gacel Perfinian",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-01-16 17:29:38"
  }
]
