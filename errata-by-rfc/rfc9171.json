[
  {
    "errata_id": "7272",
    "doc-id": "RFC9171",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.5.1.1",
    "orig_text": "dtn-hier-part = \"//\" node-name name-delim demux ; a path-rootless\r\n\r\nnode-name = reg-name\r\n\r\ndemux = *VCHAR\r\n",
    "correct_text": "dtn-hier-part = \"//\" node-name name-delim demux [ \"?\" query ]\r\n\r\nnode-name = reg-name\r\n\r\ndemux = path-rootless / path-empty\r\n",
    "notes": "The demux portion of an EID should match only URI path segments and not match query or fragment URI parts. A fragment part should not actually be sent as encoded EID to be consistent with other URI uses (e.g. HTTP). The administrative endpoint is the allowed empty demux path.",
    "submit_date": "2022-12-12",
    "submitter_name": "Brian Sipos",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7337",
    "doc-id": "RFC9171",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Appendix B",
    "orig_text": "   ; Actual CBOR data embedded in a byte string, with optional tag to\r\n   indicate so.\r\n \r\n...\r\n \r\n   ; Extension block type, which does not specialize other than the\r\n   code/number\r\n\r\n...\r\n\r\n   payload-block = payload-block-structure .within canonical-block-\r\n   structure\r\n",
    "correct_text": "   ; Actual CBOR data embedded in a byte string, with optional tag to\r\n   ; indicate so.\r\n\r\n... \r\n \r\n   ; Extension block type, which does not specialize other than the\r\n   ; code/number\r\n\r\n...\r\n\r\n   payload-block = payload-block-structure .within\r\n                   canonical-block-structure\r\n",
    "notes": "Various line breaking events cause syntax errors while parsing Appendix B.",
    "submit_date": "2023-02-06",
    "submitter_name": "Carsten Bormann",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7881",
    "doc-id": "RFC9171",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "6.1.1",
    "orig_text": "   The first element of each bundle status item SHALL be a status\r\n   indicator, a Boolean value indicating whether or not the\r\n   corresponding bundle status is asserted, encoded as a CBOR Boolean\r\n   value.",
    "correct_text": "   The first element of each bundle status item SHALL be a status\r\n   indicator, a Boolean value indicating whether or not the\r\n   corresponding bundle status is asserted, encoded as a CBOR simple\r\n   value.  A value of 'true' SHALL be encoded as a CBOR simple value\r\n   with additional information 21.  A value of 'false' SHALL be encoded\r\n   as a CBOR simple value with additional information 20.",
    "notes": "The CBOR spec does not define a 'Boolean' type (RFC8949). It's become common practice to encode boolean values as simple values (major type 7), with additional information 21 indicating 'true' and additional information 20 indicating 'false' (RFC9254, RFC8152). However, this should be explicitly stated for clarity.\r\n\r\n--- comments ---\r\n\r\nThe original text refers to \"Boolean values\" and not to any \"Boolean type\"; it is technically correct as is.\r\n\r\nAs noted, CBOR doesn't have a specific \"type\" per se for a Boolean, but RFC 8948 S3.3 clearly specifies an encoding for `true` and `false`.\r\n\r\nThat said, there might be room here for additional clarity for implementers if there is ever to be a 9171bis.",
    "submit_date": "2024-04-03",
    "submitter_name": "John Huff",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2024-04-07 16:12:46"
  },
  {
    "errata_id": "8043",
    "doc-id": "RFC9171",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.3.1",
    "orig_text": "   CRC:  A CRC SHALL be present in the primary block unless the bundle\r\n      includes a BPSec Block Integrity Block [BPSEC] whose target is the\r\n      primary block, in which case a CRC MAY be present in the primary\r\n      block.  The length and nature of the CRC SHALL be as indicated by\r\n      the CRC type.  The CRC SHALL be computed over the concatenation of\r\n      all bytes (including CBOR \"break\" characters) of the primary block\r\n      including the CRC field itself, which, for this purpose, SHALL be\r\n      temporarily populated with all bytes set to zero.",
    "correct_text": "   CRC:  A CRC SHALL be present in the primary block unless the bundle\r\n      includes a BPSec Block Integrity Block [BPSEC] whose target is the\r\n      primary block, in which case a CRC MAY be present in the primary\r\n      block.  The length and nature of the CRC SHALL be as indicated by\r\n      the CRC type.  The CRC SHALL be computed over the concatenation of\r\n      all bytes (including CBOR \"break\" characters) of the primary block\r\n      including the CRC field itself, which, for this purpose, SHALL be\r\n      temporarily populated with all value bytes set to zero. The\r\n      initial byte of the CBOR encoded CRC field SHALL remain unchanged.",
    "notes": "There was some confusion about the wording of \"temporarily populated with all bytes set to zero\" when talking about the CRC field in the CBOR encoded primary block. An implementer thought this might mean to also zeroize the intial byte(s) of the CBOR encoded byte string that represents the CRC field. This correction makes it clear that only the bytes that represent the value of the CRC field should be zeroized when calculating the CRC.\r\n\r\nMy correction uses \"initial byte\" because the current CRC types will only ever have a single intial byte when encoding the CRC value as a CBOR byte string. However, technically CBOR byte strings can byte more than 1 initial byte so it may be better to use \"initial byte(s)\".",
    "submit_date": "2024-07-22",
    "submitter_name": "John Huff",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2024-07-25 10:59:40"
  }
]
