[
  {
    "errata_id": 2094,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 6.1,
    "orig_text": " - the value of S1 is written into the first bit of N1;\r\n\r\n   - the value of S2 is written into the second bit of N1 (etc.);\r\n\r\n   - the value of S32 is written into the 32nd bit of N1;\r\n\r\n   - the value of S33 is written into the first bit of N2;\r\n\r\n   - the value of S34 is written into the 33th bit of N2 (etc.);\r\n\r\n   - the value of S64 is written into the 32nd bit of N2.\r\n",
    "correct_text": " - the value of S1 is written into the first bit of N1;\r\n\r\n   - the value of S2 is written into the second bit of N1 (etc.);\r\n\r\n   - the value of S32 is written into the 32nd bit of N1;\r\n\r\n   - the value of S33 is written into the first bit of N2;\r\n\r\n   - the value of S34 is written into the second bit of N2 (etc.);\r\n\r\n   - the value of S64 is written into the 32nd bit of N2.\r\n",
    "notes": "",
    "submit_date": "2010-03-23",
    "submitter_name": "V. Dolmatov",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2134,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "Abstract",
    "orig_text": "   This document is intended to be a source of information about the\r\n   Russian Federal standard for electronic encryption, decryption, and\r\n   message authentication algorithms (GOST 28147-89), which is one of\r\n   the Russian cryptographic standard algorithms called GOST\r\n   algorithms).",
    "correct_text": "   This document is intended to be a source of information about the\r\n   Russian Federal standard for electronic encryption, decryption, and\r\n   message authentication algorithms (GOST 28147-89), which is one of\r\n   the Russian cryptographic standard algorithms called GOST\r\n   algorithms.",
    "notes": null,
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2135,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 7.1,
    "orig_text": "   The plain text is divided into 64-bit blocks Tp(1), Tp(2), ..., Tp(M)\r\n   and encrypted in the cipher feedback mode by bitwise addition modulo\r\n   2 in the adder CM5 with the running key Gc generated in 64-bit\r\n   blocks, i.e., Gc(i)=(Gc(1), Gc(2), ..., Gc(M)), where M is defined by\r\n                                                                   ___\r\n   the length of the plain text, Gc(i) is the i-th 64-bit block, i=1,M.\r\n   The number of bits in the block Tp(M) may be less than 64.\r\n",
    "correct_text": "   The plain text is divided into 64-bit blocks Tp(1), Tp(2), ..., Tp(M)\r\n   and encrypted in the cipher feedback mode by bitwise addition modulo\r\n   2 in the adder CM5 with the running key Gc generated in 64-bit\r\n   blocks, i.e., Gc(i)=(Gc(1), Gc(2), ..., Gc(M)), where M is defined by\r\n   the length of the plain text, Gc(i) is the i-th 64-bit block, i=1,M.\r\n   The number of bits in the block Tp(M) may be less than 64.\r\n",
    "notes": null,
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2136,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 3.1,
    "orig_text": "   Initialisation vector: initial values of plain parameters of a\r\n   cryptographic transformation algorithm.\r\n",
    "correct_text": "   Initialization vector: initial values of plain parameters of a\r\n   cryptographic transformation algorithm.\r\n",
    "notes": null,
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2137,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 3.1,
    "orig_text": "   Cipher: a set of reversible transformations of the set of possible\r\n   plain texts onto the set of encrypted data, made after certain rules\r\n   and using keys.\r\n",
    "correct_text": "   Cipher: a set of reversible transformations of the set of possible\r\n   plain texts onto the set of encrypted data carried out by specified \r\n   rules with the use of keys.\r\n",
    "notes": "\"After\" does not mean \"as a result.\"",
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2138,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 4,
    "orig_text": "   When writing a key (W1, W2, ..., W256), Wq = 0..1, q = 1..256, in the\r\n   KDS the value:\r\n\r\n   - W1 is written into the 1st bit of the register X0;\r\n\r\n   - the value W2 is written into the 2nd bit of the register X0 (etc.);\r\n\r\n   - the value W32 is written into the 32nd bit of the register X0;\r\n\r\n   - the value W33 is written into the 1st bit of the register X1;\r\n\r\n   - the value W34 is written into the 2nd bit of the register X1\r\n     (etc.);\r\n\r\n   - the value W64 is written into the 32nd bit of the register X1;\r\n\r\n   - the value W65 is written into the 1st bit of the register X2\r\n     (etc.);\r\n\r\n   - the value W256 is written into the 32nd bit of the register X7.\r\n\r\n",
    "correct_text": "   When writing a key (W1, W2, ..., W256), Wq = 0..1, q = 1..256, in the\r\n   KDS:\r\n\r\n   - the value W1 is written into the 1st bit of the register X0;\r\n\r\n   - the value W2 is written into the 2nd bit of the register X0 (etc.);\r\n\r\n   - the value W32 is written into the 32nd bit of the register X0;\r\n\r\n   - the value W33 is written into the 1st bit of the register X1;\r\n\r\n   - the value W34 is written into the 2nd bit of the register X1\r\n     (etc.);\r\n\r\n   - the value W64 is written into the 32nd bit of the register X1;\r\n\r\n   - the value W65 is written into the 1st bit of the register X2\r\n     (etc.);\r\n\r\n   - the value W256 is written into the 32nd bit of the register X7.\r\n\r\n",
    "notes": null,
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2139,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 5.1,
    "orig_text": "   The plain text to be encrypted is split into 64-bit blocks.  Input of\r\n   a binary data block Tp = (a1(0), a2(0), ... , a31(0), a32(0), b1(0),\r\n   b2(0), ..., b32(0)) into the registers N1 and N2 is done so that the\r\n   value of a1(0) is put into the first bit of N1, the value of a2(0) is\r\n   put into the second bit of N1, etc., and the value of a32(0) is put\r\n   into the 32nd bit of N1.  The value of b1(0) is put into the first\r\n   bit of N2, the value of b2(0) is put into the 2nd bit of N2, etc.,\r\n   and the value of b32(0) is input into the 32nd bit of N2.\r\n",
    "correct_text": "   The plain text to be encrypted is split into 64-bit blocks.  Input of\r\n   any binary data block Tp = (a1(0), a2(0), ... , a31(0), a32(0), b1(0),\r\n   b2(0), ..., b32(0)) into the registers N1 and N2 is done so that the\r\n   value of a1(0) is put into the first bit of N1, the value of a2(0) is\r\n   put into the second bit of N1, etc., and the value of a32(0) is put\r\n   into the 32nd bit of N1.  The value of b1(0) is put into the first\r\n   bit of N2, the value of b2(0) is put into the 2nd bit of N2, etc.,\r\n   and the value of b32(0) is input into the 32nd bit of N2.\r\n",
    "notes": null,
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2140,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 5.2,
    "orig_text": "   The fillings of the adders N1 and N2 after 32 working rounds are a\r\n   plain text block.\r\n",
    "correct_text": "   After 32 working rounds contents of registers N1 and N2 are a plain text block.",
    "notes": "N1 and N2 aren't adders.",
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2141,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 5.2,
    "orig_text": "      A(Tp) is A(a(0), b(0)) = (a(32), b(32)) = Tc.\r\n",
    "correct_text": "      A(Tp) = A(a(0), b(0)) = (a(32), b(32)) = Tc.\r\n",
    "notes": null,
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2144,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 6.1,
    "orig_text": "   The filling of N1 and N2 is encrypted in the electronic codebook mode\r\n   according to the requirements of section 5.1.  The resulting\r\n   encrypted filling of N1 and N2 is the second 64-bit block of the\r\n   running key Gc(2); this block is bitwise added modulo 2 in the adder\r\n   CM5 with the first 64-bit block of the plain text Tp(2).  ",
    "correct_text": "   The filling of N1 and N2 is encrypted in the electronic codebook mode\r\n   according to the requirements of section 5.1.  The resulting\r\n   encrypted filling of N1 and N2 is the second 64-bit block of the\r\n   running key Gc(2); this block is bitwise added modulo 2 in the adder\r\n   CM5 with the second 64-bit block of the plain text Tp(2).  ",
    "notes": null,
    "submit_date": "2010-04-08",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2145,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 7.1,
    "orig_text": "   The plain text is divided into 64-bit blocks Tp(1), Tp(2), ..., Tp(M)\r\n   and encrypted in the cipher feedback mode by bitwise addition modulo\r\n   2 in the adder CM5 with the running key Gc generated in 64-bit\r\n   blocks, i.e., Gc(i)=(Gc(1), Gc(2), ..., Gc(M)), where M is defined by\r\n                                                                   ___\r\n   the length of the plain text, Gc(i) is the i-th 64-bit block, i=1,M.\r\n   The number of bits in the block Tp(M) may be less than 64.\r\n",
    "correct_text": "   The plain text is divided into 64-bit blocks Tp(1), Tp(2), ..., Tp(M)\r\n   and encrypted in the cipher feedback mode by bitwise addition modulo\r\n   2 in the adder CM5 with the running key Gc generated in 64-bit\r\n   blocks, i.e., Gc(i)=(Gc(1), Gc(2), ..., Gc(M)), where M is defined by\r\n   the length of the plain text, Gc(i) is the i-th 64-bit block, i=1..M.\r\n   The number of bits in the block Tp(M) may be less than 64.\r\n",
    "notes": null,
    "submit_date": "2010-04-09",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2146,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 7.1,
    "orig_text": "   The initial filling of N1 and N2 is encrypted in the electronic\r\n   codebook mode in accordance with the requirements in section 6.1.  If\r\n   resulting encrypted filling N1 and N2 is the first 64-bit block of\r\n   the running key Gc(1)=A(S), then this block is added bitwise modulo 2\r\n   with the first 64-bit block of plain text Tp(1) = (t1(1), t2(1), ...,\r\n   t64(1)).\r\n",
    "correct_text": "   The initial filling of N1 and N2 is encrypted in the electronic\r\n   codebook mode in accordance with the requirements in section 5.1.  If\r\n   resulting encrypted filling N1 and N2 is the first 64-bit block of\r\n   the running key Gc(1)=A(S), then this block is added bitwise modulo 2\r\n   with the first 64-bit block of plain text Tp(1) = (t1(1), t2(1), ...,\r\n   t64(1)).\r\n",
    "notes": null,
    "submit_date": "2010-04-09",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2147,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 7.1,
    "orig_text": "   The filling of N1 and N2 is encrypted in the electronic codebook mode\r\n   in accordance with the requirements in the section 6.1.  The\r\n   encrypted filling of N1 and N2 makes the second 64-bit block of the\r\n   running key Gc(2), this block is added bitwise modulo 2 in the adder\r\n   CM5 to the second block of the plain text Tp(2).\r\n",
    "correct_text": "   The filling of N1 and N2 is encrypted in the electronic codebook mode\r\n   in accordance with the requirements in the section 5.1.  The\r\n   encrypted filling of N1 and N2 makes the second 64-bit block of the\r\n   running key Gc(2), this block is added bitwise modulo 2 in the adder\r\n   CM5 to the second block of the plain text Tp(2).\r\n",
    "notes": null,
    "submit_date": "2010-04-09",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2148,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 7.1,
    "orig_text": "   The initial filling of N1 and N2 is encrypted in the electronic\r\n   codebook mode in accordance with the requirements in section 6.1.  If\r\n   resulting encrypted filling N1 and N2 is the first 64-bit block of\r\n   the running key Gc(1)=A(S), then this block is added bitwise modulo 2\r\n   with the first 64-bit block of plain text Tp(1) = (t1(1), t2(1), ...,\r\n   t64(1)).",
    "correct_text": "   The initial filling of N1 and N2 is encrypted in the electronic\r\n   codebook mode in accordance with the requirements in section 6.1.  The\r\n   resulting encrypted filling N1 and N2 is the first 64-bit block of\r\n   the running key Gc(1)=A(S), then this block is added bitwise modulo 2\r\n   in the adder CM5 with the first 64-bit block of plain text Tp(1) = \r\n   (t1(1), t2(1), ..., t64(1)).",
    "notes": null,
    "submit_date": "2010-04-09",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2149,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 7.2,
    "orig_text": "   The initial filling of N1 and N2 (the initialisation vector S) is\r\n   encrypted in the electronic codebook mode in accordance with the\r\n   subsection 6.1.  The encrypted filling of N1, N2 is the first block\r\n   of the running key Gc(1) = A(S), this block is added bitwise modulo 2\r\n   in the adder CM5 with the encrypted data block Tc(1).  This results\r\n   in the first block of plain text Tp(1).\r\n",
    "correct_text": "   The initial filling of N1 and N2 (the initialisation vector S) is\r\n   encrypted in the electronic codebook mode in accordance with the\r\n   subsection 5.1.  The encrypted filling of N1, N2 is the first block\r\n   of the running key Gc(1) = A(S), this block is added bitwise modulo 2\r\n   in the adder CM5 with the encrypted data block Tc(1).  This results\r\n   in the first block of plain text Tp(1).\r\n",
    "notes": null,
    "submit_date": "2010-04-09",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2150,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 8,
    "orig_text": "   - The first block of plain text:\r\n\r\n      Tp(1) = (t1(1), t1(2), ..., t64(1)) = (a1(1)[0], a2(1)[0], ...,\r\n              a32(1)[0], b1(1)[0], b2(1)[0], ..., b32(1)[0])\r\n",
    "correct_text": "   The first block of plain text:\r\n\r\n      Tp(1) = (t1(1), t1(2), ..., t64(1)) = (a1(1)[0], a2(1)[0], ...,\r\n              a32(1)[0], b1(1)[0], b2(1)[0], ..., b32(1)[0])\r\n",
    "notes": null,
    "submit_date": "2010-04-09",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2151,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 8,
    "orig_text": "   The filling of N1 and N2 is transformed in accordance with the first\r\n   16 rounds of the encryption algorithm in the electronic codebook mode\r\n   (see the subsection 6.1).  In the KDS, there exists the same key that\r\n   is used for encrypting the blocks of plain text Tp(1), Tp(2), ...,\r\n   Tp(M) in the corresponding blocks of encrypted data Tc(1), Tc(2),\r\n   ..., Tc(M).\r\n",
    "correct_text": "   The filling of N1 and N2 is transformed in accordance with the first\r\n   16 rounds of the encryption algorithm in the electronic codebook mode\r\n   (see the subsection 5.1).  In the KDS, there exists the same key that\r\n   is used for encrypting the blocks of plain text Tp(1), Tp(2), ...,\r\n   Tp(M) in the corresponding blocks of encrypted data Tc(1), Tc(2),\r\n   ..., Tc(M).\r\n",
    "notes": null,
    "submit_date": "2010-04-09",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2152,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 7.2,
    "orig_text": "The block of encrypted data Tc(1) makes the initial filling of N1, N2\r\n   for generating the second block of the running key Gc(2).  The block\r\n   Tc(1) is written in N1 and N2 in accordance with the requirements in\r\n   the subsection 6.1, the resulted block Gc(2) is added bitwise modulo\r\n   2 in the adder CM5 to the second block of the encrypted data Tc(2).\r\n   This results in the block of plain text Tc(2).\r\n",
    "correct_text": "The block of encrypted data Tc(1) makes the initial filling of N1, N2\r\n   for generating the second block of the running key Gc(2).  The block\r\n   Tc(1) is written in N1 and N2 in accordance with the requirements in\r\n   the subsection 6.1. The filling of N1 and N2 is encrypted in the electronic\r\n   codebook mode according to the requirements of section 5.1. The encrypted\r\n   filling of N1 and N2 makes the second 64-bit block Gc(2) which is added\r\n   bitwise modulo 2 in the adder CM5 to the second block of the encrypted data\r\n   Tc(2). This results in the block of plain text Tc(2).\r\n",
    "notes": "One necessary statement was missed in the text.",
    "submit_date": "2010-04-09",
    "submitter_name": "Dolmatov V.",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2153,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 8,
    "orig_text": "   The resulting filling of N1 and N2 is added in the CM5 modulo 2 with\r\n   the third block Tp(3), etc., the last block Tp(M) = (t1(M), t2(M),\r\n   ..., t64(M)), padded if necessary to a complete 64-bit block by\r\n   zeros, is added in CM5 modulo 2 with the filling N1, N2 (a1(M-1)[16],\r\n   a2(M-1)[16], ..., a32(M-1)[16], b1(M-1)[16], b2(M-1)[16], ...,\r\n   b32(M-1)[16]).\r\n",
    "correct_text": "   The resulting filling of N1 and N2 is added in the CM5 modulo 2 with\r\n   the third block Tp(3), etc., the last block Tp(M) = (t1(M), t2(M),\r\n   ..., t64(M)), padded if necessary to a complete 64-bit block by\r\n   zeros, is added in CM5 modulo 2 with the filling N1, N2 \r\n   (a1(M-1)[16], a2(M-1)[16], ..., a32(M-1)[16], b1(M-1)[16], \r\n   b2(M-1)[16], ..., b32(M-1)[16]).\r\n",
    "notes": null,
    "submit_date": "2010-04-09",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2154,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 8,
    "orig_text": "The encrypted data Tc(1), Tc(2), ..., Tc(M), when arriving, are\r\n   decrypted, out of the resulting plain text blocks Tp(1), Tp(2), ...,\r\n   Tp(M).  The MAC I'(l) is generated as described in the subsection 5.3\r\n   and compared with the MAC I(l) received together with the encrypted\r\n   data from the telecommunication channel or from the computer memory.\r\n   If the MACs are not equal, the resulting plain text blocks Tp(1),\r\n   Tp(2), ..., Tp(M) are considered false.\r\n\r\n",
    "correct_text": "he encrypted data Tc(1), Tc(2), ..., Tc(M), when arriving, are\r\n   decrypted, out of the resulting plain text blocks Tp(1), Tp(2), ...,\r\n   Tp(M).  The MAC I'(l) is generated as described above\r\n   and compared with the MAC I(l) received together with the encrypted\r\n   data from the telecommunication channel or from the computer memory.\r\n   If the MACs are not equal, the resulting plain text blocks Tp(1),\r\n   Tp(2), ..., Tp(M) are considered false.\r\n\r\n",
    "notes": "wrong reference to the original text sections",
    "submit_date": "2010-04-09",
    "submitter_name": "Dolmatov V.",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2692,
    "doc-id": "RFC5830",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "   The constant C1 is:\r\n\r\n      The bit of N6   32 31 30 29 28 27 26 25 24 23 22 21 20 19 18\r\n\r\n      The bit value    0  0  0  0  0  0  0  1  0  0  0  0  0  0  0\r\n\r\n\r\n      The bit of N6   17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\r\n\r\n      The bit value    1  0 0  0  0  0  0  0  1 0 0 0 0 0 1 0 0\r\n\r\n   The constant C2 is:\r\n\r\n      The bit of N6   32 31 30 29 28 27 26 25 24 23 22 21 20 19 18\r\n\r\n      The bit value    0  0  0  0  0  0  0  1  0  0  0  0  0  0  0\r\n\r\n\r\n      The bit of N6   17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\r\n\r\n      The bit value    1  0 0  0  0  0  0  0  1 0 0 0 0 0 0 0 1\r\n\r\n",
    "correct_text": "   The constant C1 is:\r\n\r\n      The bit of N6   32 31 30 29 28 27 26 25 24 23 22 21 20 19 18\r\n\r\n      The bit value    0  0  0  0  0  0  0  1  0  0  0  0  0  0  0\r\n\r\n\r\n      The bit of N6   17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\r\n\r\n      The bit value    1  0 0  0  0  0  0  0  1 0 0 0 0 0 1 0 0\r\n\r\n   The constant C2 is:\r\n\r\n      The bit of N5   32 31 30 29 28 27 26 25 24 23 22 21 20 19 18\r\n\r\n      The bit value    0  0  0  0  0  0  0  1  0  0  0  0  0  0  0\r\n\r\n\r\n      The bit of N5   17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\r\n\r\n      The bit value    1  0 0  0  0  0  0  0  1 0 0 0 0 0 0 0 1\r\n\r\n",
    "notes": "C1 is stored in N6 and C2 is stored in N5 (not both in N6)",
    "submit_date": "2011-01-28",
    "submitter_name": "Kirill Gagarski",
    "verifier_id": 126,
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  }
]
