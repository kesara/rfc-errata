[
  {
    "errata_id": 4730,
    "doc-id": "RFC7748",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 4.1,
    "orig_text": "V(P)  147816194475895447910205935684099868872646061346164752889648818\r\n37755586237401",
    "correct_text": "V(P)  431144251710685529207648989359339670393703861982038067307639101\r\n66200978582548",
    "notes": "The Montgomery form of the curve is generally used with a ladder, where the v coordinate is unused and unspecified. Thus I picked the smaller of the two possible values for v.\r\n\r\nHowever, the curve is birationally equivalent to edwards25519, where both coordinates of the base point are used and are already in widespread use. Sadly, picking the smaller of the values for v ends up mapping to the negative of the base point on edwards25519.\r\n\r\nThis change replaces v with -v so that it matches up.",
    "submit_date": "2016-07-05",
    "submitter_name": "Adam Langley",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5028,
    "doc-id": "RFC7748",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 5.2,
    "orig_text": "Input u-coordinate as a number (base 10):",
    "correct_text": "Decoded u-coordinate as a number (base 10):",
    "notes": "It is unclear that the base 10 numbers are the decoded values (i.e. after masking). That should have been made more explicit to reduce confusion.",
    "submit_date": "2017-06-02",
    "submitter_name": "Adam Langley",
    "verifier_id": 168,
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2020-12-14 22:58:47"
  },
  {
    "errata_id": 5568,
    "doc-id": "RFC7748",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 5.2,
    "orig_text": "   Input u-coordinate:\r\n     e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493",
    "correct_text": "   Input u-coordinate:\r\n     e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a413",
    "notes": "In the X25519 2nd test vector the last byte of input u-coordinate should be 13 instead of 93. This will fix inconsistency between u-coordinate, its base10 representation and the output u-coordinate.\n --VERIFIER NOTES-- \nA change of one bit of the input u-coordinate in the hexadecimal representation is proposed (to make it \"consistent\" with the base 10 representation). However, implementations of x25519 should \"mask\" that bit after taking a u-coordinate as an input - therefore, the existing text of RFC does not have any errors there. ",
    "submit_date": "2018-12-07",
    "submitter_name": "Juan Alcasabas",
    "verifier_id": 168,
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2020-12-14 23:02:25"
  },
  {
    "errata_id": 5651,
    "doc-id": "RFC7748",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 5,
    "orig_text": "z_2 = E * (AA + a24 * E)",
    "correct_text": "z_2 = E * (BB + a24 * E)",
    "notes": "When BB is used, the point multiplication of the second test vector\r\n\r\nP = (0x13a415c749d54cfc3e3cc06f10e7db312cae38059d95b7f4d3116878120f21e5, 0x1) \r\n\r\nby scalar k\r\n0x4dba18799e16a42cd401eae021641bc1f56a7d959126d25a3c67b4d1d4e96648\r\n\r\ngives the expected point\r\n[k]P = (0x5779ac7a64f7f8e652a19f79685a598bf873b8b45ce4ad7a7d90e87694decb95, 0x1)\r\n\r\nThe implementation based on AA gives the unexpected point \r\n[k]P = (0x3884d5c22af664f822cb3dd728b03c9fac1e1d78c772a74f05546566bd7bed9c, 1)\n --VERIFIER NOTES-- \nIt is proposed to modify the algorithm description for calculation of z_2. However, after checking the original algorithm independently, it was confirmed that the expected numbers are obtained. Therefore, the existing text of RFC does not have any errors here.",
    "submit_date": "2019-03-11",
    "submitter_name": "Pierre Laurent",
    "verifier_id": 168,
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2020-12-14 23:06:31"
  },
  {
    "errata_id": 7095,
    "doc-id": "RFC7748",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "Appendix A",
    "orig_text": "This section specifies the procedure that was used to generate the\r\nabove curves; specifically, it defines how to generate the parameter\r\nA of the Montgomery curve y^2 = x^3 + A*x^2 + x.\r\n",
    "correct_text": "This section specifies the procedure that was used to generate the\r\nabove curves; specifically, it defines how to generate the parameter\r\nA of the Montgomery curve v^2 = u^3 + A*u^2 + u.\r\n",
    "notes": "For consistency with the other parts of the document (e.g. Section 3), use the variables u and v in the Montgomery curve equation.",
    "submit_date": "2022-08-18",
    "submitter_name": "James Muir",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 7096,
    "doc-id": "RFC7748",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "Appendix A",
    "orig_text": "# section A.1 sage code:\r\n\r\n       for A in xrange(3, int(1e9)):\r\n           if (A-2) % 4 != 0:\r\n             continue\r\n\r\n# section A.3 sage code:\r\n\r\n       for uInt in range(1, 1e3):\r\n         u = F(uInt)",
    "correct_text": "# section A.1 sage code:\r\n\r\n       for A in xsrange(3, int(1e9)):\r\n           if (A-2) % 4 != 0:\r\n             continue\r\n\r\n# section A.3 sage code:\r\n\r\n       for uInt in xsrange(1, int(1e3)):\r\n         u = F(uInt)",
    "notes": "\"xrange\" is not recognized by Sage with python 3, so the script from section A.1 fails with a syntax error (using \"xrange\" likely worked fine for Sage with python 2).  The suggested changes in A.3 are just for consistency.",
    "submit_date": "2022-08-18",
    "submitter_name": "James Muir",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
