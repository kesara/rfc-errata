[
  {
    "errata_id": 3109,
    "doc-id": "RFC5931",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.2.2",
    "orig_text": "An integer scalar, x, acts on an ECC group element, Y, via repetitive\r\naddition (Y is added to itself x times), also called point\r\nmultiplication -- x * Y.\r\n\r\nThe inverse function for an ECC group is defined such that the sum of\r\nan element and its inverse is the \"point at infinity\" (the identity\r\nfor elliptic curve point addition).  In other words,\r\n\r\n    Q + inv(Q) = \"O\"\r\n",
    "correct_text": "An integer scalar, x, acts on an ECC group element, Y, via repetitive\r\naddition (Y is added to itself x times), also called point\r\nmultiplication -- x * Y.\r\n\r\nECC groups require the use of a mapping function, F(), which returns\r\nthe x-coordinate of a point on the elliptic curve. In other words,\r\nif point Y has coordinates Y.x and Y.y, then,\r\n\r\n    Y.x = F(Y)\r\n\r\nThe inverse function for an ECC group is defined such that the sum of\r\nan element and its inverse is the \"point at infinity\" (the identity\r\nfor elliptic curve point addition).  In other words,\r\n\r\n    Q + inv(Q) = \"O\"\r\n",
    "notes": "Section 2.8.4.1 mentions function F() as defined in 2.2.2 but there is no\r\nfunction F() in 2.2.2.",
    "submit_date": "2012-02-06",
    "submitter_name": "Dan Harkins",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5681,
    "doc-id": "RFC5931",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "2.8.3",
    "orig_text": "2.8.3 Fixing the Password Element\r\n\r\n   Fixing the Password Element involves an iterative hunting-and-pecking\r\n   technique using the prime from the negotiated group's domain\r\n   parameter set and an ECC- or FFC-specific operation depending on the\r\n   negotiated group. \r\n\r\n2.8.3.1.  ECC Operation for PWE\r\n\r\n   The group-specific operation for ECC groups uses pwd-value, pwd-seed,\r\n   and the equation for the curve to produce the Password Element.\r\n   First, pwd-value is used directly as the x-coordinate, x, with the\r\n   equation for the elliptic curve, with parameters a and b from the\r\n   domain parameter set of the curve, to solve for a y-coordinate, y.\r\n   If there is no solution to the quadratic equation, this operation\r\n   fails and the hunting-and-pecking process continues.  If a solution\r\n   is found, then an ambiguity exists as there are technically two\r\n   solutions to the equation and pwd-seed is used to unambiguously\r\n   select one of them.  If the low-order bit of pwd-seed is equal to the\r\n   low-order bit of y, then a candidate PWE is defined as the point\r\n   (x, y); if the low-order bit of pwd-seed differs from the low-order\r\n   bit of y, then a candidate PWE is defined as the point (x, p - y),\r\n   where p is the prime over which the curve is defined.  The candidate\r\n   PWE becomes PWE, and the hunting and pecking terminates successfully.\r\n\r\n   Algorithmically, the process looks like this:\r\n\r\n      found = 0\r\n      counter = 1\r\n      do {\r\n        pwd-seed = H(token | peer-ID | server-ID | password | counter)\r\n        pwd-value = KDF(pwd-seed, \"EAP-pwd Hunting And Pecking\", len(p))\r\n        if (pwd-value < p)\r\n        then\r\n          x = pwd-value\r\n          if ( (y = sqrt(x^3 + ax + b)) != FAIL)\r\n          then\r\n            if (LSB(y) == LSB(pwd-seed))\r\n            then\r\n              PWE = (x, y)\r\n            else\r\n              PWE = (x, p-y)\r\n            fi\r\n            found = 1\r\n          fi\r\n        fi\r\n        counter = counter + 1\r\n      } while (found == 0)\r\n\r\n                    Figure 3: Fixing PWE for ECC Groups\r\n\r\n\r\n2.8.3.2.  FFC Operation for pwe\r\n\r\n   The group-specific operation for FFC groups takes pwd-value, and the\r\n   prime, p, and order, r, from the group's domain parameter set (see\r\n   Section 2.2.1 when the order is not part of the defined domain\r\n   parameter set) to directly produce a candidate Password Element, pwe,\r\n   by exponentiating the pwd-value to the value ((p-1)/r) modulo the\r\n   prime.  If the result is greater than one (1), the candidate pwe\r\n   becomes pwe, and the hunting and pecking terminates successfully.\r\n\r\n   Algorithmically, the process looks like this:\r\n\r\n      found = 0\r\n      counter = 1\r\n      do {\r\n        pwd-seed = H(token | peer-ID | server-ID | password | counter)\r\n        pwd-value = KDF(pwd-seed, \"EAP-pwd Hunting And Pecking\", len(p))\r\n        if (pwd-value < p)\r\n        then\r\n          pwe = pwd-value ^ ((p-1)/r) mod p\r\n          if (pwe > 1)\r\n          then\r\n            found = 1\r\n          fi\r\n        fi\r\n        counter = counter + 1\r\n      } while (found == 0)\r\n\r\n                    Figure 4: Fixing PWE for FFC Groups\r\n\r\n\r\n",
    "correct_text": "\r\n\r\n2.8.3 Fixing the Password Element\r\n\r\n   Fixing the Password Element involves an iterative hunting-and-pecking\r\n   technique using the prime from the negotiated group's domain\r\n   parameter set and an ECC- or FFC-specific operation depending on the\r\n   negotiated group. \r\n\r\n   To thwart side-channel attacks that attempt to determine the number\r\n   of iterations of the hunting-and-pecking loop used to find the PE for\r\n   a given password, a security parameter, k, is used that ensures that\r\n   at least k iterations are always performed.  The probability that one\r\n   requires more than n iterations of the hunting-and-pecking loop to\r\n   find an ECC PE is roughly (q/2p)^n and to find an FFC PE is roughly\r\n   (q/p)^n, both of which rapidly approach zero (0) as n increases.  The\r\n   security parameter, k, SHOULD be set sufficiently large such that the\r\n   probability that finding the PE would take more than k iterations is\r\n   sufficiently small. It is RECOMMENDED that an implementation set the\r\n   security parameter, k, to a value of at least forty (40) which will\r\n   put the probability that more than forty iterations are needed in the\r\n   order of one in one trillion (1:1,000,000,000,000)\r\n\r\n2.8.3.1.  ECC Operation for PWE\r\n\r\n   The group-specific operation for ECC groups uses pwd-value, pwd-seed,\r\n   and the equation for the curve to produce the Password Element.\r\n   First, pwd-value is used directly as an x-coordinate, v, with the\r\n   equation for the elliptic curve, with parameters a and b from the\r\n   domain parameter set of the curve, to check whether v^3 + a*v + b\r\n   is a quadratic residue modulo p.  \r\n\r\n   If it is a quadratic non residue, this operation fails and the\r\n   hunting-and-pecking process continues. If it is a quadratic residue,\r\n   then the x-coordinate is saved and the current seed is stored. When\r\n   the hunting-and-pecking loop terminates, the x-coordinate is used\r\n   with the equation of the curve to solve for a y-coordinate.  An\r\n   ambiguity exists since two values for the y-coordinate would be\r\n   valid, and the low-order bit of the stored base is used to\r\n   unambiguously determine the correct y-coordinate. The resulting\r\n   (x,y) pair becomes PWE.\r\n\r\n   Algorithmically, the process looks like this:\r\n\r\n      found = 0\r\n      counter = 1\r\n      do {\r\n        pwd-seed = H(token | peer-ID | server-ID | password | counter)\r\n        pwd-value = KDF(pwd-seed, \"EAP-pwd Hunting And Pecking\", len(p))\r\n        if (pwd-value < p)\r\n        then\r\n\t  v = pwd-value\r\n          if ((v^3 + av + b)) is a quadratic residue)\r\n          then\r\n            if ( found == 0 )\r\n\t    then\r\n\t       x = v\r\n\t       save = pwd-seed\r\n\t       found = 1\r\n\t    fi\r\n          fi\r\n        fi\r\n        counter = counter + 1\r\n      } while ((found == 0) || (counter < k))\r\n      y = sqrt(x^3 + ax + b)\r\n      if ( lsb(y) == lsb(save))\r\n      then\r\n        PWE = (x, y)\r\n      else\r\n        PWE = (x, p-y)\r\n      fi\r\n\r\n                    Figure 3: Fixing PWE for ECC Groups\r\n\r\n   Checking whether a value is a quadratic residue modulo a prime can\r\n   leak information about that value in a side-channel attack.\r\n   Therefore, it is RECOMMENDED that the technique used to determine if\r\n   the value is a quadratic residue modulo p blind the value with a\r\n   random number so that the blinded value can take on all numbers\r\n   between 1 and p-1 with equal probability while not changing its\r\n   quadratic residuosity.  Determining the quadratic residue in a\r\n   fashion that resists leakage of information is handled by flipping a\r\n   coin and multiplying the blinded value by either a random quadratic\r\n   residue or a random quadratic nonresidue and checking whether the\r\n   multiplied value is a quadratic residue (qr) or a quadratic\r\n   nonresidue (qnr) modulo p, respectively.  The random residue and\r\n   nonresidue can be calculated prior to hunting and pecking by\r\n   calculating the Legendre symbol on random values until they are\r\n   found:\r\n\r\n      do {\r\n        qr = random() mod p\r\n      } while ( lgr(qr, p) != 1)\r\n\r\n      do {\r\n        qnr = random() mod p\r\n      } while ( lgr(qnr, p) != -1)\r\n\r\n   Algorithmically, the masking technique to find out whether or not a\r\n   value is a quadratic residue looks like this:\r\n\r\n      is_quadratic_residue (val, p) {\r\n          r = (random() mod (p - 1)) + 1\r\n          num = (val * r * r) mod p\r\n          if ( lsb(r) == 1 )\r\n             num = (num * qr) mod p\r\n             if ( lgr(num, p) == 1)\r\n             then\r\n                return TRUE\r\n             fi\r\n          else\r\n             num = (num * qnr) mod p\r\n             if ( lgr(num, p) == -1)\r\n             then\r\n                return TRUE\r\n             fi\r\n          fi\r\n          return FALSE\r\n      }\r\n\r\n\r\n2.8.3.2.  FFC Operation for pwe\r\n\r\n   The group-specific operation for FFC groups takes pwd-value, and the\r\n   prime, p, and order, r, from the group's domain parameter set (see\r\n   Section 2.2.1 when the order is not part of the defined domain\r\n   parameter set) to directly produce a candidate Password Element, pwe,\r\n   by exponentiating the pwd-value to the value ((p-1)/r) modulo the\r\n   prime.  If the result is greater than one (1), the candidate pwe\r\n   becomes pwe, and the hunting and pecking continues.\r\n\r\n   Algorithmically, the process looks like this:\r\n\r\n      found = 0\r\n      counter = 1\r\n      do {\r\n        pwd-seed = H(token | peer-ID | server-ID | password | counter)\r\n        pwd-value = KDF(pwd-seed, \"EAP-pwd Hunting And Pecking\", len(p))\r\n        if (pwd-value < p)\r\n        then\r\n          temp = pwd-value ^ ((p-1)/r) mod p\r\n          if (temp > 1)\r\n          then\r\n            found = 1\r\n\t    pwe = temp\r\n          fi\r\n        fi\r\n        counter = counter + 1\r\n      } while ((found == 0) || (counter < k))\r\n\r\n                    Figure 4: Fixing PWE for FFC Groups\r\n\r\n",
    "notes": "The key exchange in EAP-pwd is dragonfly which was described in RFC 7664. During the standardization of RFC 7664, comments were received to prevent a side-channel attack against the hunting-and-pecking loop and the technique used in RFC 7664 should be done in RFC 5931 to prevent side-channel attack.",
    "submit_date": "2019-03-31",
    "submitter_name": "Dan Harkins",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  }
]
