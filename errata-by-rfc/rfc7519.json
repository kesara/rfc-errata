[
  {
    "errata_id": "5648",
    "doc-id": "RFC7519",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "1",
    "orig_text": "JSON Web Token (JWT) is a compact claims representation format\r\n   intended for space constrained environments such as HTTP\r\n   Authorization headers and URI query parameters.  JWTs encode claims\r\n   to be transmitted as a JSON [RFC7159] object that is used as the\r\n   payload of a JSON Web Signature (JWS) [JWS] structure or as the\r\n   plaintext of a JSON Web Encryption (JWE) [JWE] structure, enabling\r\n   the claims to be digitally signed or integrity protected with a\r\n   Message Authentication Code (MAC) and/or encrypted.  JWTs are always\r\n   represented using the JWS Compact Serialization or the JWE Compact\r\n   Serialization.\r\n\r\n   The suggested pronunciation of JWT is the same as the English word\r\n   \"jot\".\r\n\r\n",
    "correct_text": "JSON Web Token (JWT) is a compact claims representation format\r\n   intended for space constrained environments such as HTTP\r\n   Authorization headers and URI query parameters.  JWTs encode claims\r\n   to be transmitted as a JSON [RFC7159] object that is used as the\r\n   payload of a JSON Web Signature (JWS) [JWS] structure or as the\r\n   plaintext of a JSON Web Encryption (JWE) [JWE] structure, enabling\r\n   the claims to be digitally signed or integrity protected with a\r\n   Message Authentication Code (MAC) and/or encrypted.  JWTs are always\r\n   represented using the JWS Compact Serialization or the JWE Compact\r\n   Serialization.\r\n",
    "notes": "The suggested pronunciation is strange and confusing. It makes it hard to onboard new people verbally and always requires an explanation of the pronunciation. The standard already has a perfectly reasonable initialism of JWT that clearly refers to JSON Web Tokens. It is jarring to suggest a pronunciation that does not map to the letters of the spec, and in my experience often leads to confusion when used.",
    "submit_date": "2019-03-08",
    "submitter_name": "Andy Delcambre",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5906",
    "doc-id": "RFC7519",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.2",
    "orig_text": "   Finally, note that it is an application decision which algorithms may\r\n   be used in a given context.  Even if a JWT can be successfully\r\n   validated, unless the algorithms used in the JWT are acceptable to\r\n   the application, it SHOULD reject the JWT.",
    "correct_text": "   Finally, note that it is an application decision which algorithms may\r\n   be used in a given context.  Even if a JWT can be successfully\r\n   validated, unless the algorithms used in the JWT are acceptable to\r\n   the application, it MUST reject the JWT.",
    "notes": "A vulnerability exists in certain implementations in the wild where applications simply look for valid JWT tokens which includes the \"none\" algorithm (https://medium.com/swlh/hacking-json-web-tokens-jwts-9122efe91e4a).  A fairly popular library is auth0's java-jwt and at verification (https://github.com/auth0/java-jwt/blob/master/lib/src/main/java/com/auth0/jwt/JWTVerifier.java) quite reasonably you cannot initialize the class without an algorithm.  Given all capital SHOULD may be interpreted as a recommendation and as this RFC dictates the algorithm \"none\" MUST be implemented as a default algorithm under Section 8, one could argue JWTVerifier in the example doesn't have to verifyAlgorithm leading to the vulnerability pointed out in the first article while still complying by the specification.  There is no good reason why an algorithm unacceptable to the application must not be rejected as it does more harm than good and all popular library implementations interpret it as such.",
    "submit_date": "2019-11-13",
    "submitter_name": "Erdem Memisyazici",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "6622",
    "doc-id": "RFC7519",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "11",
    "orig_text": "All the security considerations in the JWS specification also apply\r\n   to JWT, as do the JWE security considerations when encryption is\r\n   employed.  In particular, Sections <a href=\"#section-10.12\">10.12</a>",
    "correct_text": "All the security considerations in the JWS specification also apply\r\n   to JWT, as do the JWE security considerations when encryption is\r\n   employed.  In particular, Sections <a href=\"/doc/html/rfc7515#section-10.12\">10.12</a>",
    "notes": "The link appears to be broken. It is intended to point to rfc7515#section-10.12 whereas it is pointing to the non-existent section of the same document.\n --VERIFIER NOTES-- \nThe \"text\" publication format (the only official format for RFCs prior to 8650) does not include HTML links, so the \"original text\" section of this report does not match the version of the RFC that this tool is used for.  Accordingly, the submission has to be rejected as invalid.",
    "submit_date": "2021-06-25",
    "submitter_name": "Padmanarayanan SR",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2021-07-03 17:54:53"
  },
  {
    "errata_id": "7720",
    "doc-id": "RFC7519",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.1.6",
    "orig_text": "4.1.6.  \"iat\" (Issued At) Claim\r\n\r\nThe \"iat\" (issued at) claim identifies the time at which the JWT was\r\nissued.  This claim can be used to determine the age of the JWT.  Its\r\nvalue MUST be a number containing a NumericDate value.  Use of this\r\nclaim is OPTIONAL.",
    "correct_text": "4.1.6.  \"iat\" (Issued At) Claim\r\n\r\nThe \"iat\" (issued at) claim identifies the time at which the JWT was\r\nissued.  This claim can be used to determine the age of the JWT.  Its\r\nvalue MUST be a number containing a NumericDate value.  Use of this\r\nclaim is OPTIONAL. Implementors MUST NOT reject otherwise-valid JWTs\r\nwith \"iat\" claims that appear to be from the future; token issuers\r\ndesiring this behavior may require it by including an \"nbf\" claim.",
    "notes": "There is substantial confusion and disagreement among JWT library implementors about whether to reject JWTs with `iat` claims that appear to be from the future due to clock drift. This confusion has led to over half a dozen Github issues & PRs over the years in libraries in many different ecosystems, and lots of strong disagreement among library developers and users.\r\n\r\nBased on a sample of the top Google search results for jwt client libraries in 11 different language ecosystems, the majority (7) of the libraries sampled do not reject future `iat` claims, while the remaining 4 *do* reject future `iat` claims by default. Of those 4 who do, *all* of them have had Github issues filed (by different unique users) in which the user was having a JWT unexpectedly rejected by a token validator using the library whose clock had drifted from that of the token issuer enough to trigger `iat`-based rejection.\r\n\r\nI propose we update the spec to explicitly prohibit rejection of future-`iat` JWTs (especially since token issuers have always been able to opt into this behavior using an `nbf` claim). Since this RFC has been published and cannot be edited, a new superseding RFC will have to be published and this one deprecated in order for the suggested change to make it out of the errata and into an actual RFC doc.\r\n\r\nI'm not sure if this merits a full RFC republish -- but as a data point for impact consideration, it's worth noting that this confusion has almost certainly wasted at least multiple hours per person (on average) of *dozens* of developers' time over the years, and led to at least half a dozen production bugs that I've seen mentioned. One of these bugs cropped up in my own organization on 2023-11-31 and has been observed previously but was misunderstood and not resolved; the 2023-11-31 occurence involved 10+ people in discussion. One Github issue I saw described an elongated full web server outage attributed to this confusion which cropped up during a leap-second-related clock drift issue. I'm filing this errata request on calendar day 3+ of discussing this issue in my organization (if you include past times this issue has cropped up).\r\n\r\nThanks for your consideration! I look forward to hearing back.",
    "submit_date": "2023-12-01",
    "submitter_name": "Timothy Vergenz",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
