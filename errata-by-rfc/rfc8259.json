[
  {
    "errata_id": "5210",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "Internet Engineering Task Force (IETF)                      T. Bray, Ed.\r\nRequest for Comments: 8259                                    Textuality\r\nObsoletes: 7159                                            December 2017\r\nCategory: Standards Track\r\nISSN: 2070-1721\r\n",
    "correct_text": "Internet Engineering Task Force (IETF)                      T. Bray, Ed.\r\nRequest for Comments: 8259                                    Textuality\r\nSTD: 90                                                    December 2017\r\nObsoletes: 7159\r\nCategory: Standards Track\r\nISSN: 2070-1721\r\n",
    "notes": "Missing \"STD\" entry in boilerplate.",
    "submit_date": "2017-12-16",
    "submitter_name": "Julian Reschke",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5218",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "12",
    "orig_text": "JSON is a subset of JavaScript",
    "correct_text": "JSON is nearly a subset of JavaScript",
    "notes": "JSON is not a subset of JavaScript: there are syntactically valid JSON texts that are not syntactically valid JavaScript. Namely, JSON strings can contain unescaped U+2028 LINE SEPARATOR or U+2029 PARAGRAPH SEPARATOR characters, while JavaScript string literals cannot. Thus, a sequence of characters U+0022 U+2028 U+0022 matches this RFC's 'string' production, but does not match ECMA-262's 'Expression' production.",
    "submit_date": "2017-12-28",
    "submitter_name": "Vasiliy Faronov",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5318",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "7",
    "orig_text": "      string = quotation-mark *char quotation-mark\r\n\r\n      char = unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\r\n\r\n      escape = %x5C              ; \\\r\n\r\n      quotation-mark = %x22      ; \"\r\n\r\n      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF",
    "correct_text": "      string = quotation-mark *char quotation-mark\r\n\r\n      char = unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\r\n\r\n      escape = %x5C              ; \\\r\n\r\n      quotation-mark = %x22      ; \"\r\n\r\n      unescaped = %x20-21 / %x23-2E / %x30-5B / %x5D-10FFFF",
    "notes": "The solidus U+002F is listed as being escaped above, but is not excluded in the 'unescaped' sequence.",
    "submit_date": "2018-04-04",
    "submitter_name": "Joakim Erdfelt",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5355",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "6",
    "orig_text": "Note that when such software is used, numbers that are integers and\r\nare in the range [-(2**53)+1, (2**53)-1] are interoperable in the\r\nsense that implementations will agree exactly on their numeric\r\nvalues.",
    "correct_text": "Note that when such software is used, numbers that are integers and\r\nare in the range [-(2**53), (2**53)] are interoperable in the\r\nsense that implementations will agree exactly on their numeric\r\nvalues.",
    "notes": "The limit is presumably derived from ECMAScript which says:\r\n\r\n\"The value of Number.MAX_SAFE_INTEGER is the largest integer n such that n and n + 1 are both exactly representable as a Number value\"\r\n\r\nHowever, Number.MAX_SAFE_INTEGER is 9007199254740991 ((2*53)-1) making n+1 (2**53) the largest exactly representable Number value",
    "submit_date": "2018-05-10",
    "submitter_name": "Anders Rundgren",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5853",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "11",
    "orig_text": "Note:  No \"charset\" parameter is defined for this registration.\r\n    Adding one really has no effect on compliant recipients.",
    "correct_text": "Note:  No \"charset\" parameter is defined for this registration.\r\n    JSON text is encoded as described in RFC 8259, Section 8.1.\r\n",
    "notes": "Last sentence of last note of section 11 should be amended, as it introduces confusion by going against other explicit statements, like the followings:\r\n * RFC8259 sect. 8.1 defines that inner encoding is UTF-8\r\n * RFC8259 sect. 11 defines no formal (optional/required) parameters for this registered type\r\n * RFC6838 sect. 4.2.1 defines the common usage of a \"charset\" parameter as a \"required\" one (which isn't the case here)\r\n * RFC6838 sect. 4.2.1 defines that \"charset\" should not be used if the inner payload already transports charset information (e.g. mandatory UTF-8, which is the case here)\r\n * RFC6838 sect. 4.2.1 defines a \"charset\" parameter only for subtypes of the \"text/*\" hierarchy (which isn't the case here)",
    "submit_date": "2019-09-05",
    "submitter_name": "Luca BRUNO",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "6208",
    "doc-id": "RFC8259",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "8.1",
    "orig_text": "In the interests of interoperability, implementations that parse JSON texts MAY ignore the presence of a byte order mark rather than treating it as an error.",
    "correct_text": "In the interests of interoperability, implementations that parse JSON texts MAY ignore the presence of a byte order mark or MAY interpret a byte order mark to indicate an alternate encoding rather than treating it as an error.",
    "notes": "The original line is copied from previous RFCs that specifically allowed alternate encodings.  In the context of a new, UTF-8 only restriction, interoperability provisions should also address interpreting legacy formats that predate the restriction.  By omission, readers may conclude that the *only* option for a BOM is to ignore or error.\n --VERIFIER NOTES-- \n   This is asking to revisit what we have consensus on, not a report of an error in the RFC.\r\nThe working group had extensive discussions on BOMs, and chose this particular working purposefully.",
    "submit_date": "2020-06-10",
    "submitter_name": "David Golden",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2020-06-10 07:38:37"
  },
  {
    "errata_id": "7307",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "3",
    "orig_text": "      null  = %x6e.75.6c.6c      ; null ",
    "correct_text": "      null  = %x6e.75.6c.6c      ; null without quotation marks for numeric attributes and \"null\" for string attributes.",
    "notes": "It is not clear how to encode null values in JSON.\r\nSome are encoding all attributes as \"null\".\r\nSome are encoding all attributes as null without quotation marks\r\nSome are encoding string attributes as \"null\" and numeric attributes as null without quotation marks.\r\nhttps://json.org is mentioning \"null\". ECMA 262  is mentioning \"null\" for string and +0F for numeric attributes. However providing zero for a number instead of null is incorrect and provides wrong results (in BI).",
    "submit_date": "2023-01-13",
    "submitter_name": "Maxim Iurie",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
