[
  {
    "errata_id": 37,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.1",
    "orig_text": "The Description of SHA1PadMessage, on page 30, says:\r\n\r\n * Description:\r\n *   According to the standard, the message must be padded to an\r\n *   even 512 bits. The first padding bit must be a '1'. The last\r\n *   64 bits represent the length of the original message. All bits\r\n *   in between should be 0. This helper function will pad the\r\n *   message according to those rules by filling the Message_Block\r\n *   array accordingly. When it returns, it can be assumed that the\r\n *   message digest has been computed.\r\n\r\nFor clarity, it should say:\r\n\r\n * Description:\r\n|*   According to the standard, the message must be padded to the next\r\n|*   proper multiple of 512 bits. The first padding bit must be a '1'.\r\n *   The last 64 bits represent the length of the original message.\r\n *   All bits in between should be 0. This helper function will pad\r\n *   the message according to those rules by filling the Message_Block\r\n *   array accordingly. When it returns, it can be assumed that the\r\n *   message digest has been computed.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 747,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "The Description of SHA224_256ProcessMessageBlock, on top of page 42,\r\nsays:\r\n\r\n * Description:\r\n *   This function will process the next 512 bits of the message\r\n *   stored in the Message_Block array.\r\n\r\nConsistently with the remainder of the test, it should say:\r\n\r\n * Description:\r\n|*   This helper function will process the next 512 bits of the\r\n *   message stored in the Message_Block array.\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 748,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "Similar to item (9), (16), (17), (22), and (29) above, the Description\r\nof SHA512Result contains improper wording and unpleasent formatting.\r\nAdditionally, counting 64 elements as ranging from the \"0th\" up to the\r\n\"64th\" is unpleasant and wrong -- indicating 65 elements (octets) !\r\n\r\nNear the bottom of page 44, the RFC says:\r\n\r\n * Description:\r\n *   This function will return the 512-bit message\r\n *   digest into the Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the 64th element.\r\n\r\n\r\nFor correctness and consistency, and for improved readability,\r\nit should say:\r\n\r\n * Description:\r\n *   This function will return the 512-bit message digest\r\n *   into the Message_Digest array provided by the caller.\r\n *   NOTE:\r\n *    The first octet of the hash is stored in the element with index 0,\r\n *    the last octet of the hash in the element with index 63.\r\n\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 750,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.4,
    "orig_text": "on mid-page 96, the code section,\r\n\r\n  if (bitcount > 0)\r\n    err = keyarray ? hmacFinalBits(&hmac, bits, bitcount) :\r\n                   USHAFinalBits(&sha, bits, bitcount);\r\n  if (err != shaSuccess) {\r\n    fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\r\n            keyarray ? \"hmacResult\" : \"shaResult\", err);\r\n    if (hashfp != stdin) fclose(hashfp);\r\n    return err;\r\n  }\r\n\r\nshould in fact say:\r\n\r\n  if (bitcount > 0)\r\n    err = keyarray ? hmacFinalBits(&hmac, bits, bitcount) :\r\n                   USHAFinalBits(&sha, bits, bitcount);\r\n  if (err != shaSuccess) {\r\n    fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\r\n            keyarray ? \"hmacFinalBits\" : \"shaFinalBits\", err);\r\n    if (hashfp != stdin) fclose(hashfp);\r\n    return err;\r\n  }\r\n\r\nRationale:\r\n\r\nSelf-evident; perhaps cloning error.\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1301,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 6.2,
    "orig_text": "      1. Prepare the message schedule W:\r\n         For t = 0 to 15\r\n            Wt = M(i)t\r\n         For t = 16 to 63\r\n            Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(t-15) + W(t-16)\r\n",
    "correct_text": "      1. Prepare the message schedule W:\r\n         For t = 0 to 15\r\n            Wt = M(i)t\r\n         For t = 16 to 63\r\n            Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(W(t-15)) + W(t-16)\r\n",
    "notes": "Cf. FIPS180-2, section 6.2.2.\r\n(http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf)",
    "submit_date": "2008-01-21",
    "submitter_name": "Jan Andres",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1302,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 6.4,
    "orig_text": "      1. Prepare the message schedule W:\r\n         For t = 0 to 15\r\n            Wt = M(i)t\r\n         For t = 16 to 79\r\n            Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(t-15) + W(t-16)\r\n",
    "correct_text": "      1. Prepare the message schedule W:\r\n         For t = 0 to 15\r\n            Wt = M(i)t\r\n         For t = 16 to 79\r\n            Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(W(t-15)) + W(t-16)\r\n",
    "notes": "Cf. FIPS180-2, section 6.3.2.\r\n(http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf)",
    "submit_date": "2008-01-21",
    "submitter_name": "Jan Andres",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2412,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 3,
    "orig_text": "Section 3 of RFC 4634, on page 5, defines the elementary word\r\noperations to be used subsequently in the text, including the\r\nleft shift operation, '<<'.  Unfortunately, the right shift\r\noperation '>>' is used frequently as well, but not defined\r\nin Section 3.\r\n\r\nI propose to amend the second paragraph of Section 3, on page 5,\r\n\r\n   In the operations below, x<<n is obtained as follows: discard the\r\n   left-most n bits of x and then pad the result with n zeroed bits on\r\n   the right (the result will still be the same number of bits).",
    "correct_text": "to read:\r\n\r\n   In the operations below, x<<n is obtained as follows: discard the\r\n   left-most n bits of x and then pad the result with n zeroed bits on\r\n   the right (the result will still be the same number of bits).\r\n|  Similarly, x>>n is obtained as follows: discard the right-most n bits\r\n|  of x and then prepend the result with n zeroed bits on the left (the\r\n|  result will still be the same number of bits).",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2413,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 3,
    "orig_text": "The last two text lines of Section 3, on mid-page 6, say:\r\n                                 v\r\n|            ROTL^n(x) = ROTR^(w-x)(x)\r\n\r\n             ROTR^n(x) = ROTL^(w-n)(x)",
    "correct_text": "They should say:\r\n                                 v\r\n|            ROTL^n(x) = ROTR^(w-n)(x)\r\n\r\n             ROTR^n(x) = ROTL^(w-n)(x)",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2414,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8,
    "orig_text": "In the introductory text in Section 8, function prototype arguments\r\nare inconsistently presented; all should be presented in ANSI-C style\r\nconsistently.\r\nAlso, the indentation of two lines breaks the otherwise consistent\r\nlayout.\r\n\r\nOn mid-page 16, the lines,\r\n\r\n   Functions:\r\n|                 int SHA$$$Reset(SHA$$$Context *);\r\n            Reset the hash context state\r\n|     int SHA$$$Input(SHA$$$Context *, const uint8_t *octets,\r\n                  unsigned int bytecount);\r\n            Incorporate bytecount octets into the hash.\r\n\r\nshould read:\r\n\r\n   Functions:\r\n|     int SHA$$$Reset(SHA$$$Context *context);\r\n            Reset the hash context state\r\n|     int SHA$$$Input(SHA$$$Context *context, const uint8_t *octets,\r\n                  unsigned int bytecount);\r\n            Incorporate bytecount octets into the hash.\r\n\r\nand on page 17, the lines,\r\n\r\n   Functions:\r\n|     int USHAReset(USHAContext *, SHAversion whichSha);\r\n            Reset the hash context state.\r\n|     int USHAInput(USHAContext *,\r\n                  const uint8_t *bytes, unsigned int bytecount);\r\n            Incorporate bytecount octets into the hash.\r\n|     int USHAFinalBits(USHAContext *,\r\n                  const uint8_t bits, unsigned int bitcount);\r\n|                 Incorporate bitcount bits into the hash.\r\n\r\nshould read:\r\n\r\n   Functions:\r\n|     int USHAReset(USHAContext *context, SHAversion whichSha);\r\n            Reset the hash context state.\r\n|     int USHAInput(USHAContext *context,\r\n                  const uint8_t *bytes, unsigned int bytecount);\r\n            Incorporate bytecount octets into the hash.\r\n|     int USHAFinalBits(USHAContext *context,\r\n                  const uint8_t bits, unsigned int bitcount);\r\n|           Incorporate bitcount bits into the hash.",
    "correct_text": "",
    "notes": "inconsistent prototypes, unpleasant/inconsistent indentation\r\n",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2415,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.1,
    "orig_text": "The initial Description in the file, on page 18 of the RFC, says:\r\n\r\n                                             vvvvvvvvvvvvvvvvvv\r\n *  Description:\r\n *      This file implements the Secure Hash Signature Standard\r\n *      algorithms as defined in the National Institute of Standards\r\n *      and Technology Federal Information Processing Standards\r\n *      Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\r\n *      published on August 1, 2002, and the FIPS PUB 180-2 Change\r\n *      Notice published on February 28, 2004.\r\n",
    "correct_text": "It should say:\r\n\r\n *  Description:\r\n|*      This file implements the Secure Hash Algorithms\r\n *      as defined in the National Institute of Standards\r\n *      and Technology Federal Information Processing Standards\r\n *      Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\r\n *      published on August 1, 2002, and the FIPS PUB 180-2 Change\r\n *      Notice published on February 28, 2004.",
    "notes": "Avoiding the term \"Signature\" in accordance with the Standards\r\nmentioned.  The NIST consistently uses the acronyms \"SHA\" for\r\n\"Secure Hash Algorithm\" and \"SHS\" for \"Secure Hash Standard\"\r\nand precisely distinguished between these two terms.",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2416,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.1",
    "orig_text": "The initial Description in the file, on page 24 of the RFC, says:\r\n\r\n                                             vvvvvvvvvvvvvvvvvv\r\n *  Description:\r\n *      This file implements the Secure Hash Signature Standard\r\n *      algorithms as defined in the National Institute of Standards\r\n *      and Technology Federal Information Processing Standards\r\n *      Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\r\n *      published on August 1, 2002, and the FIPS PUB 180-2 Change\r\n *      Notice published on February 28, 2004.",
    "correct_text": "It should say:\r\n\r\n *  Description:\r\n|*      This file implements the Secure Hash Algorithm SHA-1\r\n *      as defined in the National Institute of Standards\r\n *      and Technology Federal Information Processing Standards\r\n *      Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\r\n *      published on August 1, 2002, and the FIPS PUB 180-2 Change\r\n *      Notice published on February 28, 2004.",
    "notes": "See Errata 2415.\r\nAlso replace \"algorithms\" by \"Algorithm SHA-1\" to properly match\r\nthe description with the scope of the file.",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2417,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.1",
    "orig_text": "The comment text, at the bottom of page 24, says:\r\n\r\n *  Caveats:\r\n *      SHA-1 is designed to work with messages less than 2^64 bits\r\n *      long. This implementation uses SHA1Input() to hash the bits\r\n *      that are a multiple of the size of an 8-bit character, and then\r\n *      uses SHA1FinalBits() to hash the final few bits of the input.\r\n */",
    "correct_text": "It should better say:\r\n\r\n *  Caveats:\r\n *      SHA-1 is designed to work with messages less than 2^64 bits\r\n *      long. This implementation uses SHA1Input() to hash the bits\r\n *      that are a multiple of the size of an 8-bit character, and then\r\n|*      optionally uses SHA1FinalBits() to hash the final few bits of\r\n *      the input.\r\n */",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2418,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.1",
    "orig_text": "Near the top of page 25, there is the code:\r\n\r\n/*\r\n * add \"length\" to the length\r\n */\r\nstatic uint32_t addTemp;\r\n#define SHA1AddLength(context, length)                     \\\r\n    (addTemp = (context)->Length_Low,                      \\\r\n     (context)->Corrupted =                                \\\r\n        (((context)->Length_Low += (length)) < addTemp) && \\\r\n        (++(context)->Length_High == 0) ? 1 : 0)\r\n",
    "correct_text": "It should say (modifying the last line):\r\n\r\n/*\r\n * add \"length\" to the length\r\n */\r\nstatic uint32_t addTemp;\r\n#define SHA1AddLength(context, length)                     \\\r\n    (addTemp = (context)->Length_Low,                      \\\r\n     (context)->Corrupted =                                \\\r\n        (((context)->Length_Low += (length)) < addTemp) && \\\r\n        (++(context)->Length_High == 0) ? shaInputTooLong : shaSuccess )",
    "notes": "As can be found on page 19 (upper half), sha.h contains:\r\n\r\n#ifndef _SHA_enum_\r\n#define _SHA_enum_\r\n/*\r\n *  All SHA functions return one of these values.\r\n */\r\nenum {\r\n    shaSuccess = 0,\r\n    shaNull,            /* Null pointer parameter */\r\n    shaInputTooLong,    /* input data too long */\r\n    shaStateError,      /* called Input after FinalBits or Result */\r\n    shaBadParam         /* passed a bad parameter */\r\n};\r\n#endif /* _SHA_enum_ */\r\n\r\nThis leaves it to the compiler to assign values, but ordinarily,\r\n  shaNull          will be assigned the value 1,\r\n  shaInputTooLong  will be assigned the value 2, etc. ...\r\n\r\nThe value assigned to context->Corrupted in the #define listed\r\nabove will later on repeatedly be used to generate return values,\r\nvia code lines:\r\n                 return context->Corrupted;\r\n\r\nThese return values are expected to be SHA_enum values.\r\nIn the case where Corrupted gets assigned the value 0, it apparently\r\nwas intended to eventually get the return value 'shaSuccess', and\r\nin the case where Corrupted gets assigned the value 1, it apparently\r\nwas intended to eventually get the return value 'shaInputTooLong'.\r\nWith the code shown above, the former will work, but the latter\r\nwill usually *not* work as intended.\r\n\r\nTo obtain portable source code behaving as documented, the proposed\r\nchange has to be applied.",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2419,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.1",
    "orig_text": "Througout the sample source code, ANSI-C style is used for the\r\nfunction prototypes, i.e. giving type and name for function\r\narguments.  This rule is broken on mid-page 25, just below\r\nthe offending snippit from item (5) above.\r\nFor consistency and portability, the source code fragment:\r\n\r\n/* Local Function Prototypes */\r\nstatic void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte);\r\nstatic void SHA1PadMessage(SHA1Context *, uint8_t Pad_Byte);\r\nstatic void SHA1ProcessMessageBlock(SHA1Context *);\r\n\r\nshould better say, amending the last two lines:\r\n\r\n/* Local Function Prototypes */\r\nstatic void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte);\r\nstatic void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte);\r\nstatic void SHA1ProcessMessageBlock(SHA1Context *context);",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2420,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.1",
    "orig_text": "The Description comments for the SHA$$$Result functions repeatedly\r\ncontains improper wording and unpleasent formatting.\r\nSee below for significant flaws.\r\nThis change is proposed for the sake of consistency.\r\n\r\nThe Description of SHA1Result on page 28, says:\r\n\r\n * Description:\r\n *   This function will return the 160-bit message digest into the\r\n *   Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the 19th element.\r\n\r\nFor correctness and consistency, it should better say:\r\n\r\n * Description:\r\n *   This function will return the 160-bit message digest\r\n *   into the Message_Digest array provided by the caller.\r\n *   NOTE:\r\n *    The first octet of the hash is stored in the element with index 0,\r\n *    the last octet of the hash in the element with index 19.\r\n\r\n[The additional line break has been added to keep the first part\r\nof the last sentence on a single line, under RFC formatting rules.]",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2421,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.1",
    "orig_text": "The Description of SHA1ProcessMessageBlock, on page 31, says:\r\n\r\n * Parameters:\r\n *   None.\r\n\r\nThis is not true, as can be seen subsequently in the source code.\r\nThe RFC should say:\r\n\r\n * Parameters:\r\n *   context: [in/out]\r\n *     The SHA context to update",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2422,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "The initial Description in this file, on page 33, says:\r\n\r\n * Description:\r\n *   This file implements the Secure Hash Signature Standard\r\n *   algorithms as defined in the National Institute of Standards\r\n *   and Technology Federal Information Processing Standards\r\n *   Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\r\n *   published on August 1, 2002, and the FIPS PUB 180-2 Change\r\n *   Notice published on February 28, 2004.\r\n\r\nIt should say:\r\n\r\n * Description:\r\n *   This file implements the Secure Hash Algorithms SHA-224 and\r\n *   SHA-256, as defined in the National Institute of Standards\r\n *   and Technology Federal Information Processing Standards\r\n *   Publication (FIPS PUB) 180-2 published on August 1, 2002, and\r\n *   the FIPS PUB 180-2 Change Notice published on February 28, 2004.\r\n\r\nRationale:\r\n\r\nFIPS-PUB 180-1 only specified SHA-1, neither SHA-224 nor SHA-256.\r\nFIPS-PUB 180-2 has introduced SHA-256 (and SHA-384 and SHA-512 as\r\nwell), and SHA-224 has been introduced by the \"Change Notice 1\".\r\nThus, citation of FIPS PUB 180-1 is void and inappropriate in the\r\ncontext of SHA-224 and SHA-256.\r\nAvoiding the term \"Signature\" also conforms to the above Standards\r\n-- cf. item (4) and (5) above.\r\nRestricting the text to the scope of the file -- cf. item (5) above.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2423,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "The comment text, near the bottom of page 33, says:\r\n\r\n * Caveats:\r\n *   SHA-224 and SHA-256 are designed to work with messages less\r\n *   than 2^64 bits long. This implementation uses SHA224/256Input()\r\n *   to hash the bits that are a multiple of the size of an 8-bit\r\n *   character, and then uses SHA224/256FinalBits() to hash the\r\n *   final few bits of the input.\r\n\r\nIt should better say -- cf. item (6) above:\r\n\r\n * Caveats:\r\n *   SHA-224 and SHA-256 are designed to work with messages less\r\n *   than 2^64 bits long. This implementation uses SHA224/256Input()\r\n *   to hash the bits that are a multiple of the size of an 8-bit\r\n|*   character, and then optionally uses SHA224/256FinalBits()\r\n *   to hash the final few bits of the input.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2424,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "On mid-page 34, there is the code:\r\n\r\n/*\r\n * add \"length\" to the length\r\n */\r\nstatic uint32_t addTemp;\r\n#define SHA224_256AddLength(context, length)               \\\r\n  (addTemp = (context)->Length_Low, (context)->Corrupted = \\\r\n    (((context)->Length_Low += (length)) < addTemp) &&     \\\r\n    (++(context)->Length_High == 0) ? 1 : 0)\r\n\r\nIt should say (modifying the last line):\r\n\r\n/*\r\n * add \"length\" to the length\r\n */\r\nstatic uint32_t addTemp;\r\n#define SHA224_256AddLength(context, length)               \\\r\n  (addTemp = (context)->Length_Low, (context)->Corrupted = \\\r\n    (((context)->Length_Low += (length)) < addTemp) &&     \\\r\n    (++(context)->Length_High == 0) ? shaInputTooLong : shaSuccess )\r\n\r\nRationale:  Same as for item (7) above.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2425,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "On top of page 35, the Description of SHA224Reset says:\r\n\r\n                                          vvv\r\n * Description:\r\n *   This function will initialize the SHA384Context in preparation\r\n *   for computing a new SHA224 message digest.\r\n\r\nIt should say:\r\n\r\n * Description:\r\n|*   This function will initialize the SHA224Context in preparation\r\n *   for computing a new SHA224 message digest.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2426,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "Similar to item (9) above, the Description comment of SHA224Result\r\ncontains improper wording and unpleasent formatting. Additionally,\r\ncounting 28 elements as ranging from the \"0th\" up to the \"28th\" is\r\nunpleasant and wrong -- it would indicate 29 elements (octets) !\r\n\r\nOn mid-page 36, the RFC says:\r\n\r\n * Description:\r\n *   This function will return the 224-bit message\r\n *   digest into the Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the 28th element.\r\n\r\nFor correctness and consistency, and for improved readability,\r\nit should say:\r\n\r\n * Description:\r\n *   This function will return the 224-bit message digest\r\n *   into the Message_Digest array provided by the caller.\r\n *   NOTE:\r\n *    The first octet of the hash is stored in the element with index 0,\r\n *    the last octet of the hash in the element with index 27.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2427,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "Similar to item (9) and (16) above, the Description of SHA256Result\r\ncontains improper wording and unpleasent formatting. Additionally,\r\ncounting 32 elements as ranging from the \"0th\" up to the \"32nd\" is\r\nunpleasant and wrong -- it would indicate 33 elements (octets) !\r\n\r\nOn page 39, the RFC says:\r\n\r\n * Description:\r\n *   This function will return the 256-bit message\r\n *   digest into the Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the 32nd element.\r\n\r\nFor correctness and consistency, and for improved readability,\r\nit should say:\r\n\r\n * Description:\r\n *   This function will return the 256-bit message digest\r\n *   into the Message_Digest array provided by the caller.\r\n *   NOTE:\r\n *    The first octet of the hash is stored in the element with index 0,\r\n *    the last octet of the hash in the element with index 31.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2428,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "The sample code presents almost all formal function arguments of type\r\narray with predefined (constant) length with this explicit length.\r\nContrary to that, the definition of SHA256Result does not supply\r\nthe expected size of the formal argument 'Message_Digest'.\r\n\r\nAt the bottom of page 39, RFC 4634 says:\r\n\r\nint SHA256Result(SHA256Context *context, uint8_t Message_Digest[])\r\n{\r\n\r\nFor consistency and clarity, it should say:\r\n\r\nint SHA256Result(SHA256Context *context,\r\n                 uint8_t Message_Digest[SHA256HashSize])\r\n{",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2429,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "The Description of SHA224_256PadMessage, near the bottom of page 40,\r\nsays:\r\n\r\n * Description:\r\n *   According to the standard, the message must be padded to an\r\n *   even 512 bits. The first padding bit must be a '1'. The\r\n *   last 64 bits represent the length of the original message.\r\n *   All bits in between should be 0. This helper function will pad\r\n *   the message according to those rules by filling the\r\n *   Message_Block array accordingly. When it returns, it can be\r\n *   assumed that the message digest has been computed.\r\n\r\nFor clarity, it should say (cf. item (10) above):\r\n\r\n * Description:\r\n|*   According to the standard, the message must be padded to the next\r\n|*   proper multiple of 512 bits. The first padding bit must be a '1'.\r\n *   The last 64 bits represent the length of the original message.\r\n *   All bits in between should be 0. This helper function will pad\r\n *   the message according to those rules by filling the\r\n *   Message_Block array accordingly. When it returns, it can be\r\n *   assumed that the message digest has been computed.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2430,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "Near the bottom of page 43, the Description of SHA224_256Reset says:\r\n\r\n * Description:\r\n *   This helper function will initialize the SHA256Context in\r\n *   preparation for computing a new SHA256 message digest.\r\n\r\nFor completeness and consistency, it should say:\r\n\r\n * Description:\r\n *   This helper function will initialize the SHA256Context in\r\n|*   preparation for computing a new SHA-224 or SHA-256 message digest.\r\n                                     ^^^^^^^^^^    ^",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2431,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.2",
    "orig_text": "Similar to item (9), (16), and (17) above, the Description of\r\nSHA224_256ResultN contains improper wording. Additionally,\r\ncounting 28/32 elements as ranging from the \"0th\" up to the\r\n\"28th/32nd\" is unpleasant and wrong -- that erroneously indicates\r\n29/33 elements (octets) !\r\n\r\nNear the bottom of page 44, the RFC says:\r\n\r\n * Description:\r\n *   This helper function will return the 224-bit or 256-bit message\r\n *   digest into the Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the 28th/32nd element.\r\n\r\nFor correctness and consistency, it should say:\r\n\r\n * Description:\r\n *   This helper function will return the 224-bit or 256-bit message\r\n *   digest into the Message_Digest array provided by the caller.\r\n *   NOTE:\r\n *    The first octet of the hash is stored in the element with index 0,\r\n *    the last octet of the hash in the element with index 27/31.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2432,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "The initial Description in this file, on page 45, says:\r\n\r\n * Description:\r\n *   This file implements the Secure Hash Signature Standard\r\n *   algorithms as defined in the National Institute of Standards\r\n *   and Technology Federal Information Processing Standards\r\n *   Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\r\n *   published on August 1, 2002, and the FIPS PUB 180-2 Change\r\n *   Notice published on February 28, 2004.\r\n\r\nIt should say:\r\n\r\n * Description:\r\n *   This file implements the Secure Hash Algorithms SHA-384 and\r\n *   SHA-512, as defined in the National Institute of Standards\r\n *   and Technology Federal Information Processing Standards\r\n *   Publication (FIPS PUB) 180-2 published on August 1, 2002, and\r\n *   the FIPS PUB 180-2 Change Notice published on February 28, 2004.\r\n\r\nRationale:\r\n\r\nFIPS-PUB 180-1 only specified SHA-1, neither SHA-384 nor SHA-512.\r\nFIPS-PUB 180-2 has introduced SHA-384 and SHA-512 (and SHA-256 as\r\nwell), and the \"Change Notice 1\" has introduced SHA-224.\r\nThus, citation of FIPS PUB 180-1 is void and inappropriate in the\r\ncontext of SHA-384 and SHA-512.\r\nAvoiding the term \"Signature\" also conforms to the above Standards\r\n-- cf. item (4), (5), and (12) above.\r\nRestricting the text to the scope of the file -- cf. item (5) and\r\n(12) above.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2433,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "The comment text, near the top of page 46, says:\r\n\r\n * Caveats:\r\n *   SHA-384 and SHA-512 are designed to work with messages less\r\n *   than 2^128 bits long. This implementation uses\r\n *   SHA384/512Input() to hash the bits that are a multiple of the\r\n *   size of an 8-bit character, and then uses SHA384/256FinalBits()\r\n *   to hash the final few bits of the input.\r\n\r\nIt should better say -- cf. item (6) and (13) above:\r\n\r\n * Caveats:\r\n *   SHA-384 and SHA-512 are designed to work with messages less\r\n *   than 2^128 bits long. This implementation uses SHA384/512Input()\r\n *   to hash the bits that are a multiple of the size of an 8-bit\r\n|*   character, and optionally then uses SHA384/256FinalBits()\r\n *   to hash the final few bits of the input.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2434,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "The first line on page 50 says:\r\n\r\n#else /* !USE_32BIT_ONLY */\r\n\r\nIt should say:\r\n\r\n#else /* !USE_MODIFIED_MACROS */\r\n\r\nRationale:  Look at the #if[n]def structure of the file.\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2435,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "Within the '#ifdef USE_32BIT_ONLY' macro definition branch of the\r\nfile, on mid-page 50 the RFC says:\r\n\r\n/*\r\n * add \"length\" to the length\r\n */\r\nstatic uint32_t addTemp[4] = { 0, 0, 0, 0 };\r\n#define SHA384_512AddLength(context, length) (                        \\\r\n    addTemp[3] = (length), SHA512_ADDTO4((context)->Length, addTemp), \\\r\n    (context)->Corrupted = (((context)->Length[3] == 0) &&            \\\r\n       ((context)->Length[2] == 0) && ((context)->Length[1] == 0) &&  \\\r\n       ((context)->Length[0] < 8)) ? 1 : 0 )\r\n\r\nIt should say:\r\n\r\n/*\r\n * add \"length\" to the length\r\n */\r\nstatic uint32_t addTemp[4] = { 0, 0, 0, 0 };\r\n#define SHA384_512AddLength(context, length) (                        \\\r\n    addTemp[3] = (length), SHA512_ADDTO4((context)->Length, addTemp), \\\r\n    (context)->Corrupted = (((context)->Length[0] < addTemp[3]) &&    \\\r\n       ((context)->Length[1] == 0) && ((context)->Length[1] == 0) &&  \\\r\n       ((context)->Length[0] == 0)) ? shaInputTooLong : shaSuccess )\r\n\r\nRationale:\r\n\r\nThe context words  Lenght[0] ... Length[3]  represent the unsigned\r\n128-bit-wide running (bit-)length of the message text hash so far,\r\nin most-significant word first order.\r\nThe code fragment above is intended to add to this value the\r\nunsigned 32-bit value (uint32_t) length, and to detect overflow\r\n(to 2^128 and above).\r\nThe given code is wrong.\r\n(Apparently it has never been tested with messages long enough to\r\nexhibit this misbehaviour.)\r\nOther parts of the sample code show how this can be done correctly\r\nin the case of long accumulators consisting of two 32-bit words\r\n-- cf. the code snippits in item (7) and (14) above, and item (27)\r\nbelow, as well,\r\nThe replacement code corrects this issue.\r\n\r\nFurthermore, the original code suffers from the same problem as\r\nin item (7) and (14) above; this has been corrected accordingly,\r\nas well.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2436,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "Within the '#ifndef USE_32BIT_ONLY' macro definition branch of the\r\nfile, on mid-page 51 the RFC says:\r\n\r\n/*\r\n * add \"length\" to the length\r\n */\r\nstatic uint64_t addTemp;\r\n#define SHA384_512AddLength(context, length)                   \\\r\n   (addTemp = context->Length_Low, context->Corrupted =        \\\r\n    ((context->Length_Low += length) < addTemp) &&             \\\r\n    (++context->Length_High == 0) ? 1 : 0)\r\n\r\nIt should say:\r\n\r\n/*\r\n * add \"length\" to the length\r\n */\r\nstatic uint64_t addTemp;\r\n#define SHA384_512AddLength(context, length)                   \\\r\n   (addTemp = (context)->Length_Low, (context)->Corrupted =    \\\r\n    (((context)->Length_Low += length) < addTemp) &&           \\\r\n    (++(context)->Length_High == 0) ? shaInputTooLong : shaSuccess )\r\n\r\nRationale:\r\n\r\nSame as for item (7) and (14) above, cf. item (26) as well.\r\n\r\nAdditionally, parentheses have been added around all invocations of\r\nthe macro argument `context` to protect it against various artifacts,\r\nas has been done consistently in the remainder of the sample code.\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2437,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "The sample code presents almost all formal function arguments of type\r\narray with predefined (constant) length with this explicit length.\r\nContrary to that, the function prototypes for SHA384_512Reset do not\r\nsupply the expected size of the formal argument 'H0'.\r\nThis inconsistency should be corrected -- as in item (18) above.\r\n\r\nThere are two instances of the issue (see item (xx) below for\r\nanother two similar instances, with the function declarations):\r\n\r\n(28a)\r\nWithin the function prototype definition part of the\r\n  '#ifdef USE_32BIT_ONLY'\r\nbranch of the sample code, near the bottom of page 50, the RFC says:\r\n\r\nstatic int SHA384_512Reset(SHA512Context *context, uint32_t H0[]);\r\n\r\nFor consistency and clarity, it should say:\r\n\r\nstatic int SHA384_512Reset(SHA512Context *context,\r\n                           uint32_t H0[SHA512HashSize/4]);\r\n\r\n(28b)\r\nWithin the function prototype definition part of the\r\n  '#else /* !USE_32BIT_ONLY */'\r\nbranch of the sample code, near the bottom of page 51, the RFC says:\r\n\r\nstatic int SHA384_512Reset(SHA512Context *context, uint64_t H0[]);\r\n\r\nFor consistency and clarity, it should say:\r\n\r\nstatic int SHA384_512Reset(SHA512Context *context,\r\n                           uint64_t H0[SHA512HashSize/8]);",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2438,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "Similar to item (9), (16), (17), and (22) above, the Description\r\nof SHA384Result contains improper wording and unpleasent formatting.\r\nAdditionally, counting 48 elements as ranging from the \"0th\" up to the\r\n\"48th\" is unpleasant and wrong -- indicating 49 elements (octets) !\r\n\r\nNear the bottom of page 53, the RFC says:\r\n\r\n * Description:\r\n *   This function will return the 384-bit message\r\n *   digest into the Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the 48th element.\r\n\r\nFor correctness and consistency, and for improved readability,\r\nit should say:\r\n\r\n * Description:\r\n *   This function will return the 384-bit message digest\r\n *   into the Message_Digest array provided by the caller.\r\n *   NOTE:\r\n *    The first octet of the hash is stored in the element with index 0,\r\n *    the last octet of the hash in the element with index 47.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2439,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "The Description of SHA384_512PadMessage, on page 58, says:\r\n\r\n * Description:\r\n *   According to the standard, the message must be padded to an\r\n *   even 1024 bits. The first padding bit must be a '1'. The\r\n *   last 128 bits represent the length of the original message.\r\n *   All bits in between should be 0. This helper function will\r\n *   pad the message according to those rules by filling the\r\n *   Message_Block array accordingly. When it returns, it can be\r\n *   assumed that the message digest has been computed.\r\n\r\nFor clarity, it should say (cf. items (10) and (19) above):\r\n\r\n * Description:\r\n|*   According to the standard, the message must be padded to the next\r\n|*   proper multiple of 1024 bits. The first padding bit must be a '1'.\r\n *   The last 128 bits represent the length of the original message.\r\n *   All bits in between should be 0. This helper function will\r\n *   pad the message according to those rules by filling the\r\n *   Message_Block array accordingly. When it returns, it can be\r\n *   assumed that the message digest has been computed.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2440,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "The sample code presents almost all formal function arguments of type\r\narray with predefined (constant) length with this explicit length.\r\nContrary to that, the function definitions for SHA384_512Reset do not\r\nsupply the expected size of the formal argument 'H0'.\r\nThis inconsistency should be corrected -- as in items (18) and (28)\r\nabove.\r\n\r\nNear the top of page 65, RFC 4634 says:\r\n\r\n#ifdef USE_32BIT_ONLY\r\nstatic int SHA384_512Reset(SHA512Context *context, uint32_t H0[])\r\n#else /* !USE_32BIT_ONLY */\r\nstatic int SHA384_512Reset(SHA512Context *context, uint64_t H0[])\r\n#endif /* USE_32BIT_ONLY */\r\n\r\nFor consistency and clarity, it should say:\r\n\r\n#ifdef USE_32BIT_ONLY\r\nstatic int SHA384_512Reset(SHA512Context *context,\r\n                           uint32_t H0[SHA512HashSize/4]);\r\n#else /* !USE_32BIT_ONLY */\r\nstatic int SHA384_512Reset(SHA512Context *context,\r\n                           uint64_t H0[SHA512HashSize/8]);\r\n#endif /* USE_32BIT_ONLY */",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2441,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "Similar to item (9), (16), (17), (22), (29), and (30) above, the\r\nDescription of SHA384_512ResultN contains improper wording.\r\nAdditionally, counting 48/64 elements as ranging from the \"0th\" up to\r\nthe \"48th/64nd\" is unpleasant and wrong -- that erroneously indicates\r\n49/65 elements (octets) !\r\n\r\nOn page 65/66, the RFC says:\r\n\r\n * Description:\r\n *   This helper function will return the 384-bit or 512-bit message\r\n<< page break >>\r\n *   digest into the Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the 48th/64th element.\r\n\r\nFor correctness, it should say:\r\n\r\n * Description:\r\n *   This helper function will return the 384-bit or 512-bit message\r\n<< page break >>\r\n *   digest into the Message_Digest array provided by the caller.\r\n *   NOTE:\r\n *    The first octet of the hash is stored in the element with index 0,\r\n *    the last octet of the hash in the element with index 47/63.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2442,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.2.3",
    "orig_text": "The Description for USHAResult, on top of page 69, says:\r\n\r\n * Description:\r\n *   This function will return the 160-bit message digest into the\r\n *   Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the 19th element.\r\n\r\nIt should say:\r\n\r\n * Description:\r\n *   This function will return the message digest of the appropriate\r\n *   bit size, as returned by USHAHashSizeBits(whichSHA) for the\r\n *   'whichSHA' value used in the preceeding call to USHAReset,\r\n *   into the Message_Digest array provided by the caller.\r\n\r\nRationale:\r\n\r\nThe given text roughly matches the SHA-1 case, it is wrong for all\r\nother cases.  The arguments presented for items (9), (16), (17),\r\n(22), (29), (30), and (33) above apply as well.\r\nThe changed text tries to remain precise while avoiding too much\r\nrepetition of facts presented elsewhere in the sample code.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2443,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.3,
    "orig_text": "The code for (the message oriented) function hmac,\r\non page 73/74, reads:\r\n\r\nint hmac(SHAversion whichSha, const unsigned char *text, int text_len,\r\n    const unsigned char *key, int key_len,\r\n    uint8_t digest[USHAMaxHashSize])\r\n<< page break >>\r\n{\r\n  HMACContext ctx;\r\n  return hmacReset(&ctx, whichSha, key, key_len) ||\r\n         hmacInput(&ctx, text, text_len) ||\r\n         hmacResult(&ctx, digest);\r\n}\r\n\r\nIt should say:\r\n\r\nint hmac(SHAversion whichSha,\r\n         const unsigned char *message_array, int length,\r\n         const unsigned char *key, int key_len,\r\n         uint8_t digest[USHAMaxHashSize])\r\n<< page break >>\r\n{\r\n  HMACContext ctx;\r\n  return hmacReset(&ctx, whichSha, key, key_len) ||\r\n         hmacInput(&ctx, message_array, length) ||\r\n         hmacResult(&ctx, digest);\r\n}\r\n\r\nRationale:\r\n\r\nThe argument names `message_array` and `length` are used\r\nthroughout the sample code, including the Description of the\r\nfunction hmac, on page 73.\r\nThe code shown above was not aligned with this practise and\r\nhence inconsistent with the Description.\r\nThis has been resolved by the proposed update, bay changing\r\nthe names of 'text' and 'text_len'.\r\n\r\n>>>>>  NOTE / Caution :\r\n>>>>>\r\n>>>>>  Similar (and additional) inconsistencies between the\r\n>>>>>  argument names in the 'Parameters:' documentation\r\n>>>>>  and the variable names used in the subsequent code\r\n>>>>>  exist for all hmac* functions, on pages 74..77 ;\r\n>>>>>  in particular, the described 'context' is always\r\n>>>>>  named `ctx` in the code.\r\n>>>>>  Also, capitalization of the leading \"HMAC\"/\"hmac\"\r\n>>>>>  in the function names is totally inconsistent.\r\n>>>>>\r\n>>>>>  Resolution of these issues is left as an exercise\r\n>>>>>  to the reader of this note -- or the author of any\r\n>>>>>  future update of the sample code.\r\n>>>>>\r\n>>>>>  Furthermore, the use of \"characters\" as units of the\r\n>>>>>  message_text in the descriptions is dangerous in the\r\n>>>>>  days of Unicode and UTF-8; \"characters\" should better\r\n>>>>>  be replaced by \"octets\" throughout hmac.c !\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2444,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.3,
    "orig_text": "The Description of hmacResult, on top of page 77, says:\r\n\r\n * Description:\r\n *   This function will return the N-byte message digest into the\r\n *   Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the Nth element.\r\n\r\nIt should perhaps just say:\r\n\r\n * Description:\r\n *   This function will return the N-byte message digest into the\r\n *   Message_Digest array provided by the caller.\r\n\r\nRationale:\r\nCf. items (9), (16), (17), (22), (29), (30), and (33) above.\r\nFull replacement text for the last two lines is deemed unnecessary.\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2445,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.3,
    "orig_text": "On mid-page 75, the comment within the function hmacReset says:\r\n\r\n   * The HMAC transform looks like:\r\n   *\r\n   * SHA(K XOR opad, SHA(K XOR ipad, text))\r\n   *\r\n   * where K is an n byte key.\r\n   * ipad is the byte 0x36 repeated blocksize times\r\n   * opad is the byte 0x5c repeated blocksize times\r\n   * and text is the data being protected.\r\n\r\nIt should say:\r\n\r\n   * The HMAC transform looks like:\r\n   *\r\n   * SHA(K XOR opad, SHA(K XOR ipad, text))\r\n   *\r\n|  * where K is an n byte key, 0-padded to a total of blocksize bytes,\r\n|  * ipad is the byte 0x36 repeated blocksize times,\r\n|  * opad is the byte 0x5c repeated blocksize times,\r\n   * and text is the data being protected.\r\n\r\nRationale:\r\n\r\nWithout the addition, the 'XOR' operations in the formula are\r\nundefined.  Additionally, punctuation is made uniform.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2446,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.3,
    "orig_text": "The Description of hmacResult, on top of page 77, says:\r\n\r\n * Description:\r\n *   This function will return the N-byte message digest into the\r\n *   Message_Digest array provided by the caller.\r\n *   NOTE: The first octet of hash is stored in the 0th element,\r\n *      the last octet of hash in the Nth element.\r\n\r\nIt should perhaps just say:\r\n\r\n * Description:\r\n *   This function will return the N-byte message digest into the\r\n *   Message_Digest array provided by the caller.\r\n\r\nRationale:\r\nCf. items (9), (16), (17), (22), (29), (30), and (33) above.\r\nFull replacement text for the last two lines is deemed unnecessary.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2447,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.4,
    "orig_text": "The initial Description of the file, as presented on page 78,\r\ncontains in its first paragraph the lines:\r\n\r\n *      the seven tests documented for each algorithm in\r\n *        \"The Secure Hash Algorithm Validation System (SHAVS)\",\r\n *        three of which are bit-level tests\r\n *        (http://csrc.nist.gov/cryptval/shs/SHAVS.pdf)\r\n\r\nFor clarity, it should better say:\r\n\r\n *      the seven tests documented for each algorithm in\r\n|*        \"The Secure Hash Algorithm Validation System (SHAVS)\"\r\n|*        (http://csrc.nist.gov/cryptval/shs/SHAVS.pdf),\r\n|*        three of which are bit-level tests\r\n",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2448,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.4,
    "orig_text": "On mid-page 82, the RFC text defines the constant:\r\n\r\n#define PRINTBASE64 4\r\n\r\nwhich is never used in the subsequent test driver code\r\n(Base64 output is not supported).\r\nHence, this line should be deleted.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2449,
    "doc-id": "RFC4634",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 8.4,
    "orig_text": "On mid-page 91, there is the comment:\r\n\r\n/*\r\n * Print the string, converting non-printable characters to hex \"## \".\r\n */\r\n\r\nIt should say:\r\n\r\n/*\r\n * Print the string, converting all characters to hex \"## \".\r\n */\r\n\r\nRationale:\r\n\r\nThere is a significant mismatch between the comment and the\r\nsubsequent code.\r\nThis is being resolved by the replacement text.",
    "correct_text": "",
    "notes": "",
    "submit_date": "2006-08-13",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  }
]
