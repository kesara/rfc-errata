[
  {
    "errata_id": 1423,
    "doc-id": "RFC5234",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 4,
    "orig_text": "repeat         =  1*DIGIT / (*DIGIT \"*\" *DIGIT)",
    "correct_text": "repeat         =  *DIGIT [\"*\" *DIGIT]",
    "notes": "In section 4.  ABNF Definition of ABNF, on Page 10, the definition of <repeat> appears to be ambiguous.\r\n \r\nAfter many weeks of study of RFC 5234 I am unable to discern which alternation to choose for <repeat> for the following string.\r\n \r\n21*ARULENAME\r\n \r\nBoth alternatives are a valid solution but I was not able to determine from the RFC which one should be chosen. By my way of thinking, the first one encountered should be chosen but when done, the \"*\" is left and will cause a parsing error. Conversely I could have performed a look ahead check in my parsor, but that would produce a less efficient parser, forcing all alternatives to always be processed.  In either case, the rule is ambiguous and, in my opinion, requires further definition.\r\n \r\nMy recommendation would be to change it to \r\n \r\nrepeat         =  *DIGIT [\"*\" *DIGIT]\r\n \r\nThis solution does not introduce any ambiguity and does not break any components of the definition of ABNF.\r\n \r\nI realize that the forced presence of a digit on the <repeat> without the * is no longer present, but it was not necessary since the only use of <repeat> is by <repetition> and its presence is optional.\r\n\r\n --VERIFIER NOTES-- \r\n\r\nThe following is the text of an analysis of Erratum entry <http://www.rfc-editor.org/errata_search.php?rfc=5234&eid=1423>, made by Paul Overell:\r\n\r\n\r\n> Section: 4.\r\n>\r\n> Original Text\r\n> -------------\r\n> repeat = 1*DIGIT / (*DIGIT \"*\" *DIGIT)\r\n>\r\n\r\nI can see nothing wrong with this, there is no ambiguity. To be ambiguous it would have to be able to generate a particular string in more than one way.\r\n\r\nA <repeat> without a \"*\" can only be generated by the first alterative. A <repeat> with a \"*\" can only be generated by the second alternative.\r\n\r\n\r\n> Corrected Text\r\n> --------------\r\n> repeat = *DIGIT [\"*\" *DIGIT]\r\n\r\nThis changes the syntax of <repeat> as it allow the empty string.\r\n\r\n\r\n> Notes\r\n> -----\r\n> In section 4. ABNF Definition of ABNF, on Page 10, the definition of <repeat> appears to be ambiguous.\r\n>\r\n> After many weeks of study of RFC 5234 I am unable to discern which alternation to choose for <repeat> for the following string.\r\n>\r\n> 21*ARULENAME\r\n\r\nThis clearly matches the second alternative (*DIGIT \"*\" *DIGIT) and therefor is an instance of a <repeat>. This string can only be generated using the second alternative.\r\n\r\n\r\n> Both alternatives are a valid solution but I was not able to determine from the RFC which one should be chosen. By my way of thinking, the first one encountered should be chosen but when done, the \"*\" is left and will cause a parsing error.\r\n\r\nThe first cannot be chosen precisely because the \"*\" is left and causes a parsing error.\r\n\r\n> Conversely I could have performed a look ahead check in my parsor, but that would produce a less efficient parser, forcing all alternatives to always be processed.\r\n\r\nThe grammar given for ABNF is not, and does not claim to be, LL(0). I expect the ABNF grammar could be recast as LL(0) but there is no need, it was written for clarity.\r\n\r\nI can't see the relevance of parser efficiency here.\r\n\r\n> In either case, the rule is ambiguous and, in my opinion, requires further definition.\r\n\r\nAs discussed above, there is no ambiguity.\r\n\r\n\r\n> My recommendation would be to change it to\r\n\r\n> repeat = *DIGIT [\"*\" *DIGIT]\r\n>\r\n> This solution does not introduce any ambiguity and does not break any components of the definition of ABNF.\r\n\r\nIt is not equivalent to the original in that it allows the empty string.\r\n\r\n\r\n> I realize that the forced presence of a digit on the <repeat> without the * is no longer present, but it was not necessary since the only use of <repeat> is by <repetition> and its presence is optional.\r\n\r\nThe proposed change to <repeat> breaks the definition of <repetition> as it then becomes ambiguous.\r\n\r\nConsider the string \"foo\". With the proposed change to <repeat> it can be parsed as a <repetition> in two ways: <repeat> <element> or as <element>, the first with the option taken, the second with the option not taken. Two parse trees for the same string. To fix this ambiguity the definition of <repetition> would have to be changed to\r\n\r\nrepetition = repeat element\r\n\r\n\r\nI recommend that this errata is rejected.\r\n\r\nThere is no ambiguity to fix, the proposed change is unnecessary, and would require an additional change to the definition of <repetition>.\r\n\r\n  ",
    "submit_date": "2008-05-13",
    "submitter_name": "David J. Rutkin",
    "verifier_id": 2,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2820,
    "doc-id": "RFC5234",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 4,
    "orig_text": "         prose-val      =  \"<\" *(%x20-3D / %x3F-7E) \">\"\r\n                                ; bracketed string of SP and VCHAR\r\n                                ;  without angles",
    "correct_text": "         prose-val      =  \"<\" *(%x20-3D / %x3F-7E) \">\"\r\n                                ; bracketed string of SP and VCHAR\r\n                                ;  without \">\"",
    "notes": "\"without angles\" suggests that \">\" and \"<\"\r\nmust not appear but the range of codes given\r\nsuggests that only \">\" must not appear.",
    "submit_date": "2011-06-03",
    "submitter_name": "Spiros Bousbouras",
    "verifier_id": 127,
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2914,
    "doc-id": "RFC5234",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "         alternation    =  concatenation\r\n                           *(*c-wsp \"/\" *c-wsp concatenation)\r\n\r\n         concatenation  =  repetition *(1*c-wsp repetition)\r\n\r\n         repetition     =  [repeat] element\r\n\r\n         repeat         =  1*DIGIT / (*DIGIT \"*\" *DIGIT)\r\n\r\n         element        =  rulename / group / option /\r\n                           char-val / num-val / prose-val\r\n\r\n         group          =  \"(\" *c-wsp alternation *c-wsp \")\"\r\n\r\n         option         =  \"[\" *c-wsp alternation *c-wsp \"]\"",
    "correct_text": null,
    "notes": "Section 4. (ABNF Definition of ABNF) contains at least 2 recursions.\r\nRecursions are not explicitly mentioned in the document, which may be confusing.",
    "submit_date": "2011-08-03",
    "submitter_name": "Rudolf Dovicin",
    "verifier_id": 127,
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2968,
    "doc-id": "RFC5234",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 4,
    "orig_text": "elements       =  alternation *c-wsp",
    "correct_text": "elements       =  alternation *WSP",
    "notes": "The grammar in section 4 of RFC 5234 is ambiguous. This was discovered by my own parsing code when trying to parse the ABNF grammar with itself. The ambiguity can be seen in a simplified form using the following 10 characters of input:\r\n\r\nInput:   X  =  Y \\r \\n     ;  Z \\r \\n\r\nOffset:  0  1  2  3  4  5  6  7  8  9 \r\n\r\nMy parser finds these two (ambiguous) solutions...\r\n\r\nSOLUTION 1:\r\n\r\nrulelist @ 0 len 10\r\n    rule @ 0 len 10\r\n        rulename @ 0 len 1  \"X\"\r\n            ALPHA @ 0 len 1\r\n        star_c_wsp @ 1 len 0\r\n        defined_as @ 1 len 1\r\n            star_c_wsp @ 2 len 0\r\n        elements @ 2 len 4\r\n            alternation @ 2 len 1\r\n                concatenation @ 2 len 1\r\n                    repetition @ 2 len 1\r\n                        element @ 2 len 1\r\n                            rulename @ 2 len 1  \"Y\"\r\n                                ALPHA @ 2 len 1\r\n            star_c_wsp @ 3 len 3\r\n                c_wsp @ 3 len 3\r\n                    c_nl @ 3 len 2\r\n                        CRLF @ 3 len 2\r\n                            CR @ 3 len 1\r\n                            LF @ 4 len 1\r\n                    WSP @ 5 len 1\r\n                        SP @ 5 len 1\r\n        c_nl @ 6 len 4\r\n            comment @ 6 len 4  \";Z\r\n\"\r\n                WSP_or_VCHAR @ 7 len 1\r\n                    VCHAR @ 7 len 1\r\n                CRLF @ 8 len 2\r\n                    CR @ 8 len 1\r\n                    LF @ 9 len 1\r\n\r\nSOLUTION 2:\r\n\r\nrulelist @ 0 len 10\r\n    rule @ 0 len 5\r\n        rulename @ 0 len 1  \"X\"\r\n            ALPHA @ 0 len 1\r\n        star_c_wsp @ 1 len 0\r\n        defined_as @ 1 len 1\r\n            star_c_wsp @ 2 len 0\r\n        elements @ 2 len 1\r\n            alternation @ 2 len 1\r\n                concatenation @ 2 len 1\r\n                    repetition @ 2 len 1\r\n                        element @ 2 len 1\r\n                            rulename @ 2 len 1  \"Y\"\r\n                                ALPHA @ 2 len 1\r\n            star_c_wsp @ 3 len 0\r\n        c_nl @ 3 len 2\r\n            CRLF @ 3 len 2\r\n                CR @ 3 len 1\r\n                LF @ 4 len 1\r\n    star_c_wsp @ 5 len 1\r\n        c_wsp @ 5 len 1\r\n            WSP @ 5 len 1\r\n                SP @ 5 len 1\r\n    c_nl @ 6 len 4\r\n        comment @ 6 len 4  \";Z\r\n\"\r\n            WSP_or_VCHAR @ 7 len 1\r\n                VCHAR @ 7 len 1\r\n            CRLF @ 8 len 2\r\n                CR @ 8 len 1\r\n                LF @ 9 len 1\r\n\r\n\r\nThe solution to this ambiguity is to change:\r\n    elements       =  alternation *c-wsp\r\nto:\r\n    elements       =  alternation *WSP\r\n\r\n\r\n --VERIFIER NOTES-- \r\n\r\nThe current document is clearly incorrect. However, though the solution appears correct, it has not been tested.",
    "submit_date": "2011-09-12",
    "submitter_name": "Daniel van Vugt",
    "verifier_id": 127,
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3076,
    "doc-id": "RFC5234",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 4,
    "orig_text": " rulelist       =  1*( rule / (*c-wsp c-nl) )",
    "correct_text": " rulelist       =  1*( rule / (*WSP c-nl) )",
    "notes": "This errata is very similar to errata 2968, but different.\r\n\r\nThe grammar in section 4 is ambiguous. This ambiguity is revealed using 7 characters of input:\r\n    ';' <CR> <LF> <SP> ';' <CR> <LF>\r\n\r\nwhich produces 2 different matches (please forgive my program output):\r\n\r\nrulelist @ 0 len 7\r\n    rulelist1 @ 0 len 3\r\n        star_c_wsp @ 0 len 0\r\n        c_nl @ 0 len 3\r\n            comment @ 0 len 3  \";\\r\\n\"\r\n                CRLF @ 1 len 2\r\n                    CR @ 1 len 1\r\n                    LF @ 2 len 1\r\n    rulelist1 @ 3 len 4\r\n        star_c_wsp @ 3 len 1\r\n            c_wsp @ 3 len 1\r\n                WSP @ 3 len 1\r\n                    SP @ 3 len 1\r\n        c_nl @ 4 len 3\r\n            comment @ 4 len 3  \";\\r\\n\"\r\n                CRLF @ 5 len 2\r\n                    CR @ 5 len 1\r\n                    LF @ 6 len 1\r\n\r\n-----------\r\n\r\nrulelist @ 0 len 7\r\n    rulelist1 @ 0 len 7\r\n        star_c_wsp @ 0 len 4\r\n            c_wsp @ 0 len 4\r\n                c_nl @ 0 len 3\r\n                    comment @ 0 len 3  \";\\r\\n\"\r\n                        CRLF @ 1 len 2\r\n                            CR @ 1 len 1\r\n                            LF @ 2 len 1\r\n                WSP @ 3 len 1\r\n                    SP @ 3 len 1\r\n        c_nl @ 4 len 3\r\n            comment @ 4 len 3  \";\\r\\n\"\r\n                CRLF @ 5 len 2\r\n                    CR @ 5 len 1\r\n                    LF @ 6 len 1\r\n\r\n-----------\r\n\r\nA solution to this ambiguity, which I have verified works, is:\r\n rulelist       =  1*( rule / (*WSP c-nl) )\r\n\r\nThis prevents the c-nl inside c-wsp from getting confused with the c-nl in rulelist.\r\n\r\n --VERIFIER NOTES-- \r\n\r\nThe current document is clearly incorrect. However, though the solution appears correct, it has not been tested.",
    "submit_date": "2012-01-04",
    "submitter_name": "Daniel van Vugt",
    "verifier_id": 127,
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3096,
    "doc-id": "RFC5234",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "B.1",
    "orig_text": "LWSP           =  *(WSP / CRLF WSP)",
    "correct_text": "LWSP           =  1*(WSP / CRLF WSP)",
    "notes": "RFC 822 said:\r\nlinear-white-space =  1*([CRLF] LWSP-char)\n --VERIFIER NOTES-- \nPaul Overell notes the following (and Dave Crocker concurs):\r\n\r\n###\r\n\r\nThe suggested change would give LWSP the same syntactic definition as RFC822's linear-white-space.\r\n\r\nHowever, the successor to RFC822, RFC5322, doesn't use LWSP, it has its own definitions specifying header folding. Nor does RFC5234 itself use LWSP.\r\n\r\nThere are RFCs that use the existing definition, e.g. RFC6376, RFC5191, RFC5987.  These would need to be fixed if we changed the definition of LWSP.\r\n\r\nThe existing definition of LWSP has been around since 1997, it is not wrong or unreasonable, just different from RFC822's linear-white-space.\r\n\r\n###\r\n",
    "submit_date": "2012-01-23",
    "submitter_name": "MURATA Yasuhisa",
    "verifier_id": 121,
    "verifier_name": "Peter Saint-Andre",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4040,
    "doc-id": "RFC5234",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "B.1",
    "orig_text": "HEXDIG         =  DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"",
    "correct_text": "HEXDIG         =  DIGIT\r\n               / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\r\n               / \"a\" / \"b\" / \"c\" / \"d\" / \"e\" / \"f\"",
    "notes": "Various RFCs are quoting HEXDIG under the currently incorrect understanding that it includes a-f as well as 0-9 and A-F, and I believe this is the place where it should be changed, rather than altering them to use a different rule.\r\n\r\nHere are a couple of examples of the problem this causes that came quickly to hand:\r\n\r\n- RFC 7230: section 1.2 cites ?HEXDIG (hexadecimal 0-9/A-F/a-f)?, section 4.1 proceeds to use HEXDIG in chunk-size, which in RFC 2616 was HEX which did indeed include a-f.\r\n\r\n- RFC 3986: it replaces the hex of RFC 2396, which included a-f, with this HEXDIG of RFC 2234 (of which this document is the latest form). This is then used in pct-encoded (percent-encoding in URLs), IPvFuture and h16 (IPv6 addresses), all of which can reasonably be expected to permit lowercase a-f as well as uppercase.\n --VERIFIER NOTES-- \nIn Section 2.3, RFC 5234 explicitly says this:\r\n\r\n   NOTE:\r\n      ABNF strings are case insensitive and the character set for these\r\n      strings is US-ASCII.\r\n\r\nSo the definition of HEXDIG already allows for both upper and lower case (or a mixture).\r\n\r\nIt's true that some people aren't aware of that, and write their documents without understanding it.  But it is not an error in 5234.",
    "submit_date": "2014-07-03",
    "submitter_name": "Chris Morgan",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4361,
    "doc-id": "RFC5234",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": 2.1,
    "orig_text": "Unlike original BNF, angle brackets (\"<\", \">\") are not required.\r\nHowever, angle brackets may be used around a rule name whenever their\r\npresence facilitates in discerning the use of a rule name.  This is\r\ntypically restricted to rule name references in free-form prose",
    "correct_text": null,
    "notes": "Section 2.1 could be more explicit as to whether a parser, encountering a string that could be interpreted by humans as a rule name inside angles, should process it as a <rule-name> or not.  The use of the words \"typically restricted\" allow for leeway in interpretation, and in light of section 4 note 1, implementors may be tempted to disregard the formal definition as being simply informative.  Section 3.10 gives <prose-val> looser precedence than rule-name, adding weight to the idea that since there is a ambiguity to be resolved, angle brackets around rule names might be expected to appear in parser input.\r\n\r\nIt is also worth noting that the rule definition for <prose-val> prohibits the use of angle brackets around rule names within the contents of <prose-val> itself, and that the intended use of the <prose-val> rule is only described via comments.\r\n\r\nCorrected text is not provided as the intent is unclear.\n --VERIFIER NOTES-- \nWithin an ABNF parsing context, the handling of rulenames with or\r\nwithout angle-brackets is a small distinction.  Parsers can and do\r\neasily handle rulenames without the brackets; obviously they also can\r\nhandle the presence of the angle-brackets, although they generally\r\ndon't. Omitting brackets from ABNF intended for parsing was generally\r\nreceived as an improvement over BNF, 40 years ago.",
    "submit_date": "2015-05-10",
    "submitter_name": "Brian S. Julin",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4564,
    "doc-id": "RFC5234",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.8,
    "orig_text": "         [foo bar]\r\n\r\n   is equivalent to\r\n\r\n         *1(foo bar).\r\n",
    "correct_text": "         [foo bar]\r\n\r\n   is equivalent to\r\n\r\n         *1(foo/bar).\r\n",
    "notes": "\n --VERIFIER NOTES-- \nIt seems that the reporter misunderstands what \"[foo bar]\"\nmeans.  It means that \"foo bar\" (the two tokens together, as a unit)\nis optional.  It is not suggesting an alternative of \"foo\" or \"bar\".",
    "submit_date": "2015-12-14",
    "submitter_name": "iliwoy",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5110,
    "doc-id": "RFC5234",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "B.1.",
    "orig_text": "BIT            =  \"0\" / \"1\"",
    "correct_text": "BIT            =  %b0 / %b1",
    "notes": "The core rule BIT is written in the char-val rule syntax, which produces the ASCII chars %x30 (\"0\") and %x31 (\"1\"). For producing the 0 and 1 bit the bin-val rule should be used instead. Since the core rules use the hex-val rule extensively, using the bin-val rule shouldn't be a problem.\n --VERIFIER NOTES-- \nNo, the \"BIT\" construct is part of the \"bin-val\" construct, which gives \"b0\" or \"b1\", and \"bin-val\" is then part of \"num-val\", which is what produces \"%b0\" or \"%b1\".  The ABNF is correct as written.",
    "submit_date": "2017-09-09",
    "submitter_name": "Allan Hazarian",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-05-14 06:11:45"
  },
  {
    "errata_id": 6172,
    "doc-id": "RFC5234",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "Appendix B",
    "orig_text": "Note that these rules are only valid for ABNF encoded in 7-bit ASCII or in characters sets that are a superset of 7-bit ASCII.",
    "correct_text": "Note that these rules are only valid for ABNF encoded in 7-bit ASCII or in character sets that are a superset of 7-bit ASCII.",
    "notes": "Typo.",
    "submit_date": "2020-05-14",
    "submitter_name": "Glyn Normington",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-05-14 06:06:43"
  },
  {
    "errata_id": 6173,
    "doc-id": "RFC5234",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 3.6,
    "orig_text": "The operator \"*\" preceding an element indicates repetition. The full form is:\r\n\r\n <a>*<b>element\r\n\r\nwhere <a> and <b> are optional decimal values, indicating at least <a> and at most <b> occurrences of the element.\r\n\r\nDefault values are 0 and infinity so that *<element> allows any number, including zero; 1*<element> requires at least one; 3*3<element> allows exactly 3; and 1*2<element> allows one or two.",
    "correct_text": "The operator \"*\" preceding an element indicates repetition. The full form is:\r\n\r\n <a>*<b>element\r\n\r\nwhere <a> and <b> are optional decimal values, indicating at least <a> and at most <b> occurrences of the element.\r\n\r\nThe default value of <a> is 0. If <b> is omitted, there is no upper limit to the number of occurrences of the element. Consequently *<element> allows any number, including zero; 1*<element> requires at least one; 3*3<element> allows exactly 3; and 1*2<element> allows one or two.",
    "notes": "infinity is not a decimal value",
    "submit_date": "2020-05-14",
    "submitter_name": "Glyn Normington",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-05-14 06:05:17"
  }
]
