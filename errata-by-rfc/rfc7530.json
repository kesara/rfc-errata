[
  {
    "errata_id": 4329,
    "doc-id": "RFC7530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "21.1.",
    "orig_text": "   [openg_symlink]\r\n              The Open Group, \"Section 3.372 of Chapter 3 of Base\r\n              Definitions of The Open Group Base Specifications\r\n              Issue 7\", IEEE Std 1003.1, 2013 Edition (HTML Version),\r\n              ISBN 1937218287, April 2013, <http://www.opengroup.org/>.",
    "correct_text": "   [openg_symlink]\r\n              The Open Group, \"Section 3.375 of Chapter 3 of Base\r\n              Definitions of The Open Group Base Specifications\r\n              Issue 7\", IEEE Std 1003.1, 2013 Edition (HTML Version),\r\n              ISBN 1937218287, April 2013, <http://www.opengroup.org/>.",
    "notes": null,
    "submit_date": "2015-04-07",
    "submitter_name": "Marcel Telka",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4471,
    "doc-id": "RFC7530",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "16.10.4.",
    "orig_text": "   In the case that the lock is denied, the owner, offset, and length of\r\n   a conflicting lock are returned.",
    "correct_text": "   In the case that the lock is denied, the owner, offset, length, and\r\n   type of a conflicting lock are returned.",
    "notes": "The locktype in LOCK4denied is not specified for the LOCK operation.  See 16.11.4. for similar wording for LOCKT.",
    "submit_date": "2015-09-12",
    "submitter_name": "Marcel Telka",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4639,
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 5.9,
    "orig_text": "To provide a greater degree of compatibility with NFSv3, which\r\nidentified users and groups by 32-bit unsigned user identifiers and\r\ngroup identifiers, owner and group strings that consist of ASCII-\r\nencoded decimal numeric values with no leading zeros can be given a\r\nspecial interpretation by clients and servers that choose to provide\r\nsuch support.",
    "correct_text": "To provide a greater degree of compatibility with NFSv3, which\r\nidentified users and groups by 32-bit unsigned user identifiers and\r\ngroup identifiers, owner and group strings that consist of UTF-8\r\nencoded decimal numeric values with no leading zeros can be given a\r\nspecial interpretation by clients and servers that choose to provide\r\nsuch support.",
    "notes": "The start of section 5.9 says:\r\n\r\nThe RECOMMENDED attributes \"owner\" and \"owner_group\" (and also users\r\nand groups used as values of the who field within nfs4ace structures\r\nused in the acl attribute) are represented in the form of UTF-8\r\nstrings.\r\n\r\nI believe in the case of the digits 0-9 the ASCII encoding is the same as the UTF-8 encoding but it may cause possible confusion by not maintaining consistency.",
    "submit_date": "2016-03-16",
    "submitter_name": "Stephen Butler",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4742,
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "section-6.2.",
    "orig_text": "https://tools.ietf.org/html/rfc7530#section-6.2.1\r\n\r\n   The client can use the OPEN or ACCESS\r\n   operations to check access without modifying or reading data or\r\n   metadata.",
    "correct_text": "   The client can use the OPEN or ACCESS\r\n   operations to check access without modifying or reading data.",
    "notes": "Whenever client does OPEN/ACCESS call, there is an inadvertent change in the Last Access time of the file. Hence we think that the Metadata is modified due to OPEN/ACCESS call.  Hence the Suggestion is to change the text as above.",
    "submit_date": "2016-07-15",
    "submitter_name": "Manju Karthik",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4828,
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "16.24.4.",
    "orig_text": "   The arguments contain a cookie value that represents where the\r\n   READDIR should start within the directory.  A value of 0 (zero) for\r\n   the cookie is used to start reading at the beginning of the\r\n   directory.  For subsequent READDIR requests, the client specifies a\r\n   cookie value that is provided by the server in a previous READDIR\r\n   request.",
    "correct_text": "   The arguments contain a cookie value that represents where the\r\n   READDIR should start within the directory.  A value of 0 (zero) for\r\n   the cookie is used to start reading at the beginning of the\r\n   directory.  For subsequent READDIR requests, the client specifies a\r\n   cookie value that is provided by the server in a previous READDIR\r\n   reply.",
    "notes": "The new cookie is provided by the server in a reply, not in a request.",
    "submit_date": "2016-10-11",
    "submitter_name": "Marcel Telka",
    "verifier_id": 2,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4934,
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "9.1.7.",
    "orig_text": "   When a request is received, its sequence number (r) is compared to\r\n   that of the last one received (L).  Only if it has the correct next\r\n   sequence, normally L + 1, is the request processed beyond the point\r\n   of seqid checking.  Given a properly functioning client, the response\r\n   to (r) must have been received before the last request (L) was sent.",
    "correct_text": "   When a request is received, its sequence number (r) is compared to\r\n   that of the last one received (L).  Only if it has the correct next\r\n   sequence, normally L + 1, is the request processed beyond the point\r\n   of seqid checking.  Given a properly functioning client, the response\r\n   to (L) must have been received before the subsequent request (r) was\r\n   sent.",
    "notes": null,
    "submit_date": "2017-02-15",
    "submitter_name": "Marcel Telka",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5407,
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 16.36,
    "orig_text": "The write\r\n   verifier is a cookie that the client can use to determine whether the\r\n   server has changed instance (boot) state between a call to WRITE and\r\n   a subsequent call to either WRITE or COMMIT.  This cookie must be\r\n   consistent during a single instance of the NFSv4 protocol service and\r\n   must be unique between instances of the NFSv4 protocol server, where\r\n   uncommitted data may be lost.",
    "correct_text": "The write\r\n   verifier is a cookie that the client can use to determine whether the\r\n   server has changed instance (boot) state between a call to WRITE and\r\n   a subsequent call to either WRITE or COMMIT.  This cookie must be\r\n   consistent during a single instance of the NFSv4 protocol service and\r\n   must be unique between instances of the NFSv4 protocol server, where\r\n   uncommitted data may be lost. The server implementation should not\r\n   assume that the cookie is on per file basis.",
    "notes": "Different NFS client implementation has chosen to interpret above statement differently. Semantically, it is correct to track cookie on per file basis since both WRITE and COMMIT happens on a single file handle. But, RFC wording says that the cookie should be maintained on a per server instance basis. Either way, I believe the RFC can be more clearer for both client and server implementer.",
    "submit_date": "2018-06-24",
    "submitter_name": "Viral Mehta",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5471,
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "16.16.5",
    "orig_text": " o  NFS4ERR_BAD_RECLAIM is returned if the other error conditions do\r\n      not apply and the server has no record of the delegation whose\r\n      reclaim is being attempted.\r\n",
    "correct_text": " o  NFS4ERR_RECLAIM_BAD is returned if the other error conditions do\r\n      not apply and the server has no record of the delegation whose\r\n      reclaim is being attempted.\r\n",
    "notes": "The the defined error is NFS4ERR_RECLAIM_BAD",
    "submit_date": "2018-08-18",
    "submitter_name": "Tigran Mkrtchyan",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5472,
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "10.2.1",
    "orig_text": "   When NFS4ERR_EXPIRED is returned, the server MAY retain information\r\n   about the delegations held by the client, deleting those that are\r\n   invalidated by a conflicting request.  Retaining such information\r\n   will allow the client to recover all non-invalidated delegations\r\n   using the claim type CLAIM_DELEGATE_PREV, once the\r\n   SETCLIENTID_CONFIRM is done to recover.  Attempted recovery of a\r\n   delegation that the client has no record of, typically because they\r\n   were invalidated by conflicting requests, will result in the error\r\n   NFS4ERR_BAD_RECLAIM.  Once a reclaim is attempted for all delegations\r\n   that the client held, it SHOULD do a DELEGPURGE to allow any\r\n   remaining server delegation information to be freed.",
    "correct_text": "   When NFS4ERR_EXPIRED is returned, the server MAY retain information\r\n   about the delegations held by the client, deleting those that are\r\n   invalidated by a conflicting request.  Retaining such information\r\n   will allow the client to recover all non-invalidated delegations\r\n   using the claim type CLAIM_DELEGATE_PREV, once the\r\n   SETCLIENTID_CONFIRM is done to recover.  Attempted recovery of a\r\n   delegation that the client has no record of, typically because they\r\n   were invalidated by conflicting requests, will result in the error\r\n   NFS4ERR_RECLAIM_BAD.  Once a reclaim is attempted for all delegations\r\n   that the client held, it SHOULD do a DELEGPURGE to allow any\r\n   remaining server delegation information to be freed.",
    "notes": "The defined error code is NFS4ERR_RECLAIM_BAD",
    "submit_date": "2018-08-18",
    "submitter_name": "Tigran Mkrtchyan",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5531,
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "10.4.6.",
    "orig_text": "   o  When the callback path is down, the server MUST NOT revoke the\r\n      delegation if one of the following occurs:\r\n\r\n      *  (...)\r\n\r\n      *  The client has not issued a RENEW operation for some period of\r\n         time after the server attempted to recall the delegation.  This\r\n         period of time MUST NOT be less than the value of the\r\n         lease_time attribute.",
    "correct_text": "   o  When the callback path is down, the server MUST NOT revoke the\r\n      delegation if one of the following occurs:\r\n\r\n      *  (...)\r\n\r\n      *  The client has not issued a RENEW operation for some period of\r\n         time after the server attempted to recall the delegation.  This\r\n         period of time MUST be less than the value of the\r\n         lease_time attribute.",
    "notes": "It does not make sense to revoke the delegation before lease_time period expiration and to not revoke it after.",
    "submit_date": "2018-10-16",
    "submitter_name": "Sylvain Etienne",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  }
]
