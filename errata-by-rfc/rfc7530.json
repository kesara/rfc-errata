[
  {
    "errata_id": "4329",
    "doc-id": "RFC7530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "21.1.",
    "orig_text": "   [openg_symlink]\r\n              The Open Group, \"Section 3.372 of Chapter 3 of Base\r\n              Definitions of The Open Group Base Specifications\r\n              Issue 7\", IEEE Std 1003.1, 2013 Edition (HTML Version),\r\n              ISBN 1937218287, April 2013, <http://www.opengroup.org/>.",
    "correct_text": "   [openg_symlink]\r\n              The Open Group, \"Section 3.375 of Chapter 3 of Base\r\n              Definitions of The Open Group Base Specifications\r\n              Issue 7\", IEEE Std 1003.1, 2013 Edition (HTML Version),\r\n              ISBN 1937218287, April 2013, <http://www.opengroup.org/>.",
    "notes": null,
    "submit_date": "2015-04-07",
    "submitter_name": "Marcel Telka",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4471",
    "doc-id": "RFC7530",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "16.10.4.",
    "orig_text": "   In the case that the lock is denied, the owner, offset, and length of\r\n   a conflicting lock are returned.",
    "correct_text": "   In the case that the lock is denied, the owner, offset, length, and\r\n   type of a conflicting lock are returned.",
    "notes": "The locktype in LOCK4denied is not specified for the LOCK operation.  See 16.11.4. for similar wording for LOCKT.",
    "submit_date": "2015-09-12",
    "submitter_name": "Marcel Telka",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4639",
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.9",
    "orig_text": "To provide a greater degree of compatibility with NFSv3, which\r\nidentified users and groups by 32-bit unsigned user identifiers and\r\ngroup identifiers, owner and group strings that consist of ASCII-\r\nencoded decimal numeric values with no leading zeros can be given a\r\nspecial interpretation by clients and servers that choose to provide\r\nsuch support.",
    "correct_text": "To provide a greater degree of compatibility with NFSv3, which\r\nidentified users and groups by 32-bit unsigned user identifiers and\r\ngroup identifiers, owner and group strings that consist of UTF-8\r\nencoded decimal numeric values with no leading zeros can be given a\r\nspecial interpretation by clients and servers that choose to provide\r\nsuch support.",
    "notes": "The start of section 5.9 says:\r\n\r\nThe RECOMMENDED attributes \"owner\" and \"owner_group\" (and also users\r\nand groups used as values of the who field within nfs4ace structures\r\nused in the acl attribute) are represented in the form of UTF-8\r\nstrings.\r\n\r\nI believe in the case of the digits 0-9 the ASCII encoding is the same as the UTF-8 encoding but it may cause possible confusion by not maintaining consistency.",
    "submit_date": "2016-03-16",
    "submitter_name": "Stephen Butler",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4742",
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "section-6.2.",
    "orig_text": "https://tools.ietf.org/html/rfc7530#section-6.2.1\r\n\r\n   The client can use the OPEN or ACCESS\r\n   operations to check access without modifying or reading data or\r\n   metadata.",
    "correct_text": "   The client can use the OPEN or ACCESS\r\n   operations to check access without modifying or reading data.",
    "notes": "Whenever client does OPEN/ACCESS call, there is an inadvertent change in the Last Access time of the file. Hence we think that the Metadata is modified due to OPEN/ACCESS call.  Hence the Suggestion is to change the text as above.",
    "submit_date": "2016-07-15",
    "submitter_name": "Manju Karthik",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4828",
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "16.24.4.",
    "orig_text": "   The arguments contain a cookie value that represents where the\r\n   READDIR should start within the directory.  A value of 0 (zero) for\r\n   the cookie is used to start reading at the beginning of the\r\n   directory.  For subsequent READDIR requests, the client specifies a\r\n   cookie value that is provided by the server in a previous READDIR\r\n   request.",
    "correct_text": "   The arguments contain a cookie value that represents where the\r\n   READDIR should start within the directory.  A value of 0 (zero) for\r\n   the cookie is used to start reading at the beginning of the\r\n   directory.  For subsequent READDIR requests, the client specifies a\r\n   cookie value that is provided by the server in a previous READDIR\r\n   reply.",
    "notes": "The new cookie is provided by the server in a reply, not in a request.",
    "submit_date": "2016-10-11",
    "submitter_name": "Marcel Telka",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4934",
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "9.1.7.",
    "orig_text": "   When a request is received, its sequence number (r) is compared to\r\n   that of the last one received (L).  Only if it has the correct next\r\n   sequence, normally L + 1, is the request processed beyond the point\r\n   of seqid checking.  Given a properly functioning client, the response\r\n   to (r) must have been received before the last request (L) was sent.",
    "correct_text": "   When a request is received, its sequence number (r) is compared to\r\n   that of the last one received (L).  Only if it has the correct next\r\n   sequence, normally L + 1, is the request processed beyond the point\r\n   of seqid checking.  Given a properly functioning client, the response\r\n   to (L) must have been received before the subsequent request (r) was\r\n   sent.",
    "notes": null,
    "submit_date": "2017-02-15",
    "submitter_name": "Marcel Telka",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5407",
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "16.36",
    "orig_text": "The write\r\n   verifier is a cookie that the client can use to determine whether the\r\n   server has changed instance (boot) state between a call to WRITE and\r\n   a subsequent call to either WRITE or COMMIT.  This cookie must be\r\n   consistent during a single instance of the NFSv4 protocol service and\r\n   must be unique between instances of the NFSv4 protocol server, where\r\n   uncommitted data may be lost.",
    "correct_text": "The write\r\n   verifier is a cookie that the client can use to determine whether the\r\n   server has changed instance (boot) state between a call to WRITE and\r\n   a subsequent call to either WRITE or COMMIT.  This cookie must be\r\n   consistent during a single instance of the NFSv4 protocol service and\r\n   must be unique between instances of the NFSv4 protocol server, where\r\n   uncommitted data may be lost. The server implementation should not\r\n   assume that the cookie is on per file basis.",
    "notes": "Different NFS client implementation has chosen to interpret above statement differently. Semantically, it is correct to track cookie on per file basis since both WRITE and COMMIT happens on a single file handle. But, RFC wording says that the cookie should be maintained on a per server instance basis. Either way, I believe the RFC can be more clearer for both client and server implementer.",
    "submit_date": "2018-06-24",
    "submitter_name": "Viral Mehta",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5471",
    "doc-id": "RFC7530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "16.16.5",
    "orig_text": " o  NFS4ERR_BAD_RECLAIM is returned if the other error conditions do\r\n      not apply and the server has no record of the delegation whose\r\n      reclaim is being attempted.\r\n",
    "correct_text": " o  NFS4ERR_RECLAIM_BAD is returned if the other error conditions do\r\n      not apply and the server has no record of the delegation whose\r\n      reclaim is being attempted.\r\n",
    "notes": "The the defined error is NFS4ERR_RECLAIM_BAD\r\n\r\n\r\n---\r\nRFC Editor Note: This also appears in Section 10.2.1. See https://www.rfc-editor.org/errata/eid5472.",
    "submit_date": "2018-08-18",
    "submitter_name": "Tigran Mkrtchyan",
    "verifier_id": "2",
    "verifier_name": "RFC Editor",
    "update_date": "2024-02-02 14:01:00"
  },
  {
    "errata_id": "5472",
    "doc-id": "RFC7530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "10.2.1",
    "orig_text": "   When NFS4ERR_EXPIRED is returned, the server MAY retain information\r\n   about the delegations held by the client, deleting those that are\r\n   invalidated by a conflicting request.  Retaining such information\r\n   will allow the client to recover all non-invalidated delegations\r\n   using the claim type CLAIM_DELEGATE_PREV, once the\r\n   SETCLIENTID_CONFIRM is done to recover.  Attempted recovery of a\r\n   delegation that the client has no record of, typically because they\r\n   were invalidated by conflicting requests, will result in the error\r\n   NFS4ERR_BAD_RECLAIM.  Once a reclaim is attempted for all delegations\r\n   that the client held, it SHOULD do a DELEGPURGE to allow any\r\n   remaining server delegation information to be freed.",
    "correct_text": "   When NFS4ERR_EXPIRED is returned, the server MAY retain information\r\n   about the delegations held by the client, deleting those that are\r\n   invalidated by a conflicting request.  Retaining such information\r\n   will allow the client to recover all non-invalidated delegations\r\n   using the claim type CLAIM_DELEGATE_PREV, once the\r\n   SETCLIENTID_CONFIRM is done to recover.  Attempted recovery of a\r\n   delegation that the client has no record of, typically because they\r\n   were invalidated by conflicting requests, will result in the error\r\n   NFS4ERR_RECLAIM_BAD.  Once a reclaim is attempted for all delegations\r\n   that the client held, it SHOULD do a DELEGPURGE to allow any\r\n   remaining server delegation information to be freed.",
    "notes": "The defined error code is NFS4ERR_RECLAIM_BAD\r\n\r\n\r\n--\r\nRFC Editor Note: This also appears in 16.16.5. See https://www.rfc-editor.org/errata/eid5471.",
    "submit_date": "2018-08-18",
    "submitter_name": "Tigran Mkrtchyan",
    "verifier_id": "2",
    "verifier_name": "RFC Editor",
    "update_date": "2024-02-02 14:02:24"
  },
  {
    "errata_id": "5531",
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "10.4.6.",
    "orig_text": "   o  When the callback path is down, the server MUST NOT revoke the\r\n      delegation if one of the following occurs:\r\n\r\n      *  (...)\r\n\r\n      *  The client has not issued a RENEW operation for some period of\r\n         time after the server attempted to recall the delegation.  This\r\n         period of time MUST NOT be less than the value of the\r\n         lease_time attribute.",
    "correct_text": "   o  When the callback path is down, the server MUST NOT revoke the\r\n      delegation if one of the following occurs:\r\n\r\n      *  (...)\r\n\r\n      *  The client has not issued a RENEW operation for some period of\r\n         time after the server attempted to recall the delegation.  This\r\n         period of time MUST be less than the value of the\r\n         lease_time attribute.",
    "notes": "It does not make sense to revoke the delegation before lease_time period expiration and to not revoke it after.",
    "submit_date": "2018-10-16",
    "submitter_name": "Sylvain Etienne",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "7595",
    "doc-id": "RFC7530",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "13.1.7",
    "orig_text": "13.1.7.  Name Errors\r\n\r\n   Names in NFSv4 are UTF-8 strings.  When the strings are not of length\r\n   zero, the error NFS4ERR_INVAL results.  When they are not valid\r\n   UTF-8, the error NFS4ERR_INVAL also results, but servers may\r\n   accommodate file systems with different character formats and not\r\n   return this error.  Besides this, there are a number of other errors\r\n   to indicate specific problems with names.\r\n\r\n13.1.7.1.  NFS4ERR_BADCHAR (Error Code 10040)\r\n\r\n   A UTF-8 string contains a character that is not supported by the\r\n   server in the context in which it is being used.\r\n\r\n13.1.7.2.  NFS4ERR_BADNAME (Error Code 10041)\r\n\r\n   A name string in a request consisted of valid UTF-8 characters\r\n   supported by the server, but the name is not supported by the server\r\n   as a valid name for current operation.  An example might be creating\r\n   a file or directory named \"..\" on a server whose file system uses\r\n   that name for links to parent directories.\r\n\r\n   This error should not be returned due to a normalization issue in a\r\n   string.  When a file system keeps names in a particular normalization\r\n   form, it is the server's responsibility to do the appropriate\r\n   normalization, rather than rejecting the name.\r\n",
    "correct_text": "13.1.7.  Name Errors\r\n\r\nNames in NFSv4 often are UTF-8 strings. However, in order to provide\r\ncompatibility with NFSv3 and with local filesystems that do not impose any such\r\nrestrictions on the form of name strings, UTF-8-unaware file systems are\r\nsupported.  For such file systems,  the server is, for the most part, unaware of\r\nthe encoding of names chosen by the client and is therefore unable to support\r\nnormalization-related processing or case-insensitivity.  In order to provide\r\nproper support for the errors NFS4ERR_BADCHAR and NFS4ERR_BADNAME, the encoding\r\nused by clients MUST use the same encoding as UTF-8 for all printable ASCII\r\ncharacters.\r\n\r\nFor file systems which are UTF-8-aware,  when strings are not valid UTF-8\r\nstrings,  the error NFS4ERR_INVAL results.  As a result, clients can determine\r\nwhether the current file system is UTF-8-aware by looking up a string which is\r\nnot valid UTF-8 (e..g. the single byte 0x80)  and using an error return of\r\nNFS4ERR_INVAl as indicating that only valid UTF-8 strings may be used.\r\n\r\nWhen a string of length zero is passed, the error NFS4ERR_INVAL also results. \r\nbut servers may accommodate file systems with different character formats and\r\nreturn this error only in this case.  Besides this, there are a number of other\r\nerrors to indicate specific problems with names.\r\n\r\n13.1.7.1.  NFS4ERR_BADCHAR (Error Code 10040)\r\n\r\nA UTF-8 string contains a character that is not supported by the server file\r\nsystem as part of a  file name.  For example, the forward slash is often\r\nreserved for use to indicate multiple names within a path, making the creation\r\nof file or directory names with embedded slashes problematic.\r\n\r\n13.1.7.2.  NFS4ERR_BADNAME (Error Code 10041)\r\n\r\nA name string in a request consists of a valid string supported by the server,\r\nwhether UTF-8 or otherwise, but the name is not supported by the server as a\r\nvalid name for the current operation.  An example might be creating a file or\r\ndirectory named \"..\" on a server whose file system uses that name for links to\r\nparent directories.  This error MUST NOT result in case in which  a \r\n(UTF-8-aware) server file system prefers a particular normalization for strings.\r\nIn such cases, it is the server's responsibility to do the appropriate\r\nnormalization, rather than rejecting the name.\r\n",
    "notes": "It has been brought to my attention that there is a fundamental contradiction between the idea\r\n(derived from NFSv3) that file name strings can be  opaque, and the existence of the errors\r\nNFS4ERR_BADCHAR and  NFS4ERR_BADNAME, which, by their nature presume at least some\r\nknowledge of the character encoding being used.\r\n\r\nThis has not turned out to be a problem in practice because clients always use encodings that\r\nmeet certain criteria explained in the replacement text.  However, these criteria need to be\r\ndocumented clearly and appropriate warnings given.  These criteria were observed by\r\nimplementers of NFSv3 but are not explicitly mentioned in RFC1813.",
    "submit_date": "2023-08-10",
    "submitter_name": "David Noveck",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2023-11-10 14:41:50"
  }
]
