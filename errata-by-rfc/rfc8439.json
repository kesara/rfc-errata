[
  {
    "errata_id": 5675,
    "doc-id": "RFC8439",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "2.5.1",
    "orig_text": "for i=1 upto ceil(msg length in bytes / 16)\r\n   n = le_bytes_to_num(msg[((i-1)*16)..(i*16)] | [0x01])\r\n   a += n\r\n   a = (r * a) % p\r\n   end",
    "correct_text": "for i=1 upto floor(msg length in bytes / 16)\r\n   j = min(i*16-1, msg length in bytes - 1)\r\n   n = le_bytes_to_num(msg[((i-1)*16)..j] | [0x01])\r\n   a += n\r\n   a = (r * a) % p\r\n   end\r\n",
    "notes": "Corection for lengths of msg blocks (full blocks are of size 16, NOT 17 and last blocks of size != 16 have to be treated separately).\n --VERIFIER NOTES-- \n   Rejected in favour of errata 5689.",
    "submit_date": "2019-03-25",
    "submitter_name": "Stefan Heiss",
    "verifier_id": 163,
    "verifier_name": "Colin Perkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5689,
    "doc-id": "RFC8439",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.5.1",
    "orig_text": "for i=1 upto ceil(msg length in bytes / 16)\r\n   n = le_bytes_to_num(msg[((i-1)*16)..(i*16)] | [0x01])\r\n   a += n\r\n   a = (r * a) % p\r\n   end\r\n",
    "correct_text": "for i=1 upto ceil(msg length in bytes / 16)\r\n   j = min(i*16-1, msg length in bytes - 1)\r\n   n = le_bytes_to_num(msg[((i-1)*16)..j] | [0x01])\r\n   a += n\r\n   a = (r * a) % p\r\n   end\r\n",
    "notes": "Correction of Errata 5675",
    "submit_date": "2019-04-11",
    "submitter_name": "Stefan Heiss",
    "verifier_id": 163,
    "verifier_name": "Colin Perkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5989,
    "doc-id": "RFC8439",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.4.1",
    "orig_text": "encrypted_message +=  block ^ key_stream\r\n...\r\nencrypted_message += (block^key_stream)[0..len(plaintext)%64]",
    "correct_text": "encrypted_message |= block ^ key_stream\r\n...\r\nencrypted_message |= (block^key_stream)[0..len(plaintext)%64]",
    "notes": "The encrypted_message is the result of concatenation of blocks.\r\n\"|\" and \"|=\" are used for concatenation elsewhere in the document, changing \"+=\" to \"|=\" will reduce ambiguity. ",
    "submit_date": "2020-02-26",
    "submitter_name": "Lê Minh Đăng",
    "verifier_id": 168,
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2021-04-28 06:48:23"
  },
  {
    "errata_id": 6025,
    "doc-id": "RFC8439",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 3,
    "orig_text": "A constant-time but not optimal approach would be to naively implement the arithmetic operations for 288-bit integers, because even a naive implementation will not exceed 2^288 in the multiplication of (acc+block) and r.\r\n",
    "correct_text": "It is possible to create a constant-time, but not optimal, implementation by implementing arithmetic operations for 256-bit integers, because even a naive implementation will not exceed 2^256 in the multiplication of (acc+block) and r (note that we have r < 2^124 because r is \"clamped\").\r\n",
    "notes": "There are two issues 1) 288 bits is too big, and 2) a naive implementation of 288 bit integer arithmetic isn't necessarily constant time.\r\n\r\n#1:  288 seems to be tied to the machine int size and assumes 32-bit integers (288 is nine 32-bit integers).  It is probably better to give a number independent of the machine int size. It is possible to compute Poly1305 using 255 bit arithmetic. Padded blocks of the message are in the range 2^8, 2^8 +1,..., 2^129 -1. Assuming that the partial reduction step always reduces the accumulator to 130 bits, we have acc < 2^130, so acc+block < 2^131. r is a 16 byte value, but some of its bits are \"clampled\", so we have r < 2^124. Thus (acc+block)*r < 2^255; so we can get by with 255 bit big-integer arithmetic (probably 256 bits is more convenient to work with). \r\n\r\n#2:  big-integer arithmetic can be implemented in constant time, but perhaps not in a obvious or naive way.  Keeping things constant time seems to depend on the characteristics of the underlying processor.",
    "submit_date": "2020-03-21",
    "submitter_name": "James Muir",
    "verifier_id": 168,
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2021-11-16 23:30:55"
  },
  {
    "errata_id": 6257,
    "doc-id": "RFC8439",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "2.5.2",
    "orig_text": "Adding s, we get this number, and serialize if to get the tag:",
    "correct_text": "Adding s, we get this number, and serialize it to get the tag:",
    "notes": "It's a trivial typo. Change \"if\" to \"it\".",
    "submit_date": "2020-08-18",
    "submitter_name": "Alan Presser",
    "verifier_id": 168,
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2021-04-13 05:22:08"
  },
  {
    "errata_id": 6569,
    "doc-id": "RFC8439",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 2.3,
    "orig_text": "o  A 32-bit block count parameter, treated as a 32-bit little-endian integer.",
    "correct_text": "o  A 32-bit block count parameter, treated as a 32-bit integer.",
    "notes": "The block count is not used as a little-endian integer. An example of this can be seen in the example test vector in section 2.3.2, where Block Count = 1, but the block count word of the initial state is 00000001.",
    "submit_date": "2021-05-03",
    "submitter_name": "David Reed",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
