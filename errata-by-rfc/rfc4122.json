[
  {
    "errata_id": 184,
    "doc-id": "RFC4122",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 4.3,
    "orig_text": "The UUIDs generated from the same name in two different namespaces\r\n       should be different with (very high probability).",
    "correct_text": "The UUIDs generated from the same name in two different namespaces\r\n       should be different (with very high probability).",
    "notes": "The brackets should be set similarly to the other points.",
    "submit_date": "2006-05-03",
    "submitter_name": "Tim Wilson-Brown",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1352,
    "doc-id": "RFC4122",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "99In Appendix B, it says:",
    "orig_text": "uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f",
    "correct_text": "uuid_create_md5_from_name(): 3d813cbb-47fb-32ba-91df-831e1593ac29",
    "notes": "The given value e902... etc. is based on a calculation swapping the eight octets 0..3, 4..5, 6..7 twice, for the name space UUID, and for the MD5 output, as foreseen for little endian input, but the example values were already big endian. I can reproduce the example and the proposed fix, see <http://omniplex.blogspot.com/2008/03/md5-16-pop3-and-uuid.html>.\r\n\r\nThe blog entry contains links to an identical older error report, and two (different) examples from third parties also agreeing with that theory.",
    "submit_date": "2008-03-08",
    "submitter_name": "Frank Ellermann",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1428,
    "doc-id": "RFC4122",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 3,
    "orig_text": "UUIDs, as defined in this document, can also be ordered lexicographically.\r\nFor a pair of UUIDs, the first one follows the second if the most significant\r\nfield in which the UUIDs differ is greater for the first UUID.  The second\r\nprecedes the first if the most significant field in which the UUIDs differ\r\nis greater for the second UUID.",
    "correct_text": "UUIDs, as defined in this document, can also be ordered lexicographically.\r\nFor a pair of UUIDs, the first one follows the second if the most significant\r\nfield in which the UUIDs differ is greater for the first UUID.  The second\r\nfollows the first if the most significant field in which the UUIDs differ\r\nis greater for the second UUID.",
    "notes": "The second and third sentences in the paragraph as originally written are\r\ninconsistent.  I have proposed one of the possible fixes.  There are others\r\nthat will make them consistent.",
    "submit_date": "2008-05-22",
    "submitter_name": "Russ Housley",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 1957,
    "doc-id": "RFC4122",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.1.3",
    "orig_text": "The version number is in the most significant 4 bits of the time\r\nstamp (bits 4 through 7 of the time_hi_and_version field).",
    "correct_text": "The version number is in the most significant 4 bits of the time\r\nstamp (bits 12 through 15 of the time_hi_and_version field).",
    "notes": "time_hi_and_version is defined as 16 bit field.\r\n\r\n--- VERIFIER NOTES ---\r\nThis change does make the text in Section 4.1.3 consistent with the sixth\r\nbullet in Section 4.2.2.  But the issue goes well beyond that: there is a real\r\nproblem with the bit numbering throughout the RFC.  Please see erratum\r\n3546 for more details.",
    "submit_date": "2009-12-03",
    "submitter_name": "Sergey Shandar",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3476,
    "doc-id": "RFC4122",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "Appendix A,B",
    "orig_text": "In Appendix A, the line:\r\n    uuid_create_md5_from_name(&u, NameSpace_DNS, \"www.widgets.com\", 15);\r\nIn Appendix B, the line:\r\n     uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f",
    "correct_text": "In Appendix A, the line:\r\n    uuid_create_md5_from_name(&u, NameSpace_DNS, \"www.example.com\", 15);\r\nIn Appendix B, the line:\r\n     uuid_create_md5_from_name(): 5df41881-3aed-3515-88a7-2f4a814cf09e",
    "notes": "Per RFC2606 section 5, it is best practice for standards and other documentation (including RFCs) to use the reserved example domains (e.g. example.com) rather than domains which could be in actual use. Indeed, the domain in question (www.widgets.com) is in actual use at the time of writing. So this proposed change uses \"www.example.com\" instead, and changes the example output accordingly. (Note that original output was wrong for the original input, as already noted in verified errata 1352.)",
    "submit_date": "2013-02-02",
    "submitter_name": "Simon Kissane",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3546,
    "doc-id": "RFC4122",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.1.3",
    "orig_text": "The version number is in the most significant 4 bits of the time\r\nstamp (bits 4 through 7 of the time_hi_and_version field).",
    "correct_text": "The version number is in the most significant 4 bits of the time\r\nstamp (bits 0 through 3 of the time_hi_and_version field).",
    "notes": "We use network order (as far as I know, we use network order in this RFC both for bits and bytes). So, the most significant bits comes first and they are located in first bytes. So, 0 through 3.\r\n\r\n---VERIFIER NOTES ---\r\nThis erratum is correct as far as it goes, but, given other text in the RFC, so is erratum 1957.  There is a pervasive problem in this RFC with inconsistent and unclear usage of bit numbering, which switches between several conventions.  The diagram in Section 4.1.2 uses left-to-right bit numbering (the most significant bit is numbered 0), but much of the text (such as in Section 4.2.2) uses right-to-left bit numbering (the least significant bit is numbered 0).  Most of the text uses big-ending byte order (network byte order), but some seems to assume little-ending, probably mistakes that come from the authors' familiarity with that convention.\r\n\r\nWith respect to the text in question, the first sentence of Section 4.1.3, we have the following situation:\r\n\r\n- The original text is correct if we assume right-to-left bit numbering and little-endian byte order.\r\n\r\n- Erratum 1957 is correct if we assume right-to-left bit numbering and big-endian byte order.  This change also makes the first sentence of Section 4.1.3 consistent with the sixth bullet in Section 4.2.2.\r\n\r\n- Erratum 3546 is correct if we assume left-to-right bit numbering and big-endian byte order.\r\n\r\nIn the end, the real point is that this document needs a revision that carefully and thoroughly fixes every instance of byte numbering (or removes the byte numbering and refers only to \"most significant\" and \"least significant\").  Such a revision should also double-check the sample code in Appendix A to be sure it works in both big-ending and little-endian machines.\r\n\r\nHappily, it's not likely that misunderstandings here will cause actual interoperability problems: this isn't a situation where things need to be disassembled and reassembled.  The algorithm merely turns a UUID into a URN, and the URN is thereafter a \"black box\", an unchanged identifier.  The only issue would be whether different interpretations of the document would turn two different UUIDs into the same URN, and, given the number of bits involved, the likelihood of collisions in practice is small.",
    "submit_date": "2013-03-14",
    "submitter_name": "Askar Safin",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3641,
    "doc-id": "RFC4122",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "GLOBAL",
    "orig_text": "Advice on generating cryptographic-quality random numbers can be\r\n   found in RFC1750 [5].",
    "correct_text": "Advice on generating cryptographic-quality random numbers can be\r\n   found in RFC4086 [5].",
    "notes": "(Above sample is from section 4.5).\r\nReferences to RFC 1750 should currently refer to RFC 4086.\r\n(Likewise in Appendix A.)\r\nThe note [5] actually references RFC4086, but this is the only\r\npoint that is updated, ie, the document is inconsistent in its references.\r\nThe references in Appendix A are not cross-referenced to note [5].\r\n\r\n------------------------ Verifier notes ------------------------\r\nThis is correct: reference [5] was updated to point to 4086, but the text in the\r\ndocument body was not changed accordingly.",
    "submit_date": "2013-06-06",
    "submitter_name": "Douglas Ray",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3970,
    "doc-id": "RFC4122",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.1.3",
    "orig_text": "The version number is in the most significant 4 bits of the time\r\nstamp (bits 4 through 7 of the time_hi_and_version field).",
    "correct_text": "The version number is in the most significant 4 bits of the\r\ntime_hi_and_version field...",
    "notes": "Errata 1957 and 3546 refer to the inconsistent bit numbering. That is a separate issue and has been left out of this correction. This report is in reference to the use of \"time stamp\" vs \"time_hi_and_version field\". The version number does not replace the most significant 4 bits of the time stamp. The 4-bit version number is in addition to the 60-bit time stamp.\n --VERIFIER NOTES-- \nThis seems to be a misunderstanding of the meaning here:\r\nThe time_hi_and_version field includes 4 bits for version, followed by the most significant 12 bits of the time stamp.  Therefore, the most significant four bits of the time stamp *are* bits 4 thru 7 of the time_hi_and_version field.\r\n\r\nThat said, this is all a confusing mess, and really could use a revision for clarity.",
    "submit_date": "2014-04-19",
    "submitter_name": "Jennifer Arsenault",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4975,
    "doc-id": "RFC4122",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 4.1,
    "orig_text": "The UUID format is 16 octets; some bits of the eight octet variant \r\nfield specified below determine finer structure.",
    "correct_text": "The UUID format is 16 octets; some bits of the variant \r\nfield specified below determine finer structure.",
    "notes": "The original wording implies the variant field is 8 octets long. It is between 1 and 3 bits long. An alternative correction would be:\r\n\r\n\"The UUID format is 16 octets; some bits of the variant \r\nfield in octet 8 specified below determine finer structure.\"",
    "submit_date": "2017-03-22",
    "submitter_name": "Joseph Boon",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4976,
    "doc-id": "RFC4122",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "Set the two most significant bits (bits 6 and 7) of the\r\nclock_seq_hi_and_reserved to zero and one, respectively.",
    "correct_text": "Set the two most significant bits (bits 7 and 6) of the\r\nclock_seq_hi_and_reserved to one and zero, respectively.",
    "notes": "The original wording appears in sections 4.2.2, 4.3, and 4.4. It can lead to confusion about which bit is most significant (6 or 7), and does not align neatly with the table of Variants in section 4.1.1 (which shows 1 followed by 0 for msb0 and msb1). The revised wording specifies the bits in msb order, which helps the reader more clearly correlate the bit values with section 4.1.1. It is noted that the revised wording would not match other parts of the document which give the lsb number first (e.g. \"bits 32 through 47\"), but this case is different because it is specifying fixed values for two bits, and the sentence starts with \"Set the two most significant bits\".",
    "submit_date": "2017-03-22",
    "submitter_name": "Joseph Boon",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5560,
    "doc-id": "RFC4122",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.1.1",
    "orig_text": "\r\n   The following table lists the contents of the variant field, where\r\n   the letter \"x\" indicates a \"don't-care\" value.\r\n\r\n   Msb0  Msb1  Msb2  Description\r\n\r\n    0     x     x    Reserved, NCS backward compatibility.\r\n\r\n    1     0     x    The variant specified in this document.",
    "correct_text": "\r\n   The following table lists the contents of the variant field, where\r\n   the letter \"x\" indicates a \"don't-care\" value.\r\n\r\n   Msb0  Msb1  Msb2  Description\r\n\r\n    0     x     x    Reserved, NCS backward compatibility.\r\n\r\n    1     0     0    The variant specified in this document.",
    "notes": "If Msb2 is a « don't-care » value, this means it's not wrong to set the bit to 0 or 1.\r\nIn the case of UUIDv3 and UUIDv5, this does not specify if the bit from the hash output should be left untouched or not.\r\nIt's not stated that it's illegal to reset it to 0 when setting Msb0 and Msb1 altogether (as libuuid does), since it's a « don't-care » value.\r\nBut letting it untouched whenever it's set to 1 by the hash output (as the Python stdlib does) causes two UUIDv{3,5} to be different for the same input namespaces and data. (Example: NS=Nil UUID, data = 0x44 («D»).\r\n\r\nThe RFC should enforce the value of the bit to 0 or 1, or clarify if it should be left untouched depending on the context-dependent data (Clock ID {1,2}, hash output {3,5}, random input {4}). (Which would mean it's then just a libuuid bug to forcibly set Msb2 to 0 when it should be untouched.)\r\n\r\nSee also : https://uuid.pirate-server.com/blog/brother-uuids-or-why-uuids-are-not-unique.html",
    "submit_date": "2018-11-25",
    "submitter_name": "GLOBAL UUID DATABASE",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 6225,
    "doc-id": "RFC4122",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 4.3,
    "orig_text": "ISO Object IDs (OIDs)",
    "correct_text": "Object Identifiers (OIDs)",
    "notes": "An Object Identifier (OID) is an identification mechanism jointly developed by ITU-T and ISO/IEC.\r\n\r\nIt makes no sense saying that it is an \"ISO OID\". Actually, it can be very confusing, because people could think that \"ISO OID\" means an OID which is a descendant of { iso(1) }, which would exclude OIDs descending from { itu-t(0) } and { joint-iso-itu-t(2) }.\r\n\r\nAlso in Appendix C, \"Name string is an ISO OID\" should be changed to \"Name string is an OID\".\r\n\r\nMaybe it would also be good to mention how the OID should be formatted. I guess the intention of the author is the normal dot-notation \"2.999\" which is passed as ASCII text to the name-based UUID generation function.",
    "submit_date": "2020-07-07",
    "submitter_name": "Daniel Marschall",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6665,
    "doc-id": "RFC4122",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "Appendix A",
    "orig_text": "static unsigned16 true_random(void);\r\n\r\n/* uuid_create -- generator a UUID */\r\nint uuid_create(uuid_t *uuid)\r\n{\r\n     uuid_time_t timestamp, last_time;",
    "correct_text": "static unsigned16 true_random(void);\r\n\r\n/* uuid_create -- generate a UUID */\r\nint uuid_create(uuid_t *uuid)\r\n{\r\n     uuid_time_t timestamp, last_time;",
    "notes": "The comment above the declaration of uuid_create() uses \"generate a UUID\", so the comment above the definition is likely intended to be identical.",
    "submit_date": "2021-08-25",
    "submitter_name": "Andrzej Koszela",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
