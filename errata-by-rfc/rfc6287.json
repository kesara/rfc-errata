[
  {
    "errata_id": "3729",
    "doc-id": "RFC6287",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "6.3",
    "orig_text": "   The input for timestamps is further qualified by G, size of the time-\r\n   step.  G can be specified in number of seconds, minutes, or hours:\r\n\r\n           +--------------------+------------------------------+\r\n           | Time-Step Size (G) |           Examples           |\r\n           +--------------------+------------------------------+\r\n           |       [1-59]S      | number of seconds, e.g., 20S |\r\n           |       [1-59]M      |  number of minutes, e.g., 5M |\r\n           |       [0-48]H      |  number of hours, e.g., 24H  |\r\n           +--------------------+------------------------------+\r\n\r\n                       Table 3: Time-step Size Table\r\n\r\n   Default value for G is 1M, i.e., time-step size is one minute and the\r\n   T represents the number of minutes since epoch time [UT].\r\n",
    "correct_text": "   The input for timestamps is further qualified by G, size of the time-\r\n   step.  G can be specified in number of seconds, minutes, or hours:\r\n\r\n           +--------------------+------------------------------+\r\n           | Time-Step Size (G) |           Examples           |\r\n           +--------------------+------------------------------+\r\n           |       [1-59]S      | number of seconds, e.g., 20S |\r\n           |       [1-59]M      |  number of minutes, e.g., 5M |\r\n           |       [1-48]H      |  number of hours, e.g., 24H  |\r\n           +--------------------+------------------------------+\r\n\r\n                       Table 3: Time-step Size Table\r\n\r\n   Default value for G is 1M, i.e., time-step size is one minute and the\r\n   T represents the number of minutes since epoch time [UT].\r\n",
    "notes": "I have changed \"[0-48]H\" to \"[1-48]H\".\r\n\r\nAccording to section 5.1, T is \"representing the number of time-steps (seconds, minutes, hours, or days depending on the specified granularity) since midnight UTC of January 1, 1970 [UT].\"\r\n\r\nHaving a granualarity of 0 is non-sense, and likely an editorial error.",
    "submit_date": "2013-09-17",
    "submitter_name": "Simon Josefsson",
    "verifier_id": "124",
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3730",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.2",
    "orig_text": "   This table summarizes all possible values for the CryptoFunction:\r\n\r\n     +---------------+--------------------+-------------------------+\r\n     |      Name     | HMAC Function Used |  Size of Truncation (t) |\r\n     +---------------+--------------------+-------------------------+\r\n     |  HOTP-SHA1-t  |      HMAC-SHA1     | 0 (no truncation), 4-10 |\r\n     | HOTP-SHA256-t |     HMAC-SHA256    | 0 (no truncation), 4-10 |\r\n     | HOTP-SHA512-t |     HMAC-SHA512    | 0 (no truncation), 4-10 |\r\n     +---------------+--------------------+-------------------------+\r\n",
    "correct_text": "   This table summarizes all possible values for the CryptoFunction:\r\n\r\n     +---------------+--------------------+-------------------------+\r\n     |      Name     | HMAC Function Used |  Size of Truncation (t) |\r\n     +---------------+--------------------+-------------------------+\r\n     |  HOTP-SHA1-t  |      HMAC-SHA1     | 0 (no truncation), 4-9  |\r\n     | HOTP-SHA256-t |     HMAC-SHA256    | 0 (no truncation), 4-9  |\r\n     | HOTP-SHA512-t |     HMAC-SHA512    | 0 (no truncation), 4-9  |\r\n     +---------------+--------------------+-------------------------+\r\n",
    "notes": "The change disallows 10 digit OCRA codes.  The reason for this is subtle and could be discussed.  An alternative to disallowing 10 digit codes is to add a Security Consideration discussion about the behaviour when 10 is used.\r\n\r\nThe Truncate function defined in RFC 4226 section 5.3 works on 31-bit numbers and uses modulo 10^Digit.  When Digit=10, that means 10^10.  However, 2^31 is smaller than 10^10.  This means that the output code can never take on values 2^31..10^10 which causes a significant bias in the number of valid codes.\r\n\r\nThe entire security analysis in RFC 4226 assumes this is not the case.  For example quoting section A.5 \"Security Analysis of HOTP\":  \"Suppose m = 10^Digit < 2^31,\".\r\n\r\nTo clarify, there is no attack enabled by this flaw. OCRA with 10 digit codes just doesn't offer as good security as it could.  10 digits is only roughly twice as secure as 9 digit codes instead of 10 times as one would expect.",
    "submit_date": "2013-09-17",
    "submitter_name": "Simon Josefsson",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3899",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Appendix A.",
    "orig_text": "// Put the bytes of \"time\" to the message\r\n// Input is text value of minutes\r\n    if(timeStampLength > 0){\r\n        bArray = hexStr2Bytes(timeStamp);\r\n        System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\r\n            counterLength + questionLength +\r\n            passwordLength + sessionInformationLength,\r\n            bArray.length);\r\n    }",
    "correct_text": "// Put the bytes of \"time\" to the message\r\n// Input is HEX encoded value of minutes\r\n    if(timeStampLength > 0){\r\n        bArray = hexStr2Bytes(timeStamp);\r\n        System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\r\n            counterLength + questionLength +\r\n            passwordLength + sessionInformationLength,\r\n            bArray.length);\r\n    }",
    "notes": "The timestamp should be HEX encoded since hexStr2Bytes() is used. Otherwise it will fail to generate the correct OTP",
    "submit_date": "2014-02-24",
    "submitter_name": "Marcus Bring",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3900",
    "doc-id": "RFC6287",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "Appendix A.",
    "orig_text": "* @param password     a password that can be used, HEX encoded\r\n.\r\n.\r\n.\r\n// Put the bytes of \"password\" to the message\r\n// Input is HEX encoded",
    "correct_text": "* @param password     a password that can be used, hashed with the \r\n* SHA-version declared in OCRA-suite and HEX encoded.\r\n.\r\n.\r\n.\r\n// Put the bytes of \"password\" to the message\r\n// Input is SHA hashed and HEX encoded",
    "notes": "The password should be hashed as stated in the RFC and as it is done in the testOCRA class. \r\n\r\nThis should also eliminate the need to padd the password with zeros since the hash is always of the correct length.\r\n\r\n// Password - sha1\r\nif(DataInput.toLowerCase().indexOf(\"psha1\") > 1){\r\n    passwordLength=20;\r\n}\r\n\r\n// Password - sha256\r\nif(DataInput.toLowerCase().indexOf(\"psha256\") > 1){\r\n    passwordLength=32;\r\n}\r\n\r\n// Password - sha512\r\nif(DataInput.toLowerCase().indexOf(\"psha512\") > 1){\r\n     passwordLength=64;\r\n}",
    "submit_date": "2014-02-24",
    "submitter_name": "Marcus Bring",
    "verifier_id": "128",
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4112",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "5",
    "orig_text": "OCRA = CryptoFunction(K, DataInput)",
    "correct_text": "R = CryptoFunction(K, DataInput)",
    "notes": "The acronym “OCRA” is used page 5 as the output of the CryptoFunction, page 9 as the name of a (family of) algorithm(s), in diagrams of pages 11, 13, 14 and 16 as a cryptographic function. This is inconsistent.",
    "submit_date": "2014-09-16",
    "submitter_name": "Marc Girault",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4113",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "7",
    "orig_text": "R = OCRA(K, {[C] | Q | [P | S | T]})\r\n\r\nRS = OCRA(K, [C] | QC | QS | [S | T])\r\n\r\nOCRA(K, [C] | QC | QS | [S | T]) != RS -> STOP\r\n\r\nRC = OCRA(K, [C] | QS | QC | [P | S | T])\r\n\r\nOCRA(K, [C] | QS | QC | [P|S|T]) != RC -> STOP\r\n\r\nSIGN = OCRA(K, [C] | QS | [P | T])\r\n\r\nRS = OCRA(K, [C] | QC | QS | [T]\r\n\r\nOCRA(K, [C] | QC | QS | [T]) != RS -> STOP \r\n\r\nSIGN = OCRA( K, [C] | QS | QC | [P | T])\r\n\r\nOCRA(K, [C] | QS | QC | [P|T]) != SIGN -> STOP ",
    "correct_text": "R = CryptoFunction(K, {[C] | Q | [P | S | T]})\r\n\r\nRS = CryptoFunction(K, [C] | QC | QS | [S | T])\r\n\r\nCryptoFunction(K, [C] | QC | QS | [S | T]) != RS -> STOP\r\n\r\nRC = CryptoFunction(K, [C] | QS | QC | [P | S | T])\r\n\r\nCryptoFunction(K, [C] | QS | QC | [P|S|T]) != RC -> STOP\r\n\r\nSIGN = CryptoFunction(K, [C] | QS | [P | T])\r\n\r\nRS = CryptoFunction(K, [C] | QC | QS | [T]\r\n\r\nCryptoFunction(K, [C] | QC | QS | [T]) != RS -> STOP \r\n\r\nSIGN = CryptoFunction( K, [C] | QS | QC | [P | T])\r\n\r\nCryptoFunction(K, [C] | QS | QC | [P|T]) != SIGN -> STOP ",
    "notes": "The acronym “OCRA” is used page 5 as the output of the CryptoFunction, page 9 as the name of a (family of) algorithm(s), in diagrams of pages 11, 13, 14 and 16 as a cryptographic function. This is inconsistent.",
    "submit_date": "2014-09-16",
    "submitter_name": "Marc Girault",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4114",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7",
    "orig_text": "R = OCRA(K, {[C] | Q | [P | S | T]})\r\n\r\nRS = OCRA(K, [C] | QC | QS | [S | T])\r\n\r\nOCRA(K, [C] | QC | QS | [S | T]) != RS \r\n\r\nRC = OCRA(K, [C] | QS | QC | [P | S | T])\r\n\r\nOCRA(K, [C] | QS | QC | [P|S|T]) != RC \r\n\r\nSIGN = OCRA(K, [C] | QS | [P | T])\r\n\r\nRS = OCRA(K, [C] | QC | QS | [T]\r\n\r\nOCRA(K, [C] | QC | QS | [T]) != RS\r\n\r\nSIGN = OCRA( K, [C] | QS | QC | [P | T])\r\n\r\nOCRA(K, [C] | QS | QC | [P|T]) != SIGN \r\n",
    "correct_text": "R = CryptoFunction(K, OCRASuite | 00 | [C] | Q | [P | S | T])\r\n\r\nRS = CryptoFunction(K, OCRASuite | 00 | [C] | QC | QS | [S | T])\r\n\r\nCryptoFunction(K, OCRASuite | 00 | [C] | QC | QS | [S | T]) != RS \r\n\r\nRC = CryptoFunction(K, OCRASuite | 00 | [C] | QS | QC | [P | S | T])\r\n\r\nCryptoFunction(K, OCRASuite | 00 | [C] | QS | QC | [P|S|T]) != RC\r\n\r\nSIGN = CryptoFunction(K, OCRASuite | 00 | [C] | QS | [P | T])\r\n\r\nRS = CryptoFunction(K, OCRASuite | 00 | [C] | QC | QS | [T]\r\n\r\nCryptoFunction(K, OCRASuite | 00 | [C] | QC | QS | [T]) != RS  \r\n\r\nSIGN = CryptoFunction( K, OCRASuite | 00 | [C] | QS | QC | [P | T])\r\n\r\nCryptoFunction(K, OCRASuite | 00 | [C] | QS | QC | [P|T]) != SIGN\r\n",
    "notes": "Page 5, DataInput is defined as the concatenation of OCRASuite, byte 00 and five parameters. Pages 11 and subsequent ones, it is defined as the concatenation of only those five parameters, omitting OCRASuite and byte 00. This is technically inconsistent.\r\n\r\nThe proposed new text anticipates positive verification of errata n°4113 and supersedes it.",
    "submit_date": "2014-09-16",
    "submitter_name": "Marc Girault",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4115",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "5",
    "orig_text": "DataInput = {OCRASuite | 00 | C | Q | P | S | T} where:\r\n\r\n   o  OCRASuite is a value representing the suite of operations to\r\n      compute an OCRA response",
    "correct_text": "DataInput = {OCRASuite | 00 | [C] | Q | [P | S | T]) where:\r\n\r\n   o  [] indicates a value is optional\r\n\r\n   o  OCRASuite is a value representing the suite of operations to\r\n      compute an OCRA response\r\n",
    "notes": "It is useful to know as early as possible which parameters are optional or not, especially as it is not exhaustively specified page 6.",
    "submit_date": "2014-09-16",
    "submitter_name": "Marc Girault",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4116",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "5",
    "orig_text": "5.1.  DataInput Parameters\r\n",
    "correct_text": "5.1.  DataInput ",
    "notes": "DataInput means two different things in (contents of) section 5.1 and (title of) section 6.3. This is inconsistent.",
    "submit_date": "2014-09-16",
    "submitter_name": "Marc Girault",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4117",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "6.3",
    "orig_text": "6.3.  DataInput\r\n",
    "correct_text": "6.3.  DataInput Parameters",
    "notes": "DataInput means two different things in (contents of) section 5.1 and (title of) section 6.3. This is inconsistent.",
    "submit_date": "2014-09-16",
    "submitter_name": "Marc Girault",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4401",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "6.4",
    "orig_text": "\"OCRA-1:HOTP-SHA1-4:QH8-S512\" means version 1 of OCRA with HMAC-\r\nSHA1 function, truncated to a 4-digit value, using a random\r\nhexadecimal challenge up to 8 nibbles and a session value of 512\r\nbytes",
    "correct_text": "\"OCRA-1:HOTP-SHA1-4:QH08-S512\" means version 1 of OCRA with HMAC-\r\nSHA1 function, truncated to a 4-digit value, using a random\r\nhexadecimal challenge up to 8 nibbles and a session value of 512\r\nbytes",
    "notes": "I have changed \"QH8\" to \"QH08\".",
    "submit_date": "2015-06-25",
    "submitter_name": "Anthony",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5133",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "6.3",
    "orig_text": "The input for S is further qualified by the length of the session\r\ndata in bytes.  The client and server could agree to any length but\r\nthe typical values are:",
    "correct_text": "The input for S is further qualified by the length of the session\r\ndata in bytes.  The client and server could agree to any length up to\r\n512 but the typical values are:",
    "notes": "Section 6.3 it is said the session data can be any length, as it is three digits this means it could be from 000 to 999. However in section 5.1 it is said session data cannot exceed 512 bytes so this should be reflected.",
    "submit_date": "2017-09-29",
    "submitter_name": "Mathieu Lechat",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5625",
    "doc-id": "RFC6287",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "// put selected bytes into result int\r\nint offset = hash[hash.length - 1] & 0xf;\r\n\r\nint binary =\r\n  ((hash[offset] & 0x7f) << 24) |\r\n  ((hash[offset + 1] & 0xff) << 16) |\r\n  ((hash[offset + 2] & 0xff) << 8) |\r\n  (hash[offset + 3] & 0xff);\r\n\r\nint otp = binary % DIGITS_POWER[codeDigits];\r\n\r\nresult = Integer.toString(otp);\r\nwhile (result.length() < codeDigits) {\r\n  result = \"0\" + result;\r\n}\r\nreturn result;\r\n",
    "correct_text": "if (codeDigits > 0) {\r\n  // put selected bytes into result int\r\n  int offset = hash[hash.length - 1] & 0xf;\r\n\r\n  int binary =\r\n      ((hash[offset] & 0x7f) << 24) |\r\n      ((hash[offset + 1] & 0xff) << 16) |\r\n      ((hash[offset + 2] & 0xff) << 8) |\r\n      (hash[offset + 3] & 0xff);\r\n\r\n  int otp = binary % DIGITS_POWER[codeDigits];\r\n\r\n  result = Integer.toString(otp);\r\n  while (result.length() < codeDigits) {\r\n      result = \"0\" + result;\r\n  }\r\n  return result;\r\n} else {\r\n  return asHex(hash);\r\n}\r\n",
    "notes": "The code does not honor what the RFC says in section 5.2:\r\n\r\n   3.  t=0 means that no truncation is performed and the full HMAC value\r\n       is used for authentication purposes\r\n\r\nand still applies dynamic truncation to suites requesting \"0\" digits.\r\nAs a result, the computation performs a \"modulo 1\" operation causing\r\nthe code to always return 0 for such suites.\r\n\r\nThe proposed patch explicitly disables dynamic truncation for such suites and returns the full HMAC\r\nencoded as a Base16 string. The \"asHex\" function is the same defined in Appendix B.",
    "submit_date": "2019-02-07",
    "submitter_name": "Emanuele Giacomelli",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  }
]
