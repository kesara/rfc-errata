[
  {
    "errata_id": 255,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "8.1.8.",
    "orig_text": "This sequence establishes the use of an lock_owner and associated \nsequence number.\n\nShould be \"a lock_owner\"",
    "correct_text": "If server replica or a server immigrating a filesystem agrees to\n\nShould be \"If a server replica\"",
    "notes": "\nIn Section 9.3.2.  Data Caching and File Locking, Last Paragraph:\n\n by flushing to the server more data upon an LOCKU than is covered by \nthe locked range.\n\nShould be \"a LOCKU\"\n\n",
    "submit_date": "2004-02-03",
    "submitter_name": "Jon Bauman",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2609,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "14.2.11.",
    "orig_text": "   SYNOPSIS\r\n\r\n     (cfh) locktype, offset, length owner -> {void, NFS4ERR_DENIED ->\r\n     owner}",
    "correct_text": "   SYNOPSIS\r\n\r\n     (cfh) locktype, offset, length, owner -> {void, NFS4ERR_DENIED ->\r\n     owner}",
    "notes": "Missing comma in the LOCKT synopsis.",
    "submit_date": "2010-11-05",
    "submitter_name": "Marcel Telka",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2610,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "14.2.16.",
    "orig_text": "   SYNOPSIS\r\n\r\n     (cfh), seqid, share_access, share_deny, owner, openhow, claim ->\r\n     (cfh), stateid, cinfo, rflags, open_confirm, attrset delegation",
    "correct_text": "   SYNOPSIS\r\n\r\n     (cfh), seqid, share_access, share_deny, owner, openhow, claim ->\r\n     (cfh), stateid, cinfo, rflags, attrset, delegation",
    "notes": "i)  The open_confirm should be removed (it is not a part of the OPEN4resok structure).\r\nii)  There is missing command between attrset and delegation.",
    "submit_date": "2010-11-05",
    "submitter_name": "Marcel Telka",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2613,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "14.2.16.",
    "orig_text": "   When an OPEN is done and the specified lockowner already has the\r\n   resulting filehandle open, the result is to \"OR\" together the new\r\n   share and deny status together with the existing status.  In this\r\n   case, only a single CLOSE need be done, even though multiple OPENs\r\n   were completed.  When such an OPEN is done, checking of share\r\n   reservations for the new OPEN proceeds normally, with no exception\r\n   for the existing OPEN held by the same lockowner.",
    "correct_text": "   When an OPEN is done and the specified owner already has the\r\n   resulting filehandle open, the result is to \"OR\" together the new\r\n   share and deny status together with the existing status.  In this\r\n   case, only a single CLOSE need be done, even though multiple OPENs\r\n   were completed.  When such an OPEN is done, checking of share\r\n   reservations for the new OPEN proceeds normally, with no exception\r\n   for the existing OPEN held by the same owner.",
    "notes": "The 'lockowner' should be replaced by 'owner' (twice in the paragraph). The lockowner is not related to the OPEN operation. Instead, the owner (open_owner) is related.",
    "submit_date": "2010-11-08",
    "submitter_name": "Marcel Telka",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2614,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "14.2.18.",
    "orig_text": "   This operation is used to confirm the sequence id usage for the first\r\n   time that a open_owner is used by a client.  The stateid returned\r\n   from the OPEN operation is used as the argument for this operation\r\n   along with the next sequence id for the open_owner.  The sequence id\r\n   passed to the OPEN_CONFIRM must be 1 (one) greater than the seqid\r\n   passed to the OPEN operation from which the open_confirm value was\r\n   obtained.  If the server receives an unexpected sequence id with\r\n   respect to the original open, then the server assumes that the client\r\n   will not confirm the original OPEN and all state associated with the\r\n   original OPEN is released by the server.",
    "correct_text": "   This operation is used to confirm the sequence id usage for the first\r\n   time that a open_owner is used by a client.  The stateid returned\r\n   from the OPEN operation is used as the argument for this operation\r\n   along with the next sequence id for the open_owner.  The sequence id\r\n   passed to the OPEN_CONFIRM must be 1 (one) greater than the seqid\r\n   passed to the previous OPEN operation.\r\n   If the server receives an unexpected sequence id with\r\n   respect to the original open, then the server assumes that the client\r\n   will not confirm the original OPEN and all state associated with the\r\n   original OPEN is released by the server.",
    "notes": "The OPEN operation does not return the open_confirm value.",
    "submit_date": "2010-11-08",
    "submitter_name": "Marcel Telka",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2637,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "14.2.18.",
    "orig_text": "                           Instead, to avoid unbounded memory use, the\r\n   server needs to implement a strategy for disposing of open_owner4s\r\n   that have no current lock, open, or delegation state for any files\r\n   and have not been used recently.",
    "correct_text": "                           Instead, to avoid unbounded memory use, the\r\n   server needs to implement a strategy for disposing of open_owner4s\r\n   that have no current open state for any files\r\n   and have not been used recently.",
    "notes": "A lock can be held on already opened files only. This means that every lock state can exist only in case the accompanied open state is already there.\r\n\r\nSo if there is a lock state held by server then there must be an open state for the file too. This means that we do not need to mention the \"current lock state\" in the RFC's sentence above.\r\n\r\nNext, the delegation state is allocated only in case the delegation is granted by server to a client for a file. The delegation state is related to file and client. It is not related/tied to openowner. This means that it is not possible to test whether an openowner have any delegation states. Delegation states are simply not related to the openowner.\r\n\r\nIt is easily possible to have a client with some delegation granted with no valid openowner held by a server.",
    "submit_date": "2010-11-19",
    "submitter_name": "Marcel Telka",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2638,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.2.3.",
    "orig_text": "   FH4_VOLATILE_ANY\r\n             The filehandle may expire at any time, except as\r\n             specifically excluded (i.e., FH4_NO_EXPIRE_WITH_OPEN).",
    "correct_text": "   FH4_VOLATILE_ANY\r\n             The filehandle may expire at any time, except as\r\n             specifically excluded (i.e., FH4_NOEXPIRE_WITH_OPEN).",
    "notes": "The FH4_NO_EXPIRE_WITH_OPEN should be replaced with FH4_NOEXPIRE_WITH_OPEN.",
    "submit_date": "2010-11-19",
    "submitter_name": "Marcel Telka",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2639,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.2.3.",
    "orig_text": "   FH4_VOL_MIGRATION\r\n             The filehandle will expire as a result of migration.  If\r\n             FH4_VOL_ANY is set, FH4_VOL_MIGRATION is redundant.\r\n\r\n   FH4_VOL_RENAME\r\n             The filehandle will expire during rename.  This includes a\r\n             rename by the requesting client or a rename by any other\r\n             client.  If FH4_VOL_ANY is set, FH4_VOL_RENAME is\r\n             redundant.\r\n\r\n.....\r\n\r\n   Note that the bits FH4_VOL_MIGRATION and FH4_VOL_RENAME allow the\r\n   client to determine that expiration has occurred whenever a specific\r\n   event occurs, without an explicit filehandle expiration error from\r\n   the server.  FH4_VOL_ANY does not provide this form of information.\r\n   In situations where the server will expire many, but not all\r\n   filehandles upon migration (e.g., all but those that are open),",
    "correct_text": "   FH4_VOL_MIGRATION\r\n             The filehandle will expire as a result of migration.  If\r\n             FH4_VOLATILE_ANY is set, FH4_VOL_MIGRATION is redundant.\r\n\r\n   FH4_VOL_RENAME\r\n             The filehandle will expire during rename.  This includes a\r\n             rename by the requesting client or a rename by any other\r\n             client.  If FH4_VOLATILE_ANY is set, FH4_VOL_RENAME is\r\n             redundant.\r\n\r\n.....\r\n\r\n   Note that the bits FH4_VOL_MIGRATION and FH4_VOL_RENAME allow the\r\n   client to determine that expiration has occurred whenever a specific\r\n   event occurs, without an explicit filehandle expiration error from\r\n   the server.  FH4_VOLATILE_ANY does not provide this form of information.\r\n   In situations where the server will expire many, but not all\r\n   filehandles upon migration (e.g., all but those that are open),",
    "notes": "The FH4_VOL_ANY should be replaced with FH4_VOLATILE_ANY (three times).",
    "submit_date": "2010-11-19",
    "submitter_name": "Marcel Telka",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2663,
    "doc-id": "RFC3530",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "8.11.",
    "orig_text": "   When an OPEN is done for a file and the lockowner for which the open\r\n   is being done already has the file open, the result is to upgrade the\r\n   open file status maintained on the server to include the access and\r\n   deny bits specified by the new OPEN as well as those for the existing\r\n   OPEN.  The result is that there is one open file, as far as the\r\n   protocol is concerned, and it includes the union of the access and\r\n   deny bits for all of the OPEN requests completed.  Only a single\r\n   CLOSE will be done to reset the effects of both OPENs.  Note that the\r\n   client, when issuing the OPEN, may not know that the same file is in\r\n   fact being opened.  The above only applies if both OPENs result in\r\n   the OPENed object being designated by the same filehandle.",
    "correct_text": "   When an OPEN is done for a file and the open_owner for which the open\r\n   is being done already has the file open, the result is to upgrade the\r\n   open file status maintained on the server to include the access and\r\n   deny bits specified by the new OPEN as well as those for the existing\r\n   OPEN.  The result is that there is one open file, as far as the\r\n   protocol is concerned, and it includes the union of the access and\r\n   deny bits for all of the OPEN requests completed.  Only a single\r\n   CLOSE will be done to reset the effects of both OPENs.  Note that the\r\n   client, when issuing the OPEN, may not know that the same file is in\r\n   fact being opened.  The above only applies if both OPENs result in\r\n   the OPENed object being designated by the same filehandle.",
    "notes": "The file opens are related to open_owners, not lockowners. The lockowner\r\nshould be replaced by open_owner in the first sentence of the paragraph above.",
    "submit_date": "2010-12-08",
    "submitter_name": "Marcel Telka",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3376,
    "doc-id": "RFC3530",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 9.6,
    "orig_text": "modified attributes may be returned to the server in the response\r\nto a CB_RECALL call.",
    "correct_text": "modified attributes may be returned to the server in the response\r\nto a CB_GETATTR call.",
    "notes": null,
    "submit_date": "2012-10-10",
    "submitter_name": "Kanda Motohiro",
    "verifier_id": 133,
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  }
]
