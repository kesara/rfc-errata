[
  {
    "errata_id": 2640,
    "doc-id": "RFC5802",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 5,
    "orig_text": "The server verifies the nonce and the proof, verifies that the\r\nauthorization identity (if supplied by the client in the first\r\nmessage) is authorized to act as the authentication identity, and,\r\nfinally, it responds with a \"server-final-message\", concluding the\r\nauthentication exchange.",
    "correct_text": "The server verifies the nonce and the proof, verifies that the\r\nauthentication identity is authorized to act as the authorization\r\nidentity (if supplied by the client in the first message) , and,\r\nfinally, it responds with a \"server-final-message\", concluding the\r\nauthentication exchange.",
    "notes": "It is the authentication identity which acts as (if authorized to) the authorization identity, not the opposite.",
    "submit_date": "2010-11-22",
    "submitter_name": "Jehan Pagès",
    "verifier_id": 112,
    "verifier_name": "Tim Polk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2651,
    "doc-id": "RFC5802",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 7,
    "orig_text": "   nonce           = \"r=\" c-nonce [s-nonce]\r\n                     ;; Second part provided by server.\r\n\r\n   c-nonce         = printable\r\n\r\n   s-nonce         = printable\r\n",
    "correct_text": "   nonce           = \"r=\" c-nonce [s-nonce]\r\n                     ;; Second part provided by server.\r\n\r\n   c-nonce         = 1*(printable)\r\n\r\n   s-nonce         = 1*(printable)\r\n",
    "notes": "\"printable\" is defined this way:\r\n   printable       = %x21-2B / %x2D-7E\r\n                     ;; Printable ASCII except \",\".\r\n                     ;; Note that any \"printable\" is also\r\n                     ;; a valid \"value\".\r\n\r\nHence a \"printable\" is a single printable character (except ','). But a nonce is a \"a sequence of random printable ASCII characters excluding ','\" (section 5.1), as can also be seen by the examples (and common sense for a security feature using randomness).",
    "submit_date": "2010-11-30",
    "submitter_name": "Jehan Pagès",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2652,
    "doc-id": "RFC5802",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 9,
    "orig_text": "",
    "correct_text": "Add the follow to the end of the 4th paragraph (starts with if an attacker):\r\n\r\n  Further, implementations are RECOMMENDED to reject salt values\r\n  shorter than 2 characters and MAY reject even longer salt values if\r\n  they are considered to be insufficient.  See [RFC4086] on generating\r\n  randomness.\r\n",
    "notes": "The original version (in Sec 7) would allow the empty string (hence the base64 encoding of an empty string). Though it may technically be an acceptable base64 encoded string, it is not acceptable in our use as we use it for security features which are not supposed to be empty (though it is not defined this way, but common sense tells).  This security consideration addresses this concern.",
    "submit_date": "2010-11-30",
    "submitter_name": "Jehan Pagès",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2689,
    "doc-id": "RFC5802",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 5.2,
    "orig_text": "2b) SCRAM sends additional data with success.",
    "correct_text": "2b) SCRAM sends additional data with success. If the server sends the additional data as a challenge, the response to this challenge is a empty response.",
    "notes": "The added information MUST be supplied according to RFC 4422, Section 5, Paragraph 2b.",
    "submit_date": "2011-01-21",
    "submitter_name": "Steffen Lehmann",
    "verifier_id": 112,
    "verifier_name": "Tim Polk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3472,
    "doc-id": "RFC5802",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 5,
    "orig_text": "C: n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL\r\nS: r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,s=QSXCR+Q6sek8bf92,\r\n   i=4096\r\nC: c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,\r\n   p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=\r\nS: v=rmF9pqV8S7suAoZWja4dJRkFsKQ=\r\n",
    "correct_text": "C: n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL\r\nS: r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,s=QSXCR+Q6sek8bf92,\r\n   i=4096\r\nC: c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,\r\n   p=frsVRm77a2tPQ5vy+zZuaKRR17o=\r\nS: v=01o5+Qz2QpK1yrmPi3ZwOZzQTzs=",
    "notes": "The test vector seems wrong, at least I cannot find code pattern that produces same result.  Here is the code I used to calculate it:\r\n\r\nhttps://gist.github.com/4654875",
    "submit_date": "2013-01-28",
    "submitter_name": "Marko Kreen",
    "verifier_id": 2,
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5271,
    "doc-id": "RFC5802",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.1, 7",
    "orig_text": "Section 5.1:\r\n\r\n   o  e: This attribute specifies an error that occurred during\r\n      authentication exchange.  It is sent by the server in its final\r\n      message and can help diagnose the reason for the authentication\r\n      exchange failure.  On failed authentication, the entire server-\r\n      final-message is OPTIONAL; specifically, a server implementation\r\n      MAY conclude the SASL exchange with a failure without sending the\r\n      server-final-message.  This results in an application-level error\r\n      response without an extra round-trip.  If the server-final-message\r\n      is sent on authentication failure, then the \"e\" attribute MUST be\r\n      included.\r\n\r\nSection 7:\r\n\r\n   server-first-message =\r\n                     [reserved-mext \",\"] nonce \",\" salt \",\"\r\n                     iteration-count [\",\" extensions]",
    "correct_text": "Section 5.1:\r\n\r\n   o  e: This attribute specifies an error that occurred during\r\n      authentication exchange.  It is sent by the server in its first\r\n      or final message and can help diagnose the reason for the\r\n      authentication exchange failure.  On failed authentication, the\r\n      entire server-first-message or server-final-message is OPTIONAL;\r\n      specifically, a server implementation MAY conclude the SASL\r\n      exchange with a failure without sending the a message.  This\r\n      results in an application-level error response without an extra\r\n      round-trip.  If a server message is sent on authentication\r\n      failure, then the \"e\" attribute MUST be included.\r\n\r\nSection 7:\r\n\r\n   server-first-message-bare =\r\n                     [reserved-mext \",\"] nonce \",\" salt \",\"\r\n                     iteration-count\r\n\r\n   server-first-message = (server-error / server-first-message-bare)\r\n                     [\",\" extensions]\r\n",
    "notes": "Many of the server-error message options in the formal syntax apply to fields received in the client-first message, e.g. \"invalid-username-encoding\" or \"extensions-not-supported\".  There is no existing provision in the formal syntax for a server to return a server-error in response to a client-first message.  The intent of the server-error field appears to include responses to the client-first message and there are no meaningful responses to such errors. E.g. what salt and iteration count should be returned in the case of invalid-username-encoding?  Therefore, this proposed errata allows server-error to be returned as the server-first-message and amends the explanatory text of section 5.1 accordingly.",
    "submit_date": "2018-03-02",
    "submitter_name": "David Golden",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5580,
    "doc-id": "RFC5802",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 7,
    "orig_text": "   server-error-value = \"invalid-encoding\" /\r\n                  \"extensions-not-supported\" /  ; unrecognized 'm' value\r\n                  \"invalid-proof\" /\r\n                  \"channel-bindings-dont-match\" /\r\n                  \"server-does-support-channel-binding\" /\r\n                    ; server does not support channel binding\r\n                  \"channel-binding-not-supported\" /\r\n                  \"unsupported-channel-binding-type\" /\r\n                  \"unknown-user\" /\r\n                  \"invalid-username-encoding\" /\r\n                    ; invalid username encoding (invalid UTF-8 or\r\n                    ; SASLprep failed)\r\n                  \"no-resources\" /\r\n                  \"other-error\" /\r\n                  server-error-value-ext\r\n           ; Unrecognized errors should be treated as \"other-error\".\r\n           ; In order to prevent information disclosure, the server\r\n           ; may substitute the real reason with \"other-error\".",
    "correct_text": "   server-error-value = \"invalid-encoding\" /\r\n                  \"extensions-not-supported\" /  ; unrecognized 'm' value\r\n                  \"invalid-proof\" /\r\n                  \"channel-bindings-dont-match\" /\r\n                  \"server-does-support-channel-binding\" /\r\n                    ; the client thinks the server does not support \r\n                    ; channel binding, but the server does\r\n                  \"channel-binding-not-supported\" /\r\n                  \"unsupported-channel-binding-type\" /\r\n                  \"unknown-user\" /\r\n                  \"invalid-username-encoding\" /\r\n                    ; invalid username encoding (invalid UTF-8 or\r\n                    ; SASLprep failed)\r\n                  \"no-resources\" /\r\n                  \"other-error\" /\r\n                  server-error-value-ext\r\n           ; Unrecognized errors should be treated as \"other-error\".\r\n           ; In order to prevent information disclosure, the server\r\n           ; may substitute the real reason with \"other-error\".",
    "notes": "See Section 6, \"If the flag is set to \"y\" and the server supports channel binding, the server MUST fail authentication. \"\r\nI assume the server-error-value \"server-does-support-channel-binding\" is designed for such situation.",
    "submit_date": "2018-12-19",
    "submitter_name": "Wang Xin",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5882,
    "doc-id": "RFC5802",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 2.2,
    "orig_text": "Hi(str, salt, i):\r\n\r\n     U1   := HMAC(str, salt + INT(1))\r\n     U2   := HMAC(str, U1)\r\n     ...\r\n     Ui-1 := HMAC(str, Ui-2)\r\n     Ui   := HMAC(str, Ui-1)\r\n\r\n     Hi := U1 XOR U2 XOR ... XOR Ui\r\n",
    "correct_text": "Hi(str, salt, i):\r\n\r\n     U1   := HMAC(str, salt + INT(i))\r\n     U2   := HMAC(str, U1)\r\n     ...\r\n     Ui-1 := HMAC(str, Ui-2)\r\n     Ui   := HMAC(str, Ui-1)\r\n\r\n     Hi := U1 XOR U2 XOR ... XOR Ui\r\n",
    "notes": "The first round of PBKDF2 is defined incorrectly with a hard-coded value \"INT(1)\" rather than \"INT(i)\" (the iteration count). See RFC 2898 section 5.2 step 3. This error means that the computation of PBKDF2 with n iterations is a prefix of the computation required for PBKDF2 with m iterations (with m > n), which is otherwise not the case (and may have security implications?).\n --VERIFIER NOTES-- \n   Rejected per submitter request.  The 1 here indicates it is the first block of the output stream being computed, and only one such block is needed.",
    "submit_date": "2019-10-25",
    "submitter_name": "Neil Madden",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-10-25 16:05:01"
  }
]
