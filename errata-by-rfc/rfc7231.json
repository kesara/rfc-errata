[
  {
    "errata_id": 4031,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.1.1.1",
    "orig_text": "media-type = type \"/\" subtype *( OWS \";\" OWS parameter )",
    "correct_text": "media-type = type \"/\" subtype *( OWS \";\" OWS [parameter] )",
    "notes": "See the thread at http://lists.w3.org/Archives/Public/ietf-http-wg/2011JulSep/0027.html\r\n\r\nImplementations are much more relaxed when it comes to parsing MIME types.\r\n\r\nThe above is probably still too strict. E.g. requiring that a parameter contains \"=\" is something I doubt is actually the case in practice.\n --VERIFIER NOTES-- \nThe ABNF is there to specify what the expected productions are, and is correct as it stands: we do not *want* things such as these to be produced:\r\n\r\n   Content-Type: text/plain;\r\n   Content-Type: text/plain; charset=iso8859-1;\r\n   Content-Type: text/plain;;;;;;;;;;;; ;;; ;;; ;;;\r\n\r\nThat said, this report addresses a real problem: lack of direction to parsers on how to be appropriately lenient.  Because the fact is that general interoperability of this stuff in the wild would be improved if parsers accepted at least the first two of the examples above, which are illegal by the grammar, but which do get generated by less-than-perfect implementations.\r\n\r\nI'm marking this report as \"Rejected\" because the problem it means to address is much broader than this one case, and can't be fixed with an errata report.  But it's important that we take up work on a document that does properly address this issue.",
    "submit_date": "2014-06-30",
    "submitter_name": "Anne van Kesteren",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4072,
    "doc-id": "RFC7231",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "TOC",
    "orig_text": "ed ",
    "correct_text": null,
    "notes": "Three extraneous characters \"ed \" appear before the table of contents entry for 7.1.1.",
    "submit_date": "2014-08-06",
    "submitter_name": "Martin Thomson",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4180,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 6.4,
    "orig_text": "n/a",
    "correct_text": "n/a",
    "notes": "The section on status code 304 is missing even though that status code is mentioned in other parts of the document. RFC2616 described the status code as follows (in section 10.3.5):\r\n\r\n\r\n> 10.3.5 304 Not Modified\r\n>\r\n>    If the client has performed a conditional GET request and access is\r\n>    allowed, but the document has not been modified, the server SHOULD\r\n>    respond with this status code. The 304 response MUST NOT contain a\r\n>    message-body, and thus is always terminated by the first empty line\r\n>    after the header fields.\r\n>\r\n>    The response MUST include the following header fields:\r\n>\r\n>       - Date, unless its omission is required by section 14.18.1\r\n\r\n\r\nThis section would go right after \"6.4.4.  303 See Other\".\n --VERIFIER NOTES-- \nStatus code 304 relates to conditional requests, and is therefore documented in RFC 7232 (Section 4.1).  This fact is shown in the table in RFC 7231, Section 6.1, and in the IANA registry \"HTTP Status Codes\" <http://www.iana.org/assignments/http-status-codes>.",
    "submit_date": "2014-11-14",
    "submitter_name": "Michel Albert",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4224,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "4.1 and A. D",
    "orig_text": "     method = token\r\n",
    "correct_text": "     method = <method, see [RFC7230], Section 3.1.1>\r\n",
    "notes": "The HTTP/1.1 RFCs define rules imported across documents using prose rules for all rules except this one. This is an error because RFC7231 does not mean to re-define the production rule.\n --VERIFIER NOTES-- \nThis is asking for an editorial change, but the errata system is not the place to record proposals for editorial improvements.  There is an issue tracker at <https://github.com/httpwg/http11bis/issues> for keeping issues for a possible future HTTP 1.1 update.",
    "submit_date": "2015-01-09",
    "submitter_name": "Bjoern Hoehrmann",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4225,
    "doc-id": "RFC7231",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "A. C & A. D",
    "orig_text": "     field-name    = <comment, see [RFC7230], Section 3.2>\r\n",
    "correct_text": "     field-name    = <field-name, see [RFC7230], Section 3.2>\r\n",
    "notes": "field-name does not follow the `comment` production. The section number is correct.",
    "submit_date": "2015-01-09",
    "submitter_name": "Bjoern Hoehrmann",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4232,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "7.1.1.1",
    "orig_text": "GMT",
    "correct_text": 0,
    "notes": "The text refers to RFC 5322. There Sect 3.3 calls the use timezone abbreviations, like GMT, obsolete. It encourages using a numeric offset such as +0000.\r\n\r\nThe grammar for dates in 7231 Sect 7.1.1.1 uses GMT. Example dates throughout this RFC and others related to HTTP use GMT. This is inconsistent with 5322.\r\n\r\nThe RFCs for HTTP need to be modified to match 5322, or 7.1.1.1 needs a note that HTTP deliberately deviates from 5322 with regards to the timezone.\n --VERIFIER NOTES-- \nThe document is quite clear that the \"GMT\" version is preferred, and is necessary for compatibility with earlier versions and implementations.",
    "submit_date": "2015-01-14",
    "submitter_name": "Christopher Olson",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4351,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.3.6",
    "orig_text": "   A server MUST NOT send any Transfer-Encoding or Content-Length header\r\n   fields in a 2xx (Successful) response to CONNECT.  A client MUST\r\n   ignore any Content-Length or Transfer-Encoding header fields received\r\n   in a successful response to CONNECT.\r\n\r\n   A payload within a CONNECT request message has no defined semantics;\r\n   sending a payload body on a CONNECT request might cause some existing\r\n   implementations to reject the request.",
    "correct_text": "   Historically no semantics have been defined for request and 2xx\r\n   (Successful) response bodies for CONNECT, but nonetheless some\r\n   clients and some servers do use request and 2xx response bodies.\r\n\r\n   Servers MUST NOT send a response body in a 2xx (Successful)\r\n   response to CONNECT.  Because some proxies send an initial flight\r\n   of tunneled application data in 2xx response bodies, clients MUST\r\n   accept response bodies in 2xx responses to CONNECT, and MUST\r\n   treat the response body as the initial flight of application data.\r\n\r\n   Servers that receive a CONNECT request body SHOULD treat it as the\r\n   initial flight of tunneled application data.",
    "notes": "Implementing the original text (\"A client MUST ignore...\") has the effect\r\nthat the client will leave in the lower layer's buffer any 2xx CONNECT\r\nresponse body, and when the Transfer-Encoding is the identity, then this\r\nwill have the effect that the 2xx response body is seamlessly prepended\r\nto the tunneled application data in the server-to-client direction.\r\nIt seems almost like this was the intent of the original text, but if so,\r\nthen it would be much better to state this than to describe one possible\r\nimplementation approach.\r\n\r\nAlso, it seems rather unlikely that ignoring the Transfer-Encoding for any\r\nTE other than the identity.  If the proxy really did use a compression\r\nor chunked transfer encoding, then ignoring this on the client side\r\n(and prepending the encoded 2xx response body to the server-to-client\r\ntunneled application data) would quite clearly be wrong.\r\n\r\nIt also seems that some clients send the first flight of tunneled\r\napplication data in a CONNECT request body.  While historically the\r\nsemantics of CONNECT request and 2xx response bodies have not been\r\ndefined, it is worth pointing out that [it appears, so I'm told; see\r\nbelow] some clients and some proxies rely on CONNECT request and 2xx\r\nresponse bodies bearing the first flight of tunneled application data,\r\nand if so, then the RFC should mention it.  I'm not sure how much\r\nevidence we can demand for such behaviors, but the RFC demands behavior\r\nthat implies the intent described in this erratum and gives no evidence\r\nto support the need for such behavior, therefore it seems much better\r\nto describe the previously-implied intent explicitly and continue with\r\na little-or-no-evidence approach that should nonetheless yield the most\r\ninteroperability.\r\n\r\nFinally, I asked for clarification on the HTTPbis list, and the answers\r\nI received indicate that the intent may have been as described in\r\nthese notes.\r\n\r\nSee https://lists.w3.org/Archives/Public/ietf-http-wg/2015AprJun/0260.html\r\nand follow-ups.\n --VERIFIER NOTES-- \nThis is a change request, not an errata report.  Such changes can be proposed in the working group's issue tracker, here:\r\nhttps://github.com/httpwg/http11bis/issues",
    "submit_date": "2015-04-29",
    "submitter_name": "Nicolas Williams",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4436,
    "doc-id": "RFC7231",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "4.3.5",
    "orig_text": "If a DELETE method is successfully applied, the origin server SHOULD\r\nsend a 202 (Accepted) status code if the action will likely succeed\r\nbut has not yet been enacted, a 204 (No Content) status code if the\r\naction has been enacted and no further information is to be supplied,\r\nor a 200 (OK) status code if the action has been enacted and the\r\nresponse message includes a representation describing the status.",
    "correct_text": "If a DELETE method is successfully applied, the origin server SHOULD\r\nsend a 202 (Accepted) status code if the action will likely succeed\r\nbut has not yet been enacted; a 204 (No Content) status code if the\r\naction has been enacted and no further information is to be supplied;\r\nor a 200 (OK) status code if the action has been enacted and the\r\nresponse message includes a representation describing the status.",
    "notes": "Using a semicolon creates a stronger delineation of the different options. If you are just quickly trying to parse what status to return if the delete hasn't happened yet and you quickly read \"has not yet been enacted, a 204 (No Content)\" you could incorrectly read that as return a 204. The semicolon makes it more obvious that \"enacted\" is the end of that thought and to scan backwards where as the comma in this instance requires knowing the structure of the rest of the paragraph.\r\n\r\n----- Verifier Notes -----\r\nThere's no reason to use semicolons to delimit this list, because the list items themselves don't contain commas.  Still, the reporter's confusion is noted.  Perhaps a bullet list would be better in this case:\r\n\r\n-------\r\nIf a DELETE method is successfully applied, the origin server SHOULD\r\nsend\r\n\r\n  - a 202 (Accepted) status code if the action will likely succeed\r\n    but has not yet been enacted,\r\n\r\n  - a 204 (No Content) status code if the action has been enacted and\r\n    no further information is to be supplied, or\r\n\r\n  - a 200 (OK) status code if the action has been enacted and the\r\n    response message includes a representation describing the status.\r\n-------",
    "submit_date": "2015-08-06",
    "submitter_name": "Aron Duby",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4452,
    "doc-id": "RFC7231",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 6.4,
    "orig_text": "Automatic redirection needs to done with\r\n   care for methods not known to be safe, as defined in Section 4.2.1,\r\n   since the user might not wish to redirect an unsafe request.",
    "correct_text": "Automatic redirection needs to be done with\r\n   care for methods not known to be safe, as defined in Section 4.2.1,\r\n   since the user might not wish to redirect an unsafe request.",
    "notes": "A simple typo (\"needs to _be_ done\")",
    "submit_date": "2015-08-22",
    "submitter_name": "Attila Gulyas",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4689,
    "doc-id": "RFC7231",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "3.1.1.2",
    "orig_text": "3.1.1.2.  Charset\r\n\r\n   HTTP uses charset names to indicate or negotiate the character\r\n   encoding scheme of a textual representation [RFC6365].  A charset is\r\n   identified by a case-insensitive token.\r\n\r\n     charset = token\r\n\r\n   Charset names ought to be registered in the IANA \"Character Sets\"\r\n   registry (<http://www.iana.org/assignments/character-sets>) according\r\n   to the procedures defined in [RFC2978].",
    "correct_text": "3.1.1.2.  Charset\r\n\r\n   HTTP uses charset names to indicate or negotiate the character\r\n   encoding scheme of a textual representation [RFC6365].\r\n\r\n\r\n     charset       = <mime-charset, see [RFC5987], Section 3.2.1>\r\n\r\n\r\n   Charset names ought to be registered in the IANA \"Character Sets\"\r\n   registry (<http://www.iana.org/assignments/character-sets>) according\r\n   to the procedures defined in [RFC2978].",
    "notes": "The definition of charset from RFC 5987 is more strict and more correct.\r\n\r\nMark Nottingham: This is not an errata; it is a suggestion for a technical change in the document, and needs to be discussed by the working group.",
    "submit_date": "2016-05-10",
    "submitter_name": "Daurnimator",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4734,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.3.5",
    "orig_text": "   The \"Accept-Language\" header field can be used by user agents to\r\n   indicate the set of natural languages that are preferred in the\r\n   response.  Language tags are defined in Section 3.1.3.1.\r\n\r\n     Accept-Language = 1#( language-range [ weight ] )\r\n     language-range  =\r\n               <language-range, see [RFC4647], Section 2.1>\r\n\r\n   Each language-range can be given an associated quality value\r\n   representing an estimate of the user's preference for the languages\r\n   specified by that range, as defined in Section 5.3.1.  For example,\r\n\r\n     Accept-Language: da, en-gb;q=0.8, en;q=0.7\r\n\r\n   would mean: \"I prefer Danish, but will accept British English and\r\n   other types of English\".",
    "correct_text": "   The \"Accept-Language\" header field can be used by user agents to\r\n   indicate the set of natural languages that are preferred in the\r\n   response.  Language tags are defined in Section 3.1.3.1.\r\n\r\n     Accept-Language = 1#( language-range [ weight ] )\r\n     language-range  =\r\n               <language-range, see [RFC5646], Section 2.1>\r\n\r\n   Each language-range can be given an associated quality value\r\n   representing an estimate of the user's preference for the languages\r\n   specified by that range, as defined in Section 5.3.1.  For example,\r\n\r\n     Accept-Language: da, en-GB;q=0.8, en;q=0.7\r\n\r\n   would mean: \"I prefer Danish, but will accept British English and\r\n   other types of English\".",
    "notes": "RFC4647 -> RFC5646\r\nen-gb      -> en-GB\r\n\r\n\n --VERIFIER NOTES-- \nRejected per Mark Nottingham (chair of HTTPBIS WG):\r\nAs far as I can tell, language-range is defined in RFC 4647, not in RFC 5646. So the change as proposed seems to be incorrect. (See BCP 47.)\r\n\r\nThe other change, from 'en-gb' to 'en-GB', may be seen as a tiny stylistic improvement (because the 'canonical' way to write country codes in language tags is upper case), but is not at all required (because language tags are case-insensitive).",
    "submit_date": "2016-07-06",
    "submitter_name": "Alexey Blyshko",
    "verifier_id": 2,
    "verifier_name": "RFC Editor",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5300,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 8.1,
    "orig_text": "8.1.1.  Procedure\r\n\r\n   HTTP method registrations MUST include the following fields:\r\n\r\n   o  Method Name (see Section 4)\r\n\r\n   o  Safe (\"yes\" or \"no\", see Section 4.2.1)\r\n\r\n   o  Idempotent (\"yes\" or \"no\", see Section 4.2.2)\r\n\r\n   o  Pointer to specification text\r\n\r\n   Values to be added to this namespace require IETF Review (see\r\n   [RFC5226], Section 4.1).\r\n\r\n…\r\n\r\n8.1.3.  Registrations\r\n\r\n   The \"Hypertext Transfer Protocol (HTTP) Method Registry\" has been\r\n   populated with the registrations below:\r\n\r\n   +---------+------+------------+---------------+\r\n   | Method  | Safe | Idempotent | Reference     |\r\n   +---------+------+------------+---------------+\r\n   | CONNECT | no   | no         | Section 4.3.6 |\r\n   | DELETE  | no   | yes        | Section 4.3.5 |\r\n   | GET     | yes  | yes        | Section 4.3.1 |\r\n   | HEAD    | yes  | yes        | Section 4.3.2 |\r\n   | OPTIONS | yes  | yes        | Section 4.3.7 |\r\n   | POST    | no   | no         | Section 4.3.3 |\r\n   | PUT     | no   | yes        | Section 4.3.4 |\r\n   | TRACE   | yes  | yes        | Section 4.3.8 |\r\n   +---------+------+------------+---------------+",
    "correct_text": "8.1.1.  Procedure\r\n\r\n   HTTP method registrations MUST include the following fields:\r\n\r\n   o  Method Name (see Section 4)\r\n\r\n   o  Safe (\"yes\" or \"no\", see Section 4.2.1)\r\n\r\n   o  Idempotent (\"yes\" or \"no\", see Section 4.2.2)\r\n\r\n   o  Cacheable (\"yes\" or \"no\", see Section 4.2.3)\r\n\r\n   o  Pointer to specification text\r\n\r\n   Values to be added to this namespace require IETF Review (see\r\n   [RFC5226], Section 4.1).\r\n\r\n…\r\n\r\n8.1.3.  Registrations\r\n\r\n   The \"Hypertext Transfer Protocol (HTTP) Method Registry\" has been\r\n   populated with the registrations below:\r\n\r\n   +---------+------+------------+-----------+---------------+\r\n   | Method  | Safe | Idempotent | Cacheable | Reference     |\r\n   +---------+------+------------+-----------+---------------+\r\n   | CONNECT | no   | no         | no        | Section 4.3.6 |\r\n   | DELETE  | no   | yes        | no        | Section 4.3.5 |\r\n   | GET     | yes  | yes        | yes       | Section 4.3.1 |\r\n   | HEAD    | yes  | yes        | yes       | Section 4.3.2 |\r\n   | OPTIONS | yes  | yes        | no        | Section 4.3.7 |\r\n   | POST    | no   | no         | yes       | Section 4.3.3 |\r\n   | PUT     | no   | yes        | no        | Section 4.3.4 |\r\n   | TRACE   | yes  | yes        | no        | Section 4.3.8 |\r\n   +---------+------+------------+-----------+---------------+",
    "notes": "HTTP Methods have 3 boolean properties, all of which 8.1.2 says a registration needs to define, but only 2 of them were included in the registry.\n --VERIFIER NOTES-- \nAs discussed during work on the HTTP core documents:\r\n> \"Cacheable\" is not a boolean property of the method, but rather a capability inherent in the system in which one aspect is the method semantics.\r\nSee https://github.com/httpwg/http-core/issues/54 for detailed discussion.",
    "submit_date": "2018-03-24",
    "submitter_name": "Jeffrey Yasskin",
    "verifier_id": 170,
    "verifier_name": "Francesca Palombini",
    "update_date": "2021-08-23 04:35:50"
  },
  {
    "errata_id": 5448,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "7.1.1.1",
    "orig_text": "Recipients of a timestamp value in rfc850-date format, which uses a\r\ntwo-digit year, MUST interpret a timestamp that appears to be more\r\nthan 50 years in the future as representing the most recent year in\r\nthe past that had the same last two digits.",
    "correct_text": "Recipients of a timestamp value in rfc850-date format, which uses a\r\ntwo-digit year, MUST interpret a timestamp that appears to be more\r\nthan 200 years in the future as representing the most recent date in\r\nthe past that also matches the timestamp.",
    "notes": "The combination of day-of-the-week, day-of-the-month, month, and the two last digits of the year repeats every 400 years. For example, \"Friday, 01-Jan-00 00:00:00 GMT\" (as formatted by rfc850) happens in the years ...1300, 1700, 2100, 2500, 2900...\r\n\r\nWith the original text, \"Friday, 01-Jan-00 00:00:00 GMT\" is interpreted as year 2000, since year 2100 is more than 50 years in the future, and year 2000 is the most recent year in the past with the same last two digits as 2100. However, if it really was year 2000, it should have said \"Saturday, 01-Jan-00 00:00:00 GMT\". So it would make more sense to interpret it as either year 1700 or year 2100. The corrected text interprets it as year 2100.\r\n\r\n\"Monday, 01-Jan-00 00:00:00 GMT\" happens in years ...1100, 1500, 1900, 2300, 2700..., and is interpreted as year 1900, since 2300 is more than 200 years in the future.\n --VERIFIER NOTES-- \n  This changes the original intent of the text, so errata mechanism is not suitable.",
    "submit_date": "2018-08-02",
    "submitter_name": "Magnar Ovedal Myrtveit",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5541,
    "doc-id": "RFC7231",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.3.5",
    "orig_text": "If a DELETE\r\n   request passes through a cache that has one or more stored responses\r\n   for the effective request URI, those stored responses will be\r\n   invalidated",
    "correct_text": "If a successful DELETE\r\n   request passes through a cache that has one or more stored responses\r\n   for the effective request URI, those stored responses will be\r\n   invalidated",
    "notes": "RFC 7234 4.4 describes the semantics of cache invalidation for successful requests (non-error status code), but does not describe semantics for unsuccessful requests.  The corrected text parallels the construction in section 4.3.4 (\"If a successful PUT request...\").\r\n\r\nMark Nottingham wrote:\r\n\r\nI think HOLD FOR UPDATE; we can address this in the current http-core work. ",
    "submit_date": "2018-11-02",
    "submitter_name": "Danil Suits",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5806,
    "doc-id": "RFC7231",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.3.7",
    "orig_text": "A server MUST generate a Content-Length field with a value of \"0\" if no\r\npayload body is to be sent in the response.",
    "correct_text": "If no payload body is to be sent in the response, a server MUST\r\ngenerate a status code of 204 (No Content) or a Content-Length field\r\nwith a value of \"0\" (but not both).",
    "notes": "The original text contradicts RFC 7230 §3.3.2: “A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content)”, unless the intention was to disallow all 204 responses to OPTIONS requests, which I assume it was not.",
    "submit_date": "2019-08-12",
    "submitter_name": "Anders Kaseorg",
    "verifier_id": 170,
    "verifier_name": "Francesca Palombini",
    "update_date": "2021-08-23 04:40:26"
  },
  {
    "errata_id": 6019,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "3.1.1.1",
    "orig_text": " A parameter value that matches the token production can be\r\n   transmitted either as a token or within a quoted-string.  The quoted\r\n   and unquoted values are equivalent.  For example, the following\r\n   examples are all equivalent, but the first is preferred for\r\n   consistency:\r\n\r\n     text/html;charset=utf-8\r\n     text/html;charset=UTF-8\r\n     Text/HTML;Charset=\"utf-8\"\r\n     text/html; charset=\"utf-8\"\r\n",
    "correct_text": " A parameter value that matches the token production can be\r\n   transmitted either as a token or within a quoted-string.  The quoted\r\n   and unquoted values are equivalent.  For example, the following\r\n   examples are all equivalent, but the first is preferred for\r\n   consistency:\r\n\r\n     text/html;charset=utf-8\r\n     text/html;charset=UTF-8\r\n",
    "notes": "Section 3.1.1.2 defines charset value to be a token. I consider this to be a bad example which might cause confusion. Why should I quote the value if it is defined as token?! You make want to use some other example.\n --VERIFIER NOTES-- \n   What's relevant is the ABNF for *parameter*, and that allows both token and quoted-string.  So the example is correct.",
    "submit_date": "2020-03-16",
    "submitter_name": "Michael Osipov",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-07-10 05:48:51"
  },
  {
    "errata_id": 6149,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.3.2",
    "orig_text": "The media type quality factor associated with a given type is\r\ndetermined by finding the media range with the highest precedence\r\nthat matches the type.  For example,\r\n\r\n  Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,\r\n          text/html;level=2;q=0.4, */*;q=0.5\r\n\r\nwould cause the following values to be associated:\r\n\r\n+-------------------+---------------+\r\n| Media Type        | Quality Value |\r\n+-------------------+---------------+\r\n| text/html;level=1 | 1             |\r\n| text/html         | 0.7           |\r\n| text/plain        | 0.3           |\r\n| image/jpeg        | 0.5           |\r\n| text/html;level=2 | 0.4           |\r\n| text/html;level=3 | 0.7           |\r\n+-------------------+---------------+",
    "correct_text": "The media type quality factor associated with a given type is\r\ndetermined by finding the media range with the highest precedence\r\nthat matches the type.  For example,\r\n\r\n  Accept: text/*;q=0.3, text/plain;q=0.7, text/plain;format=flowed,\r\n          text/plain;format=fixed;q=0.4, */*;q=0.5\r\n\r\nwould cause the following values to be associated:\r\n\r\n+--------------------------+---------------+\r\n| Media Type               | Quality Value |\r\n+--------------------------+---------------+\r\n| text/plain;format=flowed | 1             |\r\n| text/plain               | 0.7           |\r\n| text/html                | 0.3           |\r\n| image/jpeg               | 0.5           |\r\n| text/plain;format=fixed  | 0.4           |\r\n| text/plain;delsp=yes     | 0.7           |\r\n+--------------------------+---------------+",
    "notes": "The optional \"level\" parameter of media type text/html was removed by informational RFC 2854 (The 'text/html' Media Type), [section 2](https://tools.ietf.org/html/rfc2854#section-2) of which states:\r\n\r\n> Note that [HTML20] included an optional \"level\" parameter; in\r\n> practice, this parameter was never used and has been removed from\r\n> this specification.\r\n\r\nMore formally, [the current IANA registration of the text/html media type](https://www.iana.org/assignments/media-types/text/html), which is taken directly from [section 16.1 of the HTML specification](https://html.spec.whatwg.org/multipage/iana.html#text/html), does not include a \"level\" parameter.\r\n\r\nWhilst the example is non-normative, it has given rise to misleading information—e.g. in the [MDN Web Docs glossary definition of \"quality values\"](https://developer.mozilla.org/en-US/docs/Glossary/quality_values), which states:\r\n\r\n> Some syntax, like the one of Accept, allow additional specifiers\r\n> like text/html;level=1. These increase the specificity of the value.\r\n> Their use is extremely rare.\n --VERIFIER NOTES-- \nAs discussed in the mailing list:\r\n\r\n> While it is theoretically possible for media types to no longer define a\r\n> given parameter, it is not possible for them to limit usage of parameters\r\n> in HTTP. This example is still fine.\r\n>\r\n> Note that this example has already been updated in http-core's Accept",
    "submit_date": "2020-04-29",
    "submitter_name": "Alan Egerton",
    "verifier_id": 170,
    "verifier_name": "Francesca Palombini",
    "update_date": "2021-04-29 02:56:40"
  },
  {
    "errata_id": 6354,
    "doc-id": "RFC7231",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "7.1.2.",
    "orig_text": "The field value consists of a single URI-reference.  When it has the\r\n   form of a relative reference ([RFC3986], Section 4.2), the final\r\n   value is computed by resolving it against the effective request URI\r\n   ([RFC3986], Section 5).\r\n\r\n   For 201 (Created) responses, the Location value refers to the primary\r\n   resource created by the request.  For 3xx (Redirection) responses,\r\n   the Location value refers to the preferred target resource for\r\n   automatically redirecting the request.\r\n\r\n   If the Location value provided in a 3xx (Redirection) response does\r\n   not have a fragment component, a user agent MUST process the\r\n   redirection as if the value inherits the fragment component of the\r\n   URI reference used to generate the request target (i.e., the\r\n   redirection inherits the original reference's fragment, if any).\r\n\r\n   For example, a GET request generated for the URI reference\r\n   \"http://www.example.org/~tim\" might result in a 303 (See Other)\r\n   response containing the header field:\r\n\r\n     Location: /People.html#tim\r\n\r\n   which suggests that the user agent redirect to\r\n   \"http://www.example.org/People.html#tim\"",
    "correct_text": "The field value consists of a single URI-reference. Relative forms are not allowed and MUST include the entire redirected URI, even if the base URL part has not changed.",
    "notes": "Relative URIs in Location redirect headers should not be allowed.\r\nAllowing relative URIs opens up, at best, inconsistent and poor implementations and interpretations, but more importantly it opens serious security holes.\r\nFor example, when the redirect emanates from a URL shortening service (e.g. bitly.com), an attacker can 'chain' multiple relative shortened URIs, effectively obfuscating the final and malicious site.\r\nIf security tools attempt to 'rebuild and resolve', this will have an impact on performance, and itself can be exploited by attackers by creating a circular redirect (this can of course be done with full URIs as well, but then a security monitoring tool can more easily detect such a scenario).\r\nYes, one would expect security tools to only redirect to a small maximum count (say 3), but in a Denial-of-Service attack, many of these can render a security monitoring tool impotent to other attacks happening in parallel.\r\nIn addition, unless *all* User-Agents (and there are a lot of them out there) interpret the relative URL absolutely consistently, this can lead to incorrect navigation at best, and such inconsistencies can be easily exploited by attackers at worst.\r\nAll in all, at a time when the industry is trying to make internet operations safer and more secure, allowing relative URLs does the opposite, and with little to no gain by allowing.\n --VERIFIER NOTES-- \n   The text says what the working group intended it to say, and this is not an erratum.  What's more, it accurately reflects real-world usage.\r\n\r\nThe place to discuss changes such as this proposal, to be considered for future updates, is the HTTP working group's mailing list; see <https://datatracker.ietf.org/wg/httpbis/about/>.",
    "submit_date": "2020-12-10",
    "submitter_name": "Peter Sturge",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-12-15 06:52:50"
  }
]
