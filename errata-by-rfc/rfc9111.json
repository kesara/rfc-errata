[
  {
    "errata_id": "7695",
    "doc-id": "RFC9111",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.3.2",
    "orig_text": "   The proper evaluation of conditional requests by a cache depends on\r\n   the received precondition header fields and their precedence.  In\r\n   summary, the If-Match and If-Unmodified-Since conditional header\r\n   fields are not applicable to a cache, and If-None-Match takes\r\n   precedence over If-Modified-Since.  See Section 13.2.2 of [HTTP] for\r\n   a complete specification of precondition precedence.",
    "correct_text": "   The proper evaluation of conditional requests by a cache depends on\r\n   the received precondition header fields and their precedence.  In\r\n   summary, the If-Match and If-Unmodified-Since conditional header\r\n   fields are not applicable to a cache and hence such requests MUST\r\n   be forwarded to the origin, and If-None-Match takes precedence\r\n   over If-Modified-Since.  See Section 13.2.2 of [HTTP] for a complete\r\n   specification of precondition precedence.",
    "notes": "Correction:\r\n\"the If-Match and If-Unmodified-Since conditional header fields are not applicable\r\n to a cache [and hence such requests MUST be forwarded to the origin]\"\r\n\r\nThis is based upon the reading of RFC 9111#section-4.3.2-3[1]:\r\n \r\n   A cache MUST NOT evaluate conditional header fields that only apply\r\n   to an origin server, occur in a request with semantics that cannot be\r\n   satisfied with a cached response, or occur in a request with a target\r\n   resource for which it has no stored responses; such preconditions are\r\n   likely intended for some other (inbound) server.\r\n\r\n\r\nCurrent RFC 9110#section-13.1.1-13[2], RFC 9110#section-13.2.2[3] and RFC \r\n9111#section-4.3.2-4[4] does not explicitly provide clear direction to cache servers as to \r\nhow to deal with If-Match and If-Unmodified-Since conditional headers[5].\r\n\r\nThe correction intends to provide more clarity for If-Match and If-Unmodified-Since\r\nheader as to how a cache server should handle conditional header which are meant\r\nfor origin server based on the reading of above produced section of \r\nthe RFC 9111#section-4.3.2-3.\r\n\r\nIf cache nodes have to ignore If-Match and If-Unmodified-Since header as per \r\nRFC 9110#section-13.1.1-13 then in scenarios where they have a cached non-expired\r\ncontent representation which can be satisfied sans If-Match and If-Unmodified-Since\r\nheaders the same will be returned back by cache and intermediary servers. \r\n\r\nCaching layers with multiple content representation cached in the network may \r\nreturn invalid response back causing higher requests errors when dealing with origin \r\napplicable conditional headers that are sent to intermediary cache nodes from \r\nedge cache nodes for cache hydration. \r\n\r\nConsider the below scenario:\r\n\r\n1. A caching system consisting of 2 cache layers with 3 servers each,\r\nServer nodes \"A\" representing Edge cache nodes(A1, A2, A3),\r\nServer nodes \"B\" representing intermediary cache nodes(B1, B2, B3), and an \r\norigin server\r\n\r\n2. All cache servers (A and B) make use of If-Match and If-Unmodified-Since to \r\nhydrate their own cached content representation as per RFC 9110#section-13.1.1-12 [6]\r\n\r\n3. All cache servers make use of 5MiB chunk ranges for cache hydration of large \r\nfiles \r\n\r\n4. Origin server contains a file foo with size 20MiB, with content \r\nrepresentation Etag E1 \r\n\r\n5. A client C1 who sends a range request for file foo with range 10-20MiB to edge node A1\r\n\r\n6. For initial set of requests sent by edge node A1 the representation E1 gets \r\ncached on 2 of the intermediary nodes B1 and B2 (because of 2 requests for \r\n5MiB chunk each) \r\n\r\n6. Content representation for file foo changes to Etag E2 on origin \r\n\r\n7. A client C2 who sends a range request for file foo with range 10-20MiB to edge node A2\r\n\r\n8. Requests to edge node A2 which does not have a cached representation causes it \r\nto send 2 range requests for 5MiB each, in this case lets assume it is sent to \r\nintermediary cache nodes B1(range:10-15MiB) and B3(range:15-20MiB), \r\nB3 node faces cache-miss and hydrates its own cache from Range 15Mib-20MiB\r\nwith content representation E2. B1 node already has a cached representation E1\r\nfor requested range so it returns it back. A2 node which has now cached 10-15MiB E1\r\nrepresentation received from B1 has to returns error and performs a cache reset for\r\nitself because of mixed representation for the whole user requested range.\r\n\r\nIn such a case where intermediary cache severs/nodes may end up with multiple \r\ncontent representation an edge node who is trying to hydrate its own cache \r\nwill find it hard to do so, i.e. the first 5MiB \r\nchunk may end up being served by intermediary cache nodes with representation \r\nE1 and the other half of the chunk by nodes who have a content representation \r\nE2. The error rates will be higher whenever content representation changes at\r\nthe origin server for such range requests.\r\n\r\n\r\n[1]: https://www.rfc-editor.org/rfc/rfc9111#section-4.3.2-3\r\n[2]: https://www.rfc-editor.org/rfc/rfc9110#section-13.1.1-13\r\n[3]: https://www.rfc-editor.org/rfc/rfc9110#section-13.2.2\r\n[4]: https://www.rfc-editor.org/rfc/rfc9111#section-4.3.2-4\r\n[5]: https://github.com/httpwg/http-core/issues/1111\r\n[6]: https://www.rfc-editor.org/rfc/rfc9110#section-13.1.1-12",
    "submit_date": "2023-11-07",
    "submitter_name": "Dron Rathore",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2023-11-07 12:18:58"
  }
]
