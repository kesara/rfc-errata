[
  {
    "errata_id": 4535,
    "doc-id": "RFC7540",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 5.1,
    "orig_text": "(content of Figure 2)",
    "correct_text": "(see notes, below)",
    "notes": "Section 5.1 Figure 2 is unclear about what stream is being depicted when PUSH_PROMISE is used.  The figure shows a transition from /idle/ to /reserved (local)/ on a PUSH_PROMISE receive, but Section 6.6 only allows PUSH_PROMISE to be sent on a stream that is in /open/ or /half-closed (remote)/ state.  But these are talking about different streams.\r\n\r\nA note should be added to figure 2 in section 5.1 clarifying that where a PUSH_PROMISE is sent or received, the state diagram is for the promised stream, not the original stream.",
    "submit_date": "2015-11-17",
    "submitter_name": "Erik Schnell",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4645,
    "doc-id": "RFC7540",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 5.1,
    "orig_text": "idle:\r\n      All streams start in the \"idle\" state.\r\n\r\n      The following transitions are valid from this state:\r\n\r\n      *  Sending or receiving a HEADERS frame causes the stream to\r\n         become \"open\".  The stream identifier is selected as described\r\n         in Section 5.1.1.  The same HEADERS frame can also cause a\r\n         stream to immediately become \"half-closed\".\r\n\r\n      *  Sending a PUSH_PROMISE frame on another stream reserves the\r\n         idle stream that is identified for later use.  The stream state\r\n         for the reserved stream transitions to \"reserved (local)\".\r\n\r\n      *  Receiving a PUSH_PROMISE frame on another stream reserves an\r\n         idle stream that is identified for later use.  The stream state\r\n         for the reserved stream transitions to \"reserved (remote)\".\r\n\r\n      *  Note that the PUSH_PROMISE frame is not sent on the idle stream\r\n         but references the newly reserved stream in the Promised Stream\r\n         ID field.\r\n\r\n      Receiving any frame other than HEADERS or PRIORITY on a stream in\r\n      this state MUST be treated as a connection error (Section 5.4.1)\r\n      of type PROTOCOL_ERROR.",
    "correct_text": "idle:\r\n      All streams start in the \"idle\" state.\r\n\r\n      The following transitions are valid from this state:\r\n\r\n      *  Sending or receiving a HEADERS frame causes the stream to\r\n         become \"open\".  The stream identifier is selected as described\r\n         in Section 5.1.1.  The same HEADERS frame can also cause a\r\n         stream to immediately become \"half-closed\".\r\n\r\n      *  Sending a PUSH_PROMISE frame on another stream reserves the\r\n         idle stream that is identified for later use.  The stream state\r\n         for the reserved stream transitions to \"reserved (local)\".\r\n\r\n      *  Receiving a PUSH_PROMISE frame on another stream reserves an\r\n         idle stream that is identified for later use.  The stream state\r\n         for the reserved stream transitions to \"reserved (remote)\".\r\n\r\n      *  Note that the PUSH_PROMISE frame is not sent on the idle stream\r\n         but references the newly reserved stream in the Promised Stream\r\n         ID field.\r\n\r\n      Receiving any frame other than HEADERS, PUSH_PROMISE or \r\n      PRIORITY on a stream in this state MUST be treated as a \r\n      connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
    "notes": "According to the description above and the state transformation in Figure 2, a stream in the 'idle' state could receive a PUSH_PROMISE frame. \r\n\r\nWhile in the last statement of Original Text, receiving a PUSH_PROMISE on a stream in 'idle' state is a connection error.\r\n\r\nPlease fix this inconsistency problem.\n --VERIFIER NOTES-- \nThis is a duplicate of errata report #4535.\r\n\r\nThe report is incorrect: the text says \"another stream\" and has a note that explains this.  The confusion that obviously exists should be considered in a future revision of the document.",
    "submit_date": "2016-03-29",
    "submitter_name": "Jessie Liu",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4663,
    "doc-id": "RFC7540",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "8 omits",
    "orig_text": "[Note:  RFC 3875, section 4.1.16, defines the protocol version as:\r\n\r\nHTTP-Version = \"HTTP\" \"/\" 1*digit \".\" 1*digit\r\n\r\nNothing in RFC 7540 redefines this.]",
    "correct_text": "Add paragraph at end of section 8 (before 8.1) - Clarification:\r\n\r\nHTTP/2 preserves the format of the SERVER_PROTOCOL CGI variable,\r\nboth in the CGI interface and for any server logging purposes.  Where\r\na version string is necessary, it is \"HTTP/2.0\" as defined by RFC 3875.",
    "notes": "Compatibility is required with a prior published RFC, or a specific change superseding the prior RFC need be explicitly stated.  This RFC states in its abstract:\r\n\r\n\"This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged\"\r\n\r\nRFC 7540, section 3.5's connection preface string containing \"HTTP/2.0\" implies that the RFC authors should have forseen this issue, and added a paragraph to section 8 to explicitly state no change in the CGI interface variable SERVER_PROTOCOL was desired.  At least one implementation is using a version string of \"HTTP/2\", not \"HTTP/2.0\", because of how it is referred in this RFC. (\"nghttp2.org\" has incorrectly implemented this in its library routines.)\n --VERIFIER NOTES-- \nMark Nottingham:  As discussed on HTTPBIS mailing list, this isn't an issue for the HTTP specification.",
    "submit_date": "2016-04-12",
    "submitter_name": "D. Stussy",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4666,
    "doc-id": "RFC7540",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "9.1.2",
    "orig_text": "   A 421 response is cacheable by default, i.e., unless otherwise\r\n   indicated by the method definition or explicit cache controls (see\r\n   Section 4.2.2 of [RFC7234]).\r\n",
    "correct_text": "   [paragraph removed]",
    "notes": "The HTTP cache key (RFC 7234 Section 2) is based on the request URI, not on properties of the connection. Therefore, if a client were to cache a 421 response, it would then use this cached 421 to satisfy further requests to the same URI, before it has a chance to connect to an authoritative server.\r\n\r\nMark Nottingham: As discussed on list, I think the best we can do here is to note that in many cases, it'd be desireable to mark this as explicitly uncacheable.\r\n\r\nWith this paragraph removed, a 421 response is not cacheable by default, per RFC 7231 Section 6.1.",
    "submit_date": "2016-04-13",
    "submitter_name": "Vasiliy Faronov",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4720,
    "doc-id": "RFC7540",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "8.2.1",
    "orig_text": "Pushed responses are always associated with an explicit request from\r\nthe client.  The PUSH_PROMISE frames sent by the server are sent on\r\nthat explicit request's stream. ",
    "correct_text": "Promised requests are always associated with an explicit request from\r\nthe client.  The PUSH_PROMISE frames sent by the server are sent on\r\nthat explicit request's stream. ",
    "notes": "This section talks about promised requests, not pushed responses.\r\n\r\nAlexey:\r\nAs per HTTPBIS WG discussion, this is correct in the original, but clearer in the proposed text.",
    "submit_date": "2016-06-27",
    "submitter_name": "Kazu Yamamoto",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4871,
    "doc-id": "RFC7540",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.3.4",
    "orig_text": "For example, assume streams A and B share a parent, and streams C\r\nand D both depend on stream A. Prior to the removal of stream A,\r\nif streams A and D are unable to proceed, then stream C receives\r\nall the resources dedicated to stream A. If stream A is removed\r\nfrom the tree, the weight of stream A is divided between streams\r\nC and D. If stream D is still unable to proceed, this results in\r\nstream C receiving a reduced proportion of resources. For equal\r\nstarting weights, C receives one third, rather than one half, of\r\navailable resources.",
    "correct_text": "For example, assume streams A and B share a parent, and streams C\r\nand D both depend on stream A. When A is complete, streams C and\r\nD receive all the resources that would be allocated to stream\r\nA. If stream D is unable to proceed, stream C shares resources\r\nwith stream B. Assuming equal starting weights on all streams,\r\nthis means that streams B and C receive an equal share.  However,\r\nif stream A is removed from the tree, the weight of stream A is\r\ndivided between streams C and D. With stream A removed and stream\r\nD unable to proceed, stream C receives a reduced proportion of\r\nresources. For equal starting weights, C receives one third,\r\nrather than one half, of available resources.",
    "notes": "The example was incorrect.  Dependent streams do not receive resources if their parent is blocked; they only receive resources once the parent is complete.\r\n\r\nNote that I didn't correct the common misunderstanding regarding the third here.  That might be further improved by doing the math.  That is:\r\n\r\nBefore removal: A=N (C=N, D=N), B=N;\r\nAfter removal: B=N, C=N/2, D=N/2;\r\nTherefore viable streams are B=N and C=N/2 meaning a total pool of 3N/2.  The resource proportion allocated to C is therefore (N/2)/(3N/2)=1/3.\r\n\r\nBut that would probably need an entire section for the example, rather than a single paragraph.\n --VERIFIER NOTES-- \n   See HTTPBIS mailing list discussion.",
    "submit_date": "2016-11-30",
    "submitter_name": "Martin Thomson",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4925,
    "doc-id": "RFC7540",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": null,
    "correct_text": null,
    "notes": "It's unclear from the text whether PRIORITY frames affect stream states (as shown in the state machine in Section 5.1).  The original intent was that prioritization of streams was independent of the mechanics of opening and closing streams, but this was not consistently captured.\r\n\r\nTwo small additions to the document would help considerably.\r\n\r\nIn Section 5.3 (Stream Priority) add a new paragraph:\r\n\r\n> The information that an endpoint maintains for stream priority is separate from other state. Importantly, this includes stream states (Section 5.1).  A stream in any state can have its priority changed with a PRIORITY frame. The state of a stream is not changed as a result of changing its priority.  The number of streams for which state is remembered is at the discretion of an endpoint, see Section 5.3.4 for details.\r\n\r\n In Section 6.4 (PRIORITY) a new sentence at the end of the first paragraph:\r\n\r\n> Sending or receiving a PRIORITY frame does not affect the state of any stream (Section 5.1), only the priority of streams is altered.",
    "submit_date": "2017-02-07",
    "submitter_name": "Martin Thomson",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5031,
    "doc-id": "RFC7540",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 3.5,
    "orig_text": "   That is, the connection preface starts with the string \"PRI *\r\n   HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\"). \r\n                              ^ ",
    "correct_text": "   That is, the connection preface starts with the string \"PRI *\r\n   HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\".  ",
    "notes": "Typo",
    "submit_date": "2017-06-07",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5249,
    "doc-id": "RFC7540",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.2.1",
    "orig_text": "     HTTP2-Settings    = token68",
    "correct_text": "     HTTP2-Settings    = [ token68 ]",
    "notes": "An initial SETTINGS frame is explicitly allowed by Section 3.5 to be empty. The payload of an empty SETTINGS frame is an empty sequence of octets, whose base64url encoding is an empty string. Thus, the HTTP2-Settings header field ought to permit an empty string as value. But the ABNF for \"token68\" does not match an empty string.\n --VERIFIER NOTES-- \nMartin Thomson wrote:\r\n\r\nThe observation is correct.  However, I'm not sure that this is the\r\nsolution I would choose.  I'm not sure, but I think that an empty\r\nheader field would cause problems.  Maybe the right conclusion to draw\r\nhere is that you have to include at least one setting if you use this\r\nheader field.\r\n\r\nAlexey:\r\n\r\nAgreement in the WG to reject the erratum as proposed, but a better fix might be proposed separately.\r\n",
    "submit_date": "2018-02-01",
    "submitter_name": "Vasiliy Faronov",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 6309,
    "doc-id": "RFC7540",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 5.1,
    "orig_text": "      Receiving any frame other than HEADERS or PRIORITY on a stream in\r\n      this state MUST be treated as a connection error (Section 5.4.1)\r\n      of type PROTOCOL_ERROR.\r\n\r\n...and similar throughout the section",
    "correct_text": "      Receiving any frame defined in this document other than HEADERS\r\n      or PRIORITY on a stream in\r\n      this state MUST be treated as a connection error (Section 5.4.1)\r\n      of type PROTOCOL_ERROR.  Frames of unknown types are ignored.",
    "notes": "Discovered via Chrome's GREASE experiment and discussed on-list, but never filed that I can find.  The HTTP/2 RFC mandates tolerance of any unknown frame type, but also mandates rejection of frames which are not the few listed.  The conservative solution in current deployments is, of course, to restrict sending extension frame types to open (and half-closed (remote)) streams.  The text which should have been in the document to begin with, however, is that only frame types defined in the HTTP/2 specification were to be impacted by that restriction.\r\n\r\nThis is already stated in section 5.1:\r\n\r\n   In the absence of more specific guidance elsewhere in this document,\r\n   implementations SHOULD treat the receipt of a frame that is not\r\n   expressly permitted in the description of a state as a connection\r\n   error (Section 5.4.1) of type PROTOCOL_ERROR.  Note that PRIORITY can\r\n   be sent and received in any stream state.  Frames of unknown types\r\n   are ignored.\r\n\r\nHowever, it's unclear whether the \"any frame other than\" language is to be construed as \"more specific guidance.\"",
    "submit_date": "2020-10-19",
    "submitter_name": "Mike Bishop",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-10-27 16:04:48"
  }
]
