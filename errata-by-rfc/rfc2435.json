[
  {
    "errata_id": "4094",
    "doc-id": "RFC2435",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "/*\r\n * Table K.1 from JPEG spec.\r\n */\r\nstatic const int jpeg_luma_quantizer[64] = {\r\n        16, 11, 10, 16, 24, 40, 51, 61,\r\n        12, 12, 14, 19, 26, 58, 60, 55,\r\n        14, 13, 16, 24, 40, 57, 69, 56,\r\n        14, 17, 22, 29, 51, 87, 80, 62,\r\n        18, 22, 37, 56, 68, 109, 103, 77,\r\n        24, 35, 55, 64, 81, 104, 113, 92,\r\n        49, 64, 78, 87, 103, 121, 120, 101,\r\n        72, 92, 95, 98, 112, 100, 103, 99\r\n};\r\n\r\n/*\r\n * Table K.2 from JPEG spec.\r\n */\r\nstatic const int jpeg_chroma_quantizer[64] = {\r\n        17, 18, 24, 47, 99, 99, 99, 99,\r\n        18, 21, 26, 66, 99, 99, 99, 99,\r\n        24, 26, 56, 99, 99, 99, 99, 99,\r\n        47, 66, 99, 99, 99, 99, 99, 99,\r\n        99, 99, 99, 99, 99, 99, 99, 99,\r\n        99, 99, 99, 99, 99, 99, 99, 99,\r\n        99, 99, 99, 99, 99, 99, 99, 99,\r\n        99, 99, 99, 99, 99, 99, 99, 99\r\n};",
    "correct_text": "/*\r\n * Table K.1 from JPEG spec.\r\n */\r\nstatic const int jpeg_luma_quantizer[64] = {\r\n           16, 11, 12, 14, 12, 10, 16, 14,\r\n           13, 14, 18, 17, 16, 19, 24, 40,\r\n           26, 24, 22, 22, 24, 49, 35, 37,\r\n           29, 40, 58, 51, 61, 60, 57, 51,\r\n           56, 55, 64, 72, 92, 78, 64, 68,\r\n           87, 69, 55, 56, 80, 109, 81, 87,\r\n           95, 98, 103, 104, 103, 62, 77, 113,\r\n           121, 112, 100, 120, 92, 101, 103, 99,\r\n};\r\n\r\n/*\r\n * Table K.2 from JPEG spec.\r\n */\r\nstatic const int jpeg_chroma_quantizer[64] = {\r\n           17, 18, 18, 24, 21, 24, 47, 26,\r\n           26, 47, 99, 66, 56, 66, 99, 99,\r\n           99, 99, 99, 99, 99, 99, 99, 99,\r\n           99, 99, 99, 99, 99, 99, 99, 99,\r\n           99, 99, 99, 99, 99, 99, 99, 99,\r\n           99, 99, 99, 99, 99, 99, 99, 99,\r\n           99, 99, 99, 99, 99, 99, 99, 99,\r\n           99, 99, 99, 99, 99, 99, 99, 99\r\n};",
    "notes": "Luma and Chroma was not in Zig Zag order and Luma energy has been de-saturated.\n --VERIFIER NOTES-- \n  Rejected per discussion in avtcore ",
    "submit_date": "2014-09-04",
    "submitter_name": "Julius Richard Friedman",
    "verifier_id": "147",
    "verifier_name": "Ben Campbell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4095",
    "doc-id": "RFC2435",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "Appendix B",
    "orig_text": "int MakeHeaders(u_char *p, int type, int w, int h, u_char *lqt,\r\n                u_char *cqt, u_short dri)\r\n{\r\n        u_char *start = p;\r\n\r\n        /* convert from blocks to pixels */\r\n        w <<= 3;\r\n        h <<= 3;\r\n\r\n\r\n\r\nBerc, et. al.               Standards Track                    [Page 19]\r\n \r\nRFC 2435              RTP Payload Format for JPEG           October 1998\r\n\r\n\r\n        *p++ = 0xff;\r\n        *p++ = 0xd8;            /* SOI */\r\n\r\n        p = MakeQuantHeader(p, lqt, 0);\r\n        p = MakeQuantHeader(p, cqt, 1);\r\n\r\n        if (dri != 0)\r\n                p = MakeDRIHeader(p, dri);\r\n\r\n        *p++ = 0xff;\r\n        *p++ = 0xc0;            /* SOF */\r\n        *p++ = 0;               /* length msb */\r\n        *p++ = 17;              /* length lsb */\r\n        *p++ = 8;               /* 8-bit precision */\r\n        *p++ = h >> 8;          /* height msb */\r\n        *p++ = h;               /* height lsb */\r\n        *p++ = w >> 8;          /* width msb */\r\n        *p++ = w;               /* wudth lsb */\r\n        *p++ = 3;               /* number of components */\r\n        *p++ = 0;               /* comp 0 */\r\n        if (type == 0)\r\n                *p++ = 0x21;    /* hsamp = 2, vsamp = 1 */\r\n        else\r\n                *p++ = 0x22;    /* hsamp = 2, vsamp = 2 */\r\n        *p++ = 0;               /* quant table 0 */\r\n        *p++ = 1;               /* comp 1 */\r\n        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */\r\n        *p++ = 1;               /* quant table 1 */\r\n        *p++ = 2;               /* comp 2 */\r\n        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */\r\n        *p++ = 1;               /* quant table 1 */\r\n        p = MakeHuffmanHeader(p, lum_dc_codelens,\r\n                              sizeof(lum_dc_codelens),\r\n                              lum_dc_symbols,\r\n                              sizeof(lum_dc_symbols), 0, 0);\r\n        p = MakeHuffmanHeader(p, lum_ac_codelens,\r\n                              sizeof(lum_ac_codelens),\r\n                              lum_ac_symbols,\r\n                              sizeof(lum_ac_symbols), 0, 1);\r\n        p = MakeHuffmanHeader(p, chm_dc_codelens,\r\n                              sizeof(chm_dc_codelens),\r\n                              chm_dc_symbols,\r\n                              sizeof(chm_dc_symbols), 1, 0);\r\n        p = MakeHuffmanHeader(p, chm_ac_codelens,\r\n                              sizeof(chm_ac_codelens),\r\n                              chm_ac_symbols,\r\n                              sizeof(chm_ac_symbols), 1, 1);\r\n\r\n\r\n\r\n\r\nBerc, et. al.               Standards Track                    [Page 20]\r\n \r\nRFC 2435              RTP Payload Format for JPEG           October 1998\r\n\r\n\r\n        *p++ = 0xff;\r\n        *p++ = 0xda;            /* SOS */\r\n        *p++ = 0;               /* length msb */\r\n        *p++ = 12;              /* length lsb */\r\n        *p++ = 3;               /* 3 components */\r\n        *p++ = 0;               /* comp 0 */\r\n        *p++ = 0;               /* huffman table 0 */\r\n        *p++ = 1;               /* comp 1 */\r\n        *p++ = 0x11;            /* huffman table 1 */\r\n        *p++ = 2;               /* comp 2 */\r\n        *p++ = 0x11;            /* huffman table 1 */\r\n        *p++ = 0;               /* first DCT coeff */\r\n        *p++ = 63;              /* last DCT coeff */\r\n        *p++ = 0;               /* sucessive approx. */\r\n\r\n        return (p - start);\r\n};\r\n",
    "correct_text": "int MakeHeaders(u_char *p, int type, int w, int h, u_char *lqt,\r\n                u_char *cqt, u_short dri)\r\n{\r\n        u_char *start = p;\r\n\r\n        /* convert from blocks to pixels */\r\n        w <<= 3;\r\n        h <<= 3;\r\n        *p++ = 0xff;\r\n        *p++ = 0xd8;            /* SOI */\r\n\r\n        p = MakeQuantHeader(p, lqt, 0);\r\n        if(cqt != NULL) p = MakeQuantHeader(p, cqt, 1);\r\n\r\n        if (dri != 0)\r\n                p = MakeDRIHeader(p, dri);\r\n\r\n        *p++ = 0xff;\r\n        *p++ = 0xc0;            /* SOF */\r\n        *p++ = 0;               /* length msb */\r\n        *p++ = 17;              /* length lsb */\r\n        *p++ = 8;               /* 8-bit precision */\r\n        *p++ = h >> 8;          /* height msb */\r\n        *p++ = h;               /* height lsb */\r\n        *p++ = w >> 8;          /* width msb */\r\n        *p++ = w;               /* wudth lsb */\r\n        *p++ = 3;               /* number of components */\r\n        *p++ = 1;               /* comp 1 */\r\n        if (type == 0)\r\n                *p++ = 0x21;    /* hsamp = 2, vsamp = 1 */\r\n        else\r\n                *p++ = 0x22;    /* hsamp = 2, vsamp = 2 */\r\n        *p++ = 0;               /* quant table 0 */\r\n        *p++ = 1;               /* comp 1 */\r\n        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */\r\n        *p++ = 1;               /* quant table 1 */\r\n        *p++ = 2;               /* comp 2 */\r\n        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */\r\n        *p++ = 1;               /* quant table 1 */\r\n        p = MakeHuffmanHeader(p, lum_dc_codelens,\r\n                              sizeof(lum_dc_codelens),\r\n                              lum_dc_symbols,\r\n                              sizeof(lum_dc_symbols), 0, 0);\r\n        p = MakeHuffmanHeader(p, lum_ac_codelens,\r\n                              sizeof(lum_ac_codelens),\r\n                              lum_ac_symbols,\r\n                              sizeof(lum_ac_symbols), 0, 1);\r\n        if(cqt != NULL)\r\n        {\r\n        p = MakeHuffmanHeader(p, chm_dc_codelens,\r\n                              sizeof(chm_dc_codelens),\r\n                              chm_dc_symbols,\r\n                              sizeof(chm_dc_symbols), 1, 0);\r\n        p = MakeHuffmanHeader(p, chm_ac_codelens,\r\n                              sizeof(chm_ac_codelens),\r\n                              chm_ac_symbols,\r\n                              sizeof(chm_ac_symbols), 1, 1);\r\n       }\r\n\r\n\r\n\r\n\r\nBerc, et. al.               Standards Track                    [Page 20]\r\n \r\nRFC 2435              RTP Payload Format for JPEG           October 1998\r\n\r\n\r\n        *p++ = 0xff;\r\n        *p++ = 0xda;            /* SOS */\r\n        *p++ = 0;               /* length msb */\r\n        *p++ = cqt != NULL ? 0x12 : 0x0b;/* length lsb */\r\n        *p++ = cqt != NULL ? 0x03 : 0x01;/* 3 components */\r\n        *p++ = 0;               /* comp 0 */\r\n        *p++ = 0;               /* huffman table 0 */\r\n        *p++ = 0x01;               /* comp 1 */\r\n        *p++ = cqt != NULL ? 0x11 : 0x00;/* huffman table 1 */\r\n        if(cqt != NULL) *p++ = 2;/* comp 2 */\r\n        *p++ = cqt != NULL ? 0x11 : 0x00;/* huffman table 1 */\r\n        *p++ = 0;               /* first DCT coeff */\r\n        *p++ = 63;              /* last DCT coeff */\r\n        *p++ = 0;               /* sucessive approx. */\r\n\r\n        return (p - start);\r\n};\r\n",
    "notes": "Did not take into account cases with only 1 component was used.\n --VERIFIER NOTES-- \n   Rejected due to discussion in avtcore",
    "submit_date": "2014-09-04",
    "submitter_name": "Julius Richard Friedman",
    "verifier_id": "147",
    "verifier_name": "Ben Campbell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4096",
    "doc-id": "RFC2435",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "Discussion",
    "orig_text": " types  component samp. fact. samp. fact. table number\r\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n         |       |  1 (Y)  |     2     |     1     |     0     |\r\n         | 0, 64 |  2 (U)  |     1     |     1     |     1     |\r\n         |       |  3 (V)  |     1     |     1     |     1     |\r\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n         |       |  1 (Y)  |     2     |     2     |     0     |\r\n         | 1, 65 |  2 (U)  |     1     |     1     |     1     |\r\n         |       |  3 (V)  |     1     |     1     |     1     |\r\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n",
    "correct_text": "TO BE DETERMINED",
    "notes": "types  component samp. fact. samp. fact. table number\r\n        FROM StartOf Frame (0xFFC0)\r\n\r\nRead Nf - Number of image components in frame\r\n\r\nif(Nf > 1) \r\n\r\nRead Each Component\r\n\r\n          0 1 2 3 4 5 6 7 \r\n         +-+-+-+-+-+-+-+-+\r\n         |   H   |   V   |\r\n         +-+-+-+-+-+-+-+-+\r\n\r\nH: Horizontal sampling factor – Specifies the relationship between the component horizontal dimension\r\nand maximum image dimension X (see Jpeg Spec A.1.1); also specifies the number of horizontal data units of component\r\nCi in each MCU, when more than one component is encoded in a scan.\r\nVi: Vertical sampling factor – Specifies the relationship between the component vertical dimension and\r\nmaximum image dimension Y (see Jpeg Spec A.1.1); also specifies the number of vertical data units of component Ci in\r\neach MCU, when more than one component is encoded in a scan.\r\nTqi: Implied from the position in parsing\n --VERIFIER NOTES-- \n   Rejected based on discussion in avtcore. (And also because the errata does not contain a proposed change to the text).",
    "submit_date": "2014-09-04",
    "submitter_name": "Julius Richard Friedman",
    "verifier_id": "147",
    "verifier_name": "Ben Campbell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4097",
    "doc-id": "RFC2435",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.1.5",
    "orig_text": "3.1.5.  Width: 8 bits\r\n\r\n   This field encodes the width of the image in 8-pixel multiples (e.g.,\r\n   a width of 40 denotes an image 320 pixels wide).  The maximum width\r\n   is 2040 pixels.\r\n\r\n3.1.6.  Height: 8 bits\r\n\r\n   This field encodes the height of the image in 8-pixel multiples\r\n   (e.g., a height of 30 denotes an image 240 pixels tall). When\r\n   encoding interlaced video, this is the height of a video field, since\r\n   fields are individually JPEG encoded. The maximum height is 65535\r\n   pixels.",
    "correct_text": "3.1.5.  Width: 8 bits\r\n\r\n   This field encodes the width of the image in 8-pixel multiples (e.g.,\r\n   a width of 40 denotes an image 320 pixels wide).  The maximum width\r\n   is 2040 pixels.\r\n\r\n3.1.6.  Height: 8 bits\r\n\r\n   This field encodes the height of the image in 8-pixel multiples\r\n   (e.g., a height of 30 denotes an image 240 pixels tall). When\r\n   encoding interlaced video, this is the height of a video field, since\r\n   fields are individually JPEG encoded. The maximum height is 65535\r\n   pixels.",
    "notes": "Use a divisor of 256 to determine the height, where 8 / 256 = 32.\r\n\r\nEnsure FragmentOffset does not exceed 2^24, if it does then use 2^24 - value)\n --VERIFIER NOTES-- \n   Rejected based on discussion in avtcore",
    "submit_date": "2014-09-04",
    "submitter_name": "Julius Richard Friedman",
    "verifier_id": "147",
    "verifier_name": "Ben Campbell",
    "update_date": "2019-09-10 09:09:03"
  }
]
