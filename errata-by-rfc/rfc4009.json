[
  {
    "errata_id": "197",
    "doc-id": "RFC4009",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "2.5",
    "orig_text": " seedCDCParameter ::= OCTET STRING  -- 128-bit Initialization Vector",
    "correct_text": "seedCDCParameter ::= OCTET STRING (SIZE(16))\r\n                       -- 128-bit Initialization Vector\r\n",
    "notes": "",
    "submit_date": "2005-03-06",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": "100",
    "verifier_name": "Russ Housley",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "751",
    "doc-id": "RFC4009",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "",
    "orig_text": "(A)\r\n>\r\n> Unfortunately, within a few lines in the RFC text, the variable name 'X'\r\n> gets used for two very distinct purposes and contexts:\r\n>\r\n>   o   X = X0 || X1 || X2 || X3                            (2)\r\n>       ... the 32 bit wide input to the function G\r\n>\r\n>   o   X used as formal argument in the defining equations for\r\n>       the 'SS-boxes' SS0 ... SS3\r\n>       ... a single octet (8 bit wide entity),\r\n>           [application of the formulas - see (3) below - will\r\n>            substitute X0, ..., X3 in turn for the arguments]\r\n>\r\n> Perhaps, it would have been better to use another symbol, e.g. 'x', for the\r\n> latter purpose.\r\n>\r\n>\r\n> (B)\r\n>\r\n> As far as I can see, feeding the definition of the SS-boxes given in the\r\n> last 4 text/formule lines on page 3 into the formula on top of page 4,\r\n>\r\n>      Z = SS0(X0) ^ SS1(X1) ^ SS2(X2) ^ SS3(X3)            (3)\r\n>\r\n> does ***NOT*** yield the same result as using the primary defining formulas\r\n> given for Z0  ... Z3  in the first formula block of section 2.2., together\r\n> with\r\n>\r\n>      Z = Z0 || Z1 || Z2 || Z3                             (1).\r\n>\r\n> I suspect a mis-ordering in the use of m0 ... m3 in the equations defining\r\n> SS0 ... SS3 :\r\n>\r\n> With regard to the formulas (1), (2), and (3) (as numbered above), the\r\n> 'matrix' pattern of the 4x4 terms in braces { ... } , obtained from the\r\n> formula block defining SS0 ... SS3 by substitution of Xi for the argument of\r\n> SSi (i=0,1,2,3) - as required in (3) -, should be the matrix transpose of\r\n> the pattern of the same terms in braces appearing in the formula block\r\n> defining Z0 ... Z3 , e. g. the first 'column' of {...} terms for SSi()\r\n> should contain the {...} terms appearing in the formula for Z0.\r\n> But this is not the case.\r\n>\r\n> Therefore, I suspect that the last 6 text/formula lines on page 3 of RFC\r\n> 4009 should in fact read (including the enhancement from (A)\r\n> above):\r\n>\r\n>   \"\r\n>   To increase the efficiency of the G function, four extended S-boxes\r\n>   'SS-box' (See Appendix A.2) are defined as follows:\r\n>\r\n>    SS0(x)= {S1(x) & m0} || {S1(x) & m1} || {S1(x) & m2} || {S1(x) & m3}\r\n>    SS1(x)= {S2(x) & m1} || {S2(x) & m2} || {S2(x) & m3} || {S2(x) & m0}\r\n>    SS2(x)= {S1(x) & m2} || {S1(x) & m3} || {S1(x) & m0} || {S1(x) & m1}\r\n>    SS3(x)= {S2(x) & m3} || {S2(x) & m0} || {S2(x) & m1} || {S2(x) & m2}\r\n>   \"\r\n>\r\n>\r\n\r\n> In this case, I also recommend to include a textual enhancement for the\r\n> first sentence of section 2.3., replacing:\r\n>\r\n>     \"The key schedule generates each round subkeys.\"\r\n> by:\r\n>     \"The key schedule generates subkeys for each round.\"\r\n>\r\n> And finally, for completeness, it would have been useful as well to give\r\n> additional Informational Reference(s) for the seedMAC (and the\r\n> [seed]CBC) algorithm(s)/construct(s) mentioned in section 2.5. - e.g.  RFC\r\n> 3610 (and RFC 2451 / NIST SP 800-38A) [?].",
    "correct_text": "[see above]",
    "notes": "from pending",
    "submit_date": "2005-02-28",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": "100",
    "verifier_name": "Russ Housley",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "752",
    "doc-id": "RFC4009",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "",
    "orig_text": "(C)\r\n\r\nFirst, a formal issue with the ASN.1 given in the RFC text:\r\n\r\nIn the ASN.1 definitions in section 2.5., it would perhaps be more\r\nnatural and consistent with the requirements from the text (and the\r\nASN.1 comment already present there!) to give an explicit SIZE\r\nrestriction in the definition of the syntax of the initialization\r\nvector for SEED in CBC mode (which indeed *MUST* be 16 octets long).\r\nTo this end, I recommend to replace the 7th text line of section 2.5.,\r\n\r\n  \"seedCDCParameter ::= OCTET STRING  -- 128-bit Initialization Vector\"\r\n\r\nby:\r\n\r\n| \"seedCDCParameter ::= OCTET STRING (SIZE(16))\r\n|                       -- 128-bit Initialization Vector\"\r\n\r\n\r\n(D)\r\n\r\nThe text in section 2.2. talks about two basic 8x8 S-boxes, named\r\n\"S1\" and \"S2\".  Contrary to that, Appendix A.1. (on page 7) gives\r\ntables for \"S-Box S0\" and \"S-Box S1\".\r\n\r\nIt would be easier to change the headlines in Appendix A.1.,\r\nbut, given the numbering style of all other formula elements,\r\nit is certainly be more appropriate and consistent to modify the\r\nequations in section 2.2., replacing \"S1\" by \"S0\", and \"S2\" by \"S1\".\r\n\r\nI'll give a full replacement text for section 2.2. below, covering\r\nthis issue as well.\r\n\r\n\r\n[ Now, returning to the open issue ... ]\r\n(B)\r\n\r\nIn short, sorry, I do NOT agree with your definition of the SS-boxes.\r\nIt does not conform with the primary definition of the function G.\r\n\r\nBelow, I'll give you a detailed step-by-step explanation, using a\r\nconcrete example, for the reasoning already presented in my first\r\nmail.\r\n\r\nNote: For brevity and due to the email line length restriction,\r\n  in the subsequent reasoning, I will omit the braces '{ ... }'\r\n  around the ANDed terms, making use of the usual precedence rule\r\n  for multiplication over addition and the facts that\r\n  - the '^' operation is the normal addition in the 8 / 32 dimensional\r\n    vector spaces over GF(2) we are working on,\r\n  - '&' representing the 8 / 32 fold tensor product of the scalar\r\n    multiplication over GF(2) .\r\n\r\nI repeat and extend the numeration of the formulas from my first\r\nemail, already applying item (D).\r\n\r\n   X = X0 || X1 || X2 || X3                                       (2)\r\n\r\n       ... the 32 bit wide input to the function G;\r\n\r\n   Z = Z0 || Z1 || Z2 || Z3                                       (1)\r\n\r\n       ... the 32 bit wide output of the function G applied to X;\r\n           with the 8-bit wide components computed by the application\r\n           of the two S-Boxes S0 and S1 via the equations:\r\n\r\n   Z0 = S0(X0) & m0 ^ S1(X1) & m1 ^ S0(X2) & m2 ^ S1(X3) & m3     (1.0)\r\n   Z1 = S0(X0) & m1 ^ S1(X1) & m2 ^ S0(X2) & m3 ^ S1(X3) & m0     (1.1)\r\n   Z2 = S0(X0) & m2 ^ S1(X1) & m3 ^ S0(X2) & m0 ^ S1(X3) & m1     (1.2)\r\n   Z3 = S0(X0) & m3 ^ S1(X1) & m0 ^ S0(X2) & m1 ^ S1(X3) & m2     (1.3)\r\n\r\n    with    m0 = 0xFC , m1 = 0xF3 , m2 = 0xCF , and m3 = 0x3F     (1.4)\r\n\r\n\r\nThe alternate description of the Function G is to be\r\n\r\n   Z = SS0(X0) ^ SS1(X1) ^ SS2(X2) ^ SS3(X3)                      (3)\r\n\r\nwhere, below, I'll try \"my\" version of the SS-Box definition ...\r\n\r\n   SS0(x) = S0(x) & m0 || S0(x) & m1 || S0(x) & m2 || S0(x) & m3  (4.0)\r\n   SS1(x) = S1(x) & m1 || S1(x) & m2 || S1(x) & m3 || S1(x) & m0  (4.1)\r\n   SS2(x) = S0(x) & m2 || S0(x) & m3 || S0(x) & m0 || S0(x) & m1  (4.2)\r\n   SS3(x) = S1(x) & m3 || S1(x) & m0 || S1(x) & m1 || S1(x) & m2  (4.3)\r\n\r\n... and the version from the text (with the formal changes already\r\n    discussed properly applied) ...\r\n\r\n   SS0(x) = S0(x) & m3 || S0(x) & m2 || S0(x) & m1 || S0(x) & m0  (5.0)\r\n   SS1(x) = S1(x) & m0 || S1(x) & m3 || S1(x) & m2 || S1(x) & m1  (5.1)\r\n   SS2(x) = S0(x) & m1 || S0(x) & m0 || S0(x) & m3 || S0(x) & m2  (5.2)\r\n   SS3(x) = S1(x) & m2 || S1(x) & m1 || S1(x) & m0 || S1(x) & m3  (5.3)\r\n\r\n\r\nWith these notations, let's challenge the example octet sequence\r\n\r\n   X0 = 0x09 , X1 = 0x11 , X2 = 0xE1 , X3 = 0xF9                  (6a)\r\n\r\ni.e., by (2) :      X = (0x) 09 11 E1 F9                          (6b)\r\n\r\nApplying the tables from Appendix A.1., we obtain  (*)  :\r\n\r\n   S0(X0) = 0x43 ,\r\n   S1(X1) = 0x62 ,\r\n   S0(X2) = 0xB9 ,\r\n   S1(X3) = 0x4C .\r\n\r\n\r\nTo first compute Z with the original definition of G, substituting\r\n(*) and (1.4) into (1.0) .. (1.3), we obtain, step by step:\r\n\r\n   Z0 = S0(X0) & m0 ^ S1(X1) & m1 ^ S0(X2) & m2 ^ S1(X3) & m3     (1.0)\r\n      = 0x43 & 0xFC ^ 0x62 & 0xF3 ^ 0xB9 & 0xCF ^ 0x4C & 0x3F\r\n      =     0x40    ^     0x62    ^     0x89    ^     0x0C\r\n==>\r\n   Z0 = 0xA7                                                      (7.0)\r\n\r\n   Z1 = S0(X0) & m1 ^ S1(X1) & m2 ^ S0(X2) & m3 ^ S1(X3) & m0     (1.1)\r\n      = 0x43 & 0xF3 ^ 0x62 & 0xCF ^ 0xB9 & 0x3F ^ 0x4C & 0xFC\r\n      =     0x43    ^     0x42    ^     0x39    ^     0x4C\r\n==>\r\n   Z1 = 0x74                                                      (7.1)\r\n\r\n   Z2 = S0(X0) & m2 ^ S1(X1) & m3 ^ S0(X2) & m0 ^ S1(X3) & m1     (1.2)\r\n      = 0x43 & 0xCF ^ 0x62 & 0x3F ^ 0xB9 & 0xFC ^ 0x4C & 0xF3\r\n      =     0x43    ^     0x22    ^     0xB8    ^     0x40\r\n==>\r\n   Z2 = 0x99                                                      (7.2)\r\n\r\n   Z3 = S0(X0) & m3 ^ S1(X1) & m0 ^ S0(X2) & m1 ^ S1(X3) & m2     (1.3)\r\n      = 0x43 & 0x3F ^ 0x62 & 0xFC ^ 0xB9 & 0xF3 ^ 0x4C & 0xCF\r\n      =     0x03    ^     0x60    ^     0xB1    ^     0x4C\r\n==>\r\n   Z3 = 0x9E                                                      (7.3)\r\n\r\nPutting (7.0) .. (7.3) together using (1), we get the byte sequence\r\n\r\n   Z = Z0 || Z1 || Z2 || Z3                                       (1)\r\n==>\r\n   Z = (0x) A7 74 99 9E                                           (7)\r\n\r\n\r\nNow let's see what happens when we apply \"my\" definition of the\r\nSS-Boxes, substituting (6a), (*), and (1.4) into (4.0) .. (4.3) :\r\n\r\n   SS0(X0) = S0(X0) & m0 || S0(X0) & m1 || S0(X0) & m2 || S0(X0) & m3\r\n           = 0x43 & 0xFC || 0x43 & 0xF3 || 0x43 & 0xCF || 0x43 & 0x3F\r\n           =     0x40    ||     0x43    ||     0x43    ||     0x03\r\n==>\r\n   SS0(X0) = (0x) 40 43 43 03                                     (8.0)\r\n\r\n   SS1(X1) = S1(X1) & m1 || S1(X1) & m2 || S1(X1) & m3 || S1(X1) & m0\r\n           = 0x62 & 0xF3 || 0x62 & 0xCF || 0x62 & 0x3F || 0x62 & 0xFC\r\n           =     0x62    ||     0x42    ||     0x22    ||     0x60\r\n==>\r\n   SS1(X1) = (0x) 62 42 22 60                                     (8.1)\r\n\r\n   SS2(X2) = S0(X2) & m2 || S0(X2) & m3 || S0(X2) & m0 || S0(X2) & m1\r\n           = 0xB9 & 0xCF || 0xB9 & 0x3F || 0xB9 & 0xFC || 0xB9 & 0xF3\r\n           =     0x89    ||     0x39    ||     0xB8    ||     0xB1\r\n==>\r\n   SS2(X2) = (0x) 89 39 B8 B1                                     (8.2)\r\n\r\n   SS3(X3) = S1(X3) & m3 || S1(X3) & m0 || S1(X3) & m1 || S1(X3) & m2\r\n           = 0x4C & 0x3F || 0x4C & 0xFC || 0x4C & 0xF3 || 0x4C & 0xCF\r\n           =     0x0C    ||     0x4C    ||     0x40    ||     0x4C\r\n==>\r\n   SS3(X3) = (0x) 0C 4C 40 4C                                     (8.3)\r\n\r\nNote: Please observe that the terms in (8.0) .. (8.3) are indeed\r\n  the same terms as in (7.0) .. (7.3), but in 4x4 matrix transposed\r\n  order -- as stated abstractly in my first email.\r\n\r\nSumming up (8.0) .. (8.3) according to (3), we get what should be\r\nthe alternate definition of G(X) :\r\n\r\n   Z = SS0(X0) ^ SS1(X1) ^ SS2(X2) ^ SS3(X3)                      (3)\r\n     = (0x) 40 43 43 03  ^                         --  from (8.0)\r\n       (0x) 62 42 22 60  ^                         --  from (8.1)\r\n       (0x) 89 39 B8 B1  ^                         --  from (8.2)\r\n       (0x) 0C 4C 40 4C                            --  from (8.3)\r\n==>         -----------\r\n   Z = (0x) A7 74 99 9E                                           (8)\r\n\r\nObviously, (8) indeed is identical to (7).\r\n\r\n\r\nFinally, let's look for what we get with your definition of the\r\nSS-Boxes, substituting (6a), (*), and (1.4) into (5.0) .. (5.3) :\r\n\r\n   SS0(X0) = S0(X0) & m3 || S0(X0) & m2 || S0(X0) & m1 || S0(X0) & m0\r\n           = 0x43 & 0x3F || 0x43 & 0xCF || 0x43 & 0xF3 || 0x43 & 0xFC\r\n           =     0x03    ||     0x43    ||     0x43    ||     0x40\r\n==>\r\n   SS0(X0) = (0x) 03 43 43 40                                     (9.0)\r\n\r\n   SS1(X1) = S1(X1) & m0 || S1(X1) & m3 || S1(X1) & m2 || S1(X1) & m1\r\n           = 0x62 & 0xFC || 0x62 & 0x3F || 0x62 & 0xCF || 0x62 & 0xF3\r\n           =     0x60    ||     0x22    ||     0x42    ||     0x62\r\n==>\r\n   SS1(X1) = (0x) 60 22 42 62                                     (9.1)\r\n\r\n   SS2(X2) = S0(X2) & m1 || S0(X2) & m0 || S0(X2) & m3 || S0(X2) & m2\r\n           = 0xB9 & 0xF3 || 0xB9 & 0xFC || 0xB9 & 0x3F || 0xB9 & 0xCF\r\n           =     0xB1    ||     0xB8    ||     0x39    ||     0x89\r\n==>\r\n   SS2(X2) = (0x) B1 B8 39 89                                     (9.2)\r\n\r\n   SS3(X3) = S1(X3) & m2 || S1(X3) & m1 || S1(X3) & m0 || S1(X3) & m3\r\n           = 0x4C & 0xCF || 0x4C & 0xF3 || 0x4C & 0xFC || 0x4C & 0x3F\r\n           =     0x4C    ||     0x40    ||     0x4C    ||     0x0C\r\n==>\r\n   SS3(X3) = (0x) 4C 40 4C 0C                                     (8.3)\r\n\r\nSumming up (9.0) .. (9.3) according to (3), we get\r\n\r\n   Z = SS0(X0) ^ SS1(X1) ^ SS2(X2) ^ SS3(X3)                      (3)\r\n     = (0x) 03 43 43 40  ^                         --  from (9.0)\r\n       (0x) 60 22 42 62  ^                         --  from (9.1)\r\n       (0x) B1 B8 39 89  ^                         --  from (9.2)\r\n       (0x) 4C 40 4C 0C                            --  from (9.3)\r\n==>         -----------\r\n   Z = (0x) 9E 99 74 A7                                           (9)\r\n\r\nThis is NOT the same as (7).\r\n\r\n\r\nIn fact, it is the byte-reversed sequence from (7) .\r\n\r\n-- Bingo!\r\nTaking a closer look at (5.0) .. (5.3), I now see that indeed the\r\nterms in these equations are in the reverse concatenation sequence\r\ncompared to (4.0) .. (4.3) !\r\n\r\nAfter a detailed inspection of the tables given in Appendix A.2.\r\nof RFC 4009, it now becomes clear that -- disregarding the IETF\r\nconventions to represent all binary data in network byte order,\r\nand without any further notice of this fact -- these tables do NOT\r\nrepresent octect sequences (as expected from the presentation of\r\nabove formula using octet concatenation, not arithmetic left-shift\r\nor multiply-by-256 operations), BUT the hexadecimal representation\r\nof the proper 4-octet sequences improperly cast into 32 bit numbers\r\non a 'little endian' processor, i.e., without using the ntohl()\r\nintrinsic!\r\n\r\nI suspect that your definition of the SS-boxes (5.0) .. (5.3) has\r\nbeen inadvertently retrofitted to match the values given in the\r\ntables in Appendix A.2., again re-formulating the printed byte\r\norder (which is NOT the storage byte order [= octet concatenation\r\norder] in a little endian processor) using the octet concatenation\r\nnotation / formalism.\r\n\r\nBecause definition of the function G according to section 2.2. does\r\nnot make use of 32-bit integer arithmetic operations, I recommend\r\nto clarify the situation by\r\no   giving formula (4.0) .. (4.3) for the SS-Boxes, consistent\r\n    with the other formulas, and\r\no   stating explicitely in Appendix A.2. that these tables give\r\n    byte reversed presentations of the octet sequences to be\r\n    used as the output of the SS-boxes.\r\n\r\n\r\nTo catch up, here's my proposed replacement text for the whole\r\nsection 2.2. of RFC 4009, covering the issues (A), (B), and (D)\r\nmentioned so far:\r\n\r\n---------------- cut here -------------------------------\r\n\r\n2.2.  The Function G\r\n\r\n   The function G has two layers: a layer of two 8x8 S-boxes, S0 and\r\n   S1, and a layer of block permutation of sixteen 8-bit sub-blocks.\r\n   The output octet sequence Z (= Z0 || Z1 || Z2 || Z3) of the\r\n   function G with the four-octet input X (= X0 || X1 || X2 || X3)\r\n   is as follows:\r\n\r\n    Z0 = {S0(X0) & m0} ^ {S1(X1) & m1} ^ {S0(X2) & m2} ^ {S1(X3) & m3}\r\n    Z1 = {S0(X0) & m1} ^ {S1(X1) & m2} ^ {S0(X2) & m3} ^ {S1(X3) & m0}\r\n    Z2 = {S0(X0) & m2} ^ {S1(X1) & m3} ^ {S0(X2) & m0} ^ {S1(X3) & m1}\r\n    Z3 = {S0(X0) & m3} ^ {S1(X1) & m0} ^ {S0(X2) & m1} ^ {S1(X3) & m2}\r\n\r\n   where  m0 = 0xFC , m1 = 0xF3 , m2 = 0xCF , and m3 = 0x3F .\r\n\r\n   To increase the efficiency of the calculation of the function G, four\r\n   extended S-boxes with 4-octet output ('SS-boxes', see Appendix A.2.)\r\n   are defined as follows:\r\n\r\n    SS0(x) = {S0(x) & m0} || {S0(x) & m1} || {S0(x) & m2} || {S0(x) & m3}\r\n    SS1(x) = {S1(x) & m1} || {S1(x) & m2} || {S1(x) & m3} || {S1(x) & m0}\r\n    SS2(x) = {S0(x) & m2} || {S0(x) & m3} || {S0(x) & m0} || {S0(x) & m1}\r\n    SS3(x) = {S1(x) & m3} || {S1(x) & m0} || {S1(x) & m1} || {S1(x) & m2}\r\n\r\n   Hereby, the function G can be defined as follows:\r\n\r\n      Z = G(X) = SS0(X0) ^ SS1(X1) ^ SS2(X2) ^ SS3(X3)  .\r\n\r\n   This alternate definition of the function G is faster than the\r\n   original definition but it takes 16 times the memory to store\r\n   the four SS-boxes compared to the two original S-boxes.\r\n\r\n---------------- cut here -------------------------------\r\n\r\n\r\nImmediately below the headline of Appendix A.2., on page 8,\r\nI propose to insert the following text (or similar):\r\n\r\n   \"The following tables specify the byte-reversed SS-box values,\r\n    i.e., the first octet to be returned from the function G\r\n    (named Z0 in section 2.2.), is obtained by XORing together\r\n    the rightmost bytes from the appropriate entries looked up\r\n    in the following four tables, etc.\"\r\n\r\n\r\n(E)\r\n\r\nThe above discussion, and the observed deviation from the IETF\r\nstandard ('network') byte ordering convention, immediately raises\r\nadditional byte ordering concerns for\r\n-  the definition of the round function F in section 2.1., and\r\n-  the Key Schedule definition given in section 2.3.\r\n\r\nThe function G -- as defined in section 2.2. -- operates on a four-\r\noctet sequence and returns a four-octet sequence, according to the\r\nformulae labelled (1) and (2) above.\r\n\r\nThe definition of the round function F and the key schedule make use of\r\nseveral multi-byte INTEGER arithmetic operations, in particular 32-bit\r\n(mod 2^32) addition and subtraction, on input and output values of the\r\nfunction G, and the key schedule uses circular shift operations on\r\nconcatenated (64 bit) intermediate key blocks.\r\n\r\nWith regard to the observations made above, I now suspect that some\r\nof the implicit 'cast' operations (between octet sequences and multi-\r\nbyte integers) involved in the round functions and the key schedule\r\nmight also be formulated in a little-endian centric way, omitting the\r\nnecessary application of the htonl() and ntohl() intrinsics when\r\nproducing the test cases in Appendix B.  (I did not have the time\r\nto verify that.)\r\n\r\nFor the sake of interoperability, it SHOULD be clarified whether the\r\nformulae given for R0' and R1' in section 2.1., and for Ki0 and Ki1\r\nin section 2.3., as well as the constant's values tabulated in the\r\nlatter section, are specified according to IEFT standard byte ordering\r\nrules, or with implicit little-endian byte order in mind.\r\n\r\n",
    "correct_text": "[see above]",
    "notes": "from pending",
    "submit_date": "2005-02-28",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": "100",
    "verifier_name": "Russ Housley",
    "update_date": "2019-09-10 09:09:03"
  }
]
