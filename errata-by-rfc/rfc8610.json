[
  {
    "errata_id": "6278",
    "doc-id": "RFC8610",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "Appendix B",
    "orig_text": "BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF\r\n",
    "correct_text": "BCHAR = %x20-26 / %x28-5B / %x5D-7E / %x80-10FFFD / SESC / CRLF\r\n",
    "notes": "Between draft 6 and 7 of the RFC, the ASCII DELETE character 0x7F was excluded from the character set allowed in text literals.  I believe it should also be excluded from the character set of bytestring literals.\r\n\r\nA 0x7F byte could not be decoded if included in a hex or base64 bytestring, leaving only UTF-8 bytestrings.  Since there is no discussion in the text of any reason to allow this character in a UTF-8 bytestring when it was not allowed in a UTF-8 text string, I suspect this was an oversight.\r\n\r\n===== Verifier notes =====\r\nIt was, indeed, an oversight, but discussion on the CBOR working group list shows that the proper fix is not straightforward, and that it should be handled in the next version of the spec.",
    "submit_date": "2020-09-04",
    "submitter_name": "Eric Seppanen",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2020-09-04 12:24:34"
  },
  {
    "errata_id": "6526",
    "doc-id": "RFC8610",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "G.2",
    "orig_text": "   The escaping rules of JSON strings are applied equivalently for\r\n   text-based byte strings, e.g., \"\\\" stands for a single backslash and\r\n   \"'\" stands for a single quote.  Whitespace is included literally,\r\n   i.e., the previous section does not apply to text-based byte strings.",
    "correct_text": "   The escaping rules of JSON strings are applied equivalently for\r\n   text-based byte strings, e.g., \"\\\\\" stands for a single backslash and\r\n   \"\\'\" stands for a single quote.  Whitespace is included literally,\r\n   i.e., the previous section does not apply to text-based byte strings.",
    "notes": "\"\\\" and \"'\" need a backslash to escape them.",
    "submit_date": "2021-04-11",
    "submitter_name": "Sean Bartell",
    "verifier_id": "170",
    "verifier_name": "Francesca Palombini",
    "update_date": "2021-04-12 05:52:53"
  },
  {
    "errata_id": "6527",
    "doc-id": "RFC8610",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "B",
    "orig_text": "text = %x22 *SCHAR %x22\r\nSCHAR = %x20-21 / %x23-5B / %x5D-7E / %x80-10FFFD / SESC\r\nSESC = \"\\\" (%x20-7E / %x80-10FFFD)",
    "correct_text": "SESC = \"\\\" ( %x22 / \"/\" / \"\\\" /                 ; \\\" \\/ \\\\\r\n             %x62 / %x66 / %x6E / %x72 / %x74 / ; \\b \\f \\n \\r \\t\r\n             (%x75 hexchar) )                   ; \\u\r\nhexchar = non-surrogate / (high-surrogate \"\\\" %x75 low-surrogate)\r\nnon-surrogate = ((DIGIT / \"A\"/\"B\"/\"C\" / \"E\"/\"F\") 3HEXDIG) /\r\n               (\"D\" %x30-37 2HEXDIG )\r\nhigh-surrogate = \"D\" (\"8\"/\"9\"/\"A\"/\"B\") 2HEXDIG\r\nlow-surrogate = \"D\" (\"C\"/\"D\"/\"E\"/\"F\") 2HEXDIG",
    "notes": "As discussed during the CBOR interim 2021-04-21 and in the mailing list: https://mailarchive.ietf.org/arch/msg/cbor/ljHAiw-WhNqoIKAzkjZa4WIf56Q/ \r\n--\r\nThe ABNF used in [RFC8610] for the content of text string literals is rather permissive:\r\n\r\ntext = %x22 *SCHAR %x22\r\nSCHAR = %x20-21 / %x23-5B / %x5D-7E / %x80-10FFFD / SESC\r\nSESC = \"\\\" (%x20-7E / %x80-10FFFD)\r\n\r\nThis allows almost any non-C0 character to be escaped by a backslash, but critically misses out on the \\uXXXX and \\uHHHH\\uLLLL forms that JSON allows to specify characters in hex. Both can be solved by updating the SESC production to:\r\n\r\nSESC = \"\\\" ( %x22 / \"/\" / \"\\\" /                 ; \\\" \\/ \\\\\r\n             %x62 / %x66 / %x6E / %x72 / %x74 / ; \\b \\f \\n \\r \\t\r\n             (%x75 hexchar) )                   ; \\u\r\nhexchar = non-surrogate / (high-surrogate \"\\\" %x75 low-surrogate)\r\nnon-surrogate = ((DIGIT / \"A\"/\"B\"/\"C\" / \"E\"/\"F\") 3HEXDIG) /\r\n               (\"D\" %x30-37 2HEXDIG )\r\nhigh-surrogate = \"D\" (\"8\"/\"9\"/\"A\"/\"B\") 2HEXDIG\r\nlow-surrogate = \"D\" (\"C\"/\"D\"/\"E\"/\"F\") 2HEXDIG\r\n\r\nNow that SESC is more restrictively formulated, this also requires an update to the BCHAR production used in the ABNF syntax for byte string literals:\r\n\r\nbytes = [bsqual] %x27 *BCHAR %x27\r\nBCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF\r\nbsqual = \"h\" / \"b64\"\r\nThe updated version explicit allows \\', which is no longer allowed in the updated SESC:\r\n\r\nBCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / \"\\'\" / CRLF\r\n",
    "submit_date": "2021-04-11",
    "submitter_name": "Sean Bartell",
    "verifier_id": "170",
    "verifier_name": "Francesca Palombini",
    "update_date": "2021-04-23 08:29:01"
  },
  {
    "errata_id": "6543",
    "doc-id": "RFC8610",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "B",
    "orig_text": "     bytes = [bsqual] %x27 *BCHAR %x27\r\n     BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF",
    "correct_text": "     bytes = %x27 *BCHAR %x27\r\n           / bsqual %x27 *QCHAR %x27\r\n     BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF\r\n     QCHAR = DIGIT / ALPHA / \"+\" / \"/\" / \"-\" / \"_\" / \"=\" / WS\r\n",
    "notes": "As discussed during the CBOR interim 2021-04-21 and in the mailing list: https://mailarchive.ietf.org/arch/msg/cbor/ekFn8a4GbUQAk4nyhc-Il-ZRLZc/\r\n--\r\n\r\nThe ABNF used in [RFC8610] for the content of byte string literals lumps together byte strings notated as text with byte strings notated in base16 (hex) or base64 (but see also updated BCHAR production above):\r\n\r\nbytes = [bsqual] %x27 *BCHAR %x27\r\nBCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF\r\n\r\nErrata report 6543 proposes to handle the two cases in separate productions (where, with an updated SESC, BCHAR obviously needs to be updated as above):\r\n\r\nbytes = %x27 *BCHAR %x27\r\n      / bsqual %x27 *QCHAR %x27\r\nBCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF\r\nQCHAR = DIGIT / ALPHA / \"+\" / \"/\" / \"-\" / \"_\" / \"=\" / WS\r\n\r\nThis potentially causes a subtle change, which is hidden in the WS production:\r\n\r\nWS = SP / NL\r\nSP = %x20\r\nNL = COMMENT / CRLF\r\nCOMMENT = \";\" *PCHAR CRLF\r\nPCHAR = %x20-7E / %x80-10FFFD\r\nCRLF = %x0A / %x0D.0A\r\n\r\nThis allows any non-C0 character in a comment, so this fragment becomes possible:\r\n\r\nfoo = h'\r\n   43424F52 ; 'CBOR'\r\n   0A       ; LF, but don't use CR!\r\n'\r\n\r\nThe current text is not unambiguously saying whether the three apostrophes need to be escaped with a \\ or not, as in:\r\n\r\nfoo = h'\r\n   43424F52 ; \\'CBOR\\'\r\n   0A       ; LF, but don\\'t use CR!\r\n'\r\n... which would be supported by the existing ABNF in [RFC8610].",
    "submit_date": "2021-04-13",
    "submitter_name": "Sean Bartell",
    "verifier_id": "170",
    "verifier_name": "Francesca Palombini",
    "update_date": "2021-04-23 08:34:23"
  },
  {
    "errata_id": "6575",
    "doc-id": "RFC8610",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "2.2.3",
    "orig_text": "   Where a major type of 6 (Tag) is used, the type\r\n   of the tagged item can be specified by appending it in parentheses.",
    "correct_text": "   Where a major type of 6 (Tag) is used, the type \r\n   of the tagged item can be specified by appending it in parentheses.\r\n   Additionally, for major type 6 the value of the argument, not the \r\n   additional info is what follows the dot.",
    "notes": "The text at the top of page 50 is correct. The examples in 2.2.3 are also correct.\r\n\r\nSee https://mailarchive.ietf.org/arch/msg/cbor/0fhPGMaG1-TPmKlgKnP7iA2lb9M/ for discussion in the working group.",
    "submit_date": "2021-05-06",
    "submitter_name": "Laurence Lundblade",
    "verifier_id": "170",
    "verifier_name": "Francesca Palombini",
    "update_date": "2022-06-01 15:03:14"
  }
]
