[
  {
    "errata_id": 5483,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.8.2",
    "orig_text": "For X25519 and X448, the contents of the public value are the byte\r\nstring inputs and outputs of the corresponding functions defined in\r\n[RFC7748]: 32 bytes for X25519 and 56 bytes for X448.",
    "correct_text": "For X25519 and X448, the contents of the public value are the byte\r\nstring outputs of the corresponding functions defined in [RFC7748]: 32\r\nbytes for X25519 and 56 bytes for X448.",
    "notes": "Per Section 7.4.2 of this RFC and Section 6 of RFC7748, the byte string inputs to the corresponding ECDH scalar multiplication function are the private key and the u-coordinate of the standard public base point, the former of which of course must not be transmitted and the latter of which is a known constant.\r\n\r\nFrom another perspective, including the byte string inputs in the contents of the public value would contradict the resulting content sizes given at the end of the cited paragraph as well as the statement in Section 7.4.2 that the public key put into the KeyShareEntry is the output of ECDH scalar multiplication function.",
    "submit_date": "2018-08-28",
    "submitter_name": "Patrick Kelsey",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5627,
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "4.2.11",
    "orig_text": "In TLS versions prior to TLS 1.3, the Server Name Identification\r\n(SNI) value ",
    "correct_text": "In TLS versions prior to TLS 1.3, the Server Name Indication\r\n(SNI) value ",
    "notes": "RFC 6066 and many other places indicate that the correct expansion for \"SNI\" is \"Server Name Indication\", not \"Server Name Identification\".",
    "submit_date": "2019-02-08",
    "submitter_name": "Daniel Kahn Gillmor",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5682,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.3.2, B.3.2",
    "orig_text": "--- rfc8446.txt\t2018-08-10 20:12:08.000000000 -0400\r\n+++ rfc8446.erratum.txt\t2019-04-01 15:44:54.000000000 -0400\r\n@@ -3341,7 +3341,7 @@\r\n \r\n       struct {\r\n           opaque certificate_request_context<0..2^8-1>;\r\n-          Extension extensions<2..2^16-1>;\r\n+          Extension extensions<0..2^16-1>;\r\n       } CertificateRequest;\r\n \r\n \r\n@@ -7309,7 +7309,7 @@\r\n \r\n       struct {\r\n           opaque certificate_request_context<0..2^8-1>;\r\n-          Extension extensions<2..2^16-1>;\r\n+          Extension extensions<0..2^16-1>;\r\n       } CertificateRequest;\r\n \r\n \r\n",
    "correct_text": "--- rfc8446.txt\t2018-08-10 20:12:08.000000000 -0400\r\n+++ rfc8446.erratum.txt\t2019-04-01 15:44:54.000000000 -0400\r\n@@ -3341,7 +3341,7 @@\r\n \r\n       struct {\r\n           opaque certificate_request_context<0..2^8-1>;\r\n-          Extension extensions<2..2^16-1>;\r\n+          Extension extensions<0..2^16-1>;\r\n       } CertificateRequest;\r\n \r\n \r\n@@ -7309,7 +7309,7 @@\r\n \r\n       struct {\r\n           opaque certificate_request_context<0..2^8-1>;\r\n-          Extension extensions<2..2^16-1>;\r\n+          Extension extensions<0..2^16-1>;\r\n       } CertificateRequest;\r\n \r\n \r\n",
    "notes": "The length of this vector can never 2.  It is either 0, if the vector is empty, or >=4, if the vector has at least one extension.  Nothing elsewhere in the spec requires a non-zero number of extensions here, so this syntax should allow a zero-length vector.",
    "submit_date": "2019-04-01",
    "submitter_name": "Richard Barnes",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5717,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "2.2.",
    "orig_text": "\r\n Figure 3 shows a pair of handshakes in which the first handshake\r\n   establishes a PSK and the second handshake uses it:\r\n \r\n          Client                                               Server\r\n \r\n   Initial Handshake:\r\n          ClientHello\r\n          + key_share               -------->\r\n                                                          ServerHello\r\n                                                          + key_share\r\n                                                {EncryptedExtensions}\r\n                                                {CertificateRequest*}\r\n                                                       {Certificate*}\r\n                                                 {CertificateVerify*}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Certificate*}\r\n          {CertificateVerify*}\r\n          {Finished}                -------->\r\n                                    <--------      [NewSessionTicket]\r\n          [Application Data]        <------->      [Application Data]\r\n \r\n \r\n   Subsequent Handshake:\r\n          ClientHello\r\n          + key_share*\r\n          + pre_shared_key          -------->\r\n                                                          ServerHello\r\n                                                     + pre_shared_key\r\n                                                         + key_share*\r\n                                                {EncryptedExtensions}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Finished}                -------->\r\n          [Application Data]        <------->      [Application Data]\r\n \r\n               Figure 3: Message Flow for Resumption and PSK\r\n",
    "correct_text": "\r\n Figure 3 shows a pair of handshakes in which the first handshake\r\n   establishes a PSK and the second handshake uses it:\r\n \r\n          Client                                               Server\r\n \r\n   Initial Handshake:\r\n          ClientHello\r\n          + key_share               -------->\r\n                                                          ServerHello\r\n                                                          + key_share\r\n                                                {EncryptedExtensions}\r\n                                                {CertificateRequest*}\r\n                                                       {Certificate*}\r\n                                                 {CertificateVerify*}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Certificate*}\r\n          {CertificateVerify*}\r\n          {Finished}                -------->\r\n                                    <--------      [NewSessionTicket]\r\n          [Application Data]        <------->      [Application Data]\r\n \r\n \r\n   Subsequent Handshake:\r\n          ClientHello\r\n          + key_share*\r\n          + psk_key_exchange_modes        \r\n          + pre_shared_key          -------->\r\n\r\n                                                          ServerHello\r\n                                                     + pre_shared_key\r\n                                                         + key_share*\r\n                                                {EncryptedExtensions}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Finished}                -------->\r\n          [Application Data]        <------->      [Application Data]\r\n \r\n               Figure 3: Message Flow for Resumption and PSK\r\n",
    "notes": "The pre_shared_key requires the pre_share_key extension. As mentioned by Martin Thompson figures do not necessarily guarantee all extensions to be mentioned. However in this case, that would be clarifying to have both extensions mentioned on the figure.",
    "submit_date": "2019-05-03",
    "submitter_name": "Daniel Migault",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5868,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.3",
    "orig_text": "   ECDSA algorithms:  Indicates a signature algorithm using ECDSA\r\n      [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA]\r\n      and FIPS 186-4 [DSS], and the corresponding hash algorithm as\r\n      defined in [SHS].  The signature is represented as a DER-encoded\r\n      [X690] ECDSA-Sig-Value structure.",
    "correct_text": "   ECDSA algorithms:  Indicates a signature algorithm using ECDSA\r\n      [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA]\r\n      and FIPS 186-4 [DSS], and the corresponding hash algorithm as\r\n      defined in [SHS].  The signature is represented as a DER-encoded\r\n      [X690] ECDSA-Sig-Value structure as defined in [RFC4492].",
    "notes": "There is a possibility for confusion as the ECDSA-Sig-Value has two conflicting definitions in authoritative standards. TLS always used the following (see RFC4492):\r\n\r\n   ECDSA-Sig-Value ::= SEQUENCE {\r\n     r  INTEGER,\r\n     s  INTEGER\r\n   }\r\n\r\nbut the publicly accessible SECG SEC1 v2.0 (https://www.secg.org/sec1-v2.pdf) defines it like this:\r\n\r\nECDSA-Sig-Value ::= SEQUENCE {\r\n r INTEGER,\r\n s INTEGER,\r\n a INTEGER OPTIONAL,\r\n y CHOICE { b BOOLEAN, f FieldElement } OPTIONAL\r\n}\r\n\r\nI think using the RFC5480 in the Corrected Text would be cleaner than RFC4492, but the former is not an existing reference, so we would need to update section 12 also.",
    "submit_date": "2019-10-02",
    "submitter_name": "Hubert Kario",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 5874,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 5.1,
    "orig_text": "...\r\n\r\n   Application Data messages contain data that is opaque to TLS.\r\n   Application Data messages are always protected.  Zero-length\r\n   fragments of Application Data MAY be sent, as they are potentially\r\n   useful as a traffic analysis countermeasure.  Application Data\r\n   fragments MAY be split across multiple records or coalesced into a\r\n   single record.",
    "correct_text": "...\r\n\r\n   Application Data messages contain data that is opaque to TLS.\r\n   Application Data messages are always protected.  Zero-length\r\n   fragments of Application Data (i.e. those encapsulating an\r\n   TLSInnerPlaintext record having a content field of length zero)\r\n   MAY be sent, as they are potentially useful as a traffic analysis\r\n   countermeasure. Application Data fragments MAY be split across\r\n   multiple records or coalesced into a single record.",
    "notes": "In the interest of clarity, it may be prudent to specify the type of record for\r\nwhich a fragment of length zero is being considered - it cannot be that of the\r\nTLSCiphertext itself, for \"Application Data messages are always protected,\"\r\ntherefore I infer this relates to the TLSInnerPlaintext content field (of\r\nlength \"TLSPlaintext.length\") - i.e. to the TLSPlaintext fragment.\r\n\r\nNote: This comment also applies to previous versions of the TLS specification,\r\nin particular with the introduction of the respective text concerning zero-length\r\nfragments in RFC 5246. In TLS 1.2, this would be the GenericXXCipher content\r\nfield of length \"TLSCompressed.length\" - i.e. to the TLSCompressed fragment.\r\n\r\nNote: The implications of zero-length records must be considered with respect to\r\npotential vectors for denial of service.",
    "submit_date": "2019-10-12",
    "submitter_name": "Mr Laurie Perrin",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 5976,
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 11,
    "orig_text": "   This document updates an entry in the TLS Certificate Types registry\r\n   originally created in [RFC6091] and updated in [RFC8447].  IANA has\r\n   updated the entry for value 1 to have the name \"OpenPGP_RESERVED\",\r\n   \"Recommended\" value \"N\", and comment \"Used in TLS versions prior\r\n   to 1.3.\"\r\n",
    "correct_text": "   This document updates two entries in the TLS Certificate Types registry\r\n   originally created in [RFC6091] and updated in [RFC8447].  IANA has\r\n   updated the entry for value 1 to have the name \"OpenPGP_RESERVED\",\r\n   \"Recommended\" value \"N\", and comment \"Used in TLS versions prior\r\n   to 1.3.\"  IANA has updated the entry for value 0 to have the name\r\n   \"X509\", \"Recommended\" value \"Y\", and comment \"Was X.509 before TLS 1.3\".",
    "notes": "The protocol description language changed the spelling used for \"X509\", and the registry should be updated to match.",
    "submit_date": "2020-02-04",
    "submitter_name": "Rich Salz",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-03-06 19:01:36"
  },
  {
    "errata_id": 6120,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 1,
    "orig_text": "the underlying transport is a reliable, in-order data stream\r\n\r\n",
    "correct_text": "the underlying transport layer is a reliable, in-order stream delivery service\r\n\r\nor\r\n\r\nthe underlying transport protocol is a reliable, in-order stream delivery service\r\n\r\nor similar",
    "notes": "Similar elsewhere",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6121,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 1,
    "orig_text": "cryptographic modes",
    "correct_text": "cryptographic algorithms",
    "notes": null,
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6122,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 1.2,
    "orig_text": "The key derivation functions have been redesigned.",
    "correct_text": "The key derivation function has been redesigned.",
    "notes": null,
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6123,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 2,
    "orig_text": "The handshake protocol allows peers to negotiate a protocol version, select cryptographic algorithms, optionally authenticate each other, and establish shared secret keying material.",
    "correct_text": null,
    "notes": "Only client authentication is optional (albeit, server authentication is implicit for PSK-only key exchange mode)",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6124,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 2,
    "orig_text": "   In the Key Exchange phase, the client sends the ClientHello                  \r\n   (Section 4.1.2) message, which contains a random nonce                       \r\n   (ClientHello.random); its offered protocol versions; a list of               \r\n   symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key         \r\n   shares (in the \"key_share\" (Section 4.2.8) extension), a set of              \r\n   pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11)              \r\n   extension), or both; and potentially additional extensions.   ",
    "correct_text": "   In the Key Exchange phase, the client sends the ClientHello                  \r\n   (Section 4.1.2) message, which contains a random nonce                       \r\n   (ClientHello.random); its offered protocol versions; a list of               \r\n   symmetric cipher/Hash algorithm pairs; either a set of Diffie-Hellman key         \r\n   shares (in the \"key_share\" (Section 4.2.8) extension), a set of              \r\n   pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11)              \r\n   extension), or both; and potentially additional extensions.   \r\n\r\nor\r\n\r\n   In the Key Exchange phase, the client sends the ClientHello                  \r\n   (Section 4.1.2) message, which contains a random nonce                       \r\n   (ClientHello.random); its offered protocol versions; a list of               \r\n   symmetric cipher/Hash algorithm (to be used with HKDF) pairs; either a set of Diffie-Hellman key         \r\n   shares (in the \"key_share\" (Section 4.2.8) extension), a set of              \r\n   pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11)              \r\n   extension), or both; and potentially additional extensions.   ",
    "notes": null,
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6125,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "PSKs are referred to as out-of-band and external",
    "correct_text": "Referring to PSKs as either out-of-band xor external would help at least one reader",
    "notes": null,
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6126,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.1.1",
    "orig_text": "Note that if the PSK can be used without (EC)DHE, then\r\nnon-overlap in the \"supported_groups\" parameters need not be fatal, \r\nas it is in the non-PSK case discussed in the previous paragraph.",
    "correct_text": "Note that if the PSK can be used without (EC)DHE, then\r\nnon-overlap in the \"supported_groups\" parameters need not be fatal, \r\nas it is in the non-PSK case discussed in the previous paragraph, \r\nbecause PSK-only key exchange mode does not need supported_groups.",
    "notes": "If \"the PSK can be used without (EC)DHE\", then PSK-only key exchange mode can be used, which doesn't require supported_groups. This is perhaps worthy of explanation.",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6127,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.1.2.",
    "orig_text": "If a \"key_share\" extension was supplied in the HelloRetryRequest,\r\nreplacing the list of shares with a list containing a single\r\nKeyShareEntry from the indicated group.",
    "correct_text": "If a \"key_share\" extension was supplied in the HelloRetryRequest,\r\nreplacing the list of shares with a list containing a single\r\nKeyShareEntry from the indicated group. Note: A \"key_share\" \r\nextension may not be supplied in a HelloRetryRequest message \r\nwhen a server receives  an \"early_data\" (Section 4.2.10).",
    "notes": null,
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6128,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "terminate and abort are used interchangeable, but this isn't explained until after such use.\r\n\r\nIn Section 6.2, we have: In the rest of this specification, when the phrases \"terminate the connection\" and \"abort the handshake\" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the\r\ndescriptions below.  ",
    "correct_text": "Perhaps explain terminology earlier. At the very least, in Section 6.2, open the above sentence with \"Throughout this specification\"\r\n\r\n",
    "notes": null,
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6135,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "Global",
    "orig_text": "list, series, set, and vector are seemingly used as synonyms. ",
    "correct_text": "Using list, series, set, xor vector would help at least one reader. \r\n",
    "notes": "Additionally, consistent usage is desirable, e.g., page 31 uses \"A list of extensions\" whereas \"A set of \r\nextensions\" is used on page 60. Elsewhere inconsistently usage causes confusion, e.g., \r\nPage 48:\r\n\r\n   client_shares:  A list of offered KeyShareEntry values in descending\r\n      order of client preference.\r\n\r\n   This vector MAY be empty if the client is requesting a\r\n\r\n(Replace \"vector\" with \"list\", or vice versa.)",
    "submit_date": "2020-04-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6136,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.1.4",
    "orig_text": "   Upon receipt of a HelloRetryRequest, the client MUST check the\r\n   legacy_version, legacy_session_id_echo, cipher_suite, and     \r\n   legacy_compression_method as specified in Section 4.1.3 ",
    "correct_text": null,
    "notes": "Section 4.1.3 defines no checks for legacy_version nor legacy_compression_method",
    "submit_date": "2020-04-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6137,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.2.10",
    "orig_text": "symmetric cipher suite",
    "correct_text": "cipher suite",
    "notes": null,
    "submit_date": "2020-04-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6138,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.2.10",
    "orig_text": "   For externally              \r\n   provisioned PSKs, the associated values are those provisioned along \r\n   with the key.  For PSKs established via a NewSessionTicket message, \r\n   the associated values are those which were negotiated in the        \r\n   connection which established the PSK.  \r\n\r\n   ...\r\n\r\n   For externally established             \r\n   PSKs, the associated values are those provisioned along with the key.\r\n   For PSKs established via a NewSessionTicket message, the associated  \r\n   values are those negotiated in the connection during which the ticket\r\n   was established.                                                     ",
    "correct_text": "   For externally              \r\n   provisioned PSKs, the associated values are those provisioned along \r\n   with the key.  For PSKs established via a NewSessionTicket message, \r\n   the associated values are those which were negotiated in the        \r\n   connection which established the PSK.  ",
    "notes": "Drop largely verbatim duplicated text",
    "submit_date": "2020-04-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6139,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.4.2.2.",
    "orig_text": "As servers MAY require the presence of the \"server_name\" extension, clients\r\nSHOULD send this extension, when applicable.",
    "correct_text": "As servers MAY require the presence of the \"server_name\" extension, client\r\nSHOULD send this extension.",
    "notes": "Since it is unclear when it is applicable for a server to send the extension, dropping \"when applicable\"\r\nseems appropriate. Alternatively, giving some extra guidance would be useful.",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6140,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.4.2.2.",
    "orig_text": "This fallback chain SHOULD NOT use the deprecated SHA-1 hash\r\nalgorithm in general, but MAY do so if the client's advertisement\r\npermits it, and MUST NOT do so otherwise.",
    "correct_text": "This fullback chain MUST NOT use the deprecated SHA-1 hash,\r\nexcept if advertised by the client, in which case it MAY.",
    "notes": "The original text is difficult to read, eliminating the unnecessary \"SHOULD NOT\" seems to make it \r\neasier.",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6141,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.4.3",
    "orig_text": "   -  The context string",
    "correct_text": "   -  The context string (defined below)",
    "notes": null,
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6142,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.6.1.",
    "orig_text": "Clients MUST NOT cache tickets for longer than 7 days",
    "correct_text": "Clients MUST NOT use tickets for longer than 7 days",
    "notes": "\"MUST NOT cache\" is surely overly zealous and may unnecessarily result in non-compliant implementations",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6143,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.7",
    "orig_text": "As of TLS 1.3, servers are permitted to send the \"supported_groups\"\r\nextension to the client.",
    "correct_text": null,
    "notes": "It is unclear whether servers are permitted to send the \"supported_groups\" extension to \r\nthe client without solicitation, i.e., when the client does not first send the extension to the \r\nserver. Clarification would be useful.",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6144,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.2.8.",
    "orig_text": "Upon receipt of this extension in a HelloRetryRequest, the client\r\nMUST verify that...the selected_group field does not\r\ncorrespond to a group which was provided in the \"key_share\" extension\r\nin the original ClientHello.",
    "correct_text": "Upon receipt of this extension in a HelloRetryRequest, the client\r\nMUST verify that...a key share was not offered (in the \"key_share\" \r\nextension in the original ClientHello) for the group in the \r\nselected_group field.",
    "notes": "The original text requires knowledge of the \"key_share\" extension and is rather hard to read,\r\nthe proposed text should be easier to understand.",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6145,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.10.",
    "orig_text": "When a PSK is used and early data is allowed for that PSK",
    "correct_text": null,
    "notes": "I couldn't find restrictions that forbid early data for a PSK. Explaining where such restrictions\r\ncould exist would be useful. E.g., PSKs might be associated with data that forbids early data.",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6146,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.10.",
    "orig_text": "The TLS version number",
    "correct_text": "The selected TLS version number",
    "notes": null,
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6147,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.2.10.",
    "orig_text": "In order to accept early data, the server MUST have accepted a PSK\r\ncipher suite....In addition, it MUST verify that the\r\nfollowing values are the same as those associated with the\r\nselected PSK:\r\n\r\n...\r\n\r\n-  The selected cipher suite",
    "correct_text": null,
    "notes": "Accepting the \"PSK cipher suite\" surely implies the PSK is associated with the cipher suite, hence, \r\n\"The selected cipher suite\" can be dropped.",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6148,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.2.10",
    "orig_text": "The selected ALPN [RFC7301] protocol, if any",
    "correct_text": "The selected ALPN [RFC7301] protocol, if extension application_layer_protocol_negotiation is present",
    "notes": null,
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6150,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "Note that certificate-based client authentication is not available \r\nin PSK handshake flows (including 0-RTT). ",
    "correct_text": "Note that certificate-based client authentication is not available \r\nin PSK handshake flows (including 0-RTT), post-handshake \r\ncertificate-based client authentication is possible.",
    "notes": null,
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6151,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 4.4,
    "orig_text": "   | Post-     | ClientHello ... client  | client_application_traffic_ |\r\n   | Handshake | Finished +              | secret_N                    |\r\n   |           | CertificateRequest      |                             |",
    "correct_text": "   | Post-     | ClientHello ... client  | [sender]_application_traffic|\r\n   | Handshake | Finished +              | _secret_N                   |\r\n   |           | CertificateRequest      |                             |",
    "notes": null,
    "submit_date": "2020-04-30",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6152,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 4,
    "orig_text": "Clients MUST check for [\"supported_versions\"] prior to\r\nprocessing the rest of the ServerHello (although they will have to \r\nparse the ServerHello in order to read the extension). -- Section 4.2.1.\r\n\r\nUpon receipt of a HelloRetryRequest, the client MUST check the\r\nlegacy_version, legacy_session_id_echo, cipher_suite, and\r\nlegacy_compression_method as specified in Section 4.1.3 and then\r\nprocess the extensions, starting with determining the version using\r\n\"supported_versions\". -- Section 4.1.4\r\n\r\nUpon receiving a message with type server_hello, implementations MUST\r\nfirst examine the Random value... -- Section 4.1.3.\r\n",
    "correct_text": null,
    "notes": "These requirements are seemingly conflicting. I suspect checking for \"supported_versions\" must \r\ncome first, since that may influence subsequent steps, e.g., checking legacy_compression_method \r\nand the Random value. It doesn't seem to matter whether legacy_version, legacy_session_id_echo, \r\ncipher_suite, and legacy_compression_method are checked before the Random value, so it doesn't\r\nseem to matter which check is second and which is third. (Noting, as per one of my earlier reports,\r\ndated 28 Apr, Section 4.1.3 defines no checks for legacy_version nor legacy_compression_method. \r\nPerhaps the latter should be checked to be zero, aborting with alert illegal_parameter if it isn't, as per\r\nSection 4.1.2.)",
    "submit_date": "2020-05-01",
    "submitter_name": "Ben Smyth",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6204,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "E.1",
    "orig_text": "Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.",
    "correct_text": "Implementations MUST NOT combine external PSKs with certificate-based authentication of either client or the server. Future specifications MAY provide an extension to permit this. ",
    "notes": "The existing text can be misread as permitting this combination upon negotiation of the \"post_handshake_auth\" extension, which would be incorrect. [1] describes an attack that can occur based on this misinterpretation. The proposed text aims to make clear that a *new* extension is required for this combination. \r\n\r\n[1] https://link.springer.com/article/10.1007%2Fs11416-020-00352-0",
    "submit_date": "2020-06-03",
    "submitter_name": "Chris Wood",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6205,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.3.2",
    "orig_text": "   Servers which are authenticating with a PSK MUST NOT send the\r\n   CertificateRequest message in the main handshake, though they MAY\r\n   send it in post-handshake authentication (see Section 4.6.2) provided\r\n   that the client has sent the \"post_handshake_auth\" extension (see\r\n   Section 4.2.6).",
    "correct_text": "   Servers which are authenticating with a resumption PSK MUST NOT send the\r\n   CertificateRequest message in the main handshake, though they MAY\r\n   send it in post-handshake authentication (see Section 4.6.2) provided\r\n   that the client has sent the \"post_handshake_auth\" extension (see\r\n   Section 4.2.6).  Servers which are authenticating with an external PSK\r\n   MUST NOT send the CertificateRequest message either in the main handshake\r\n   or request post-handshake authentication. Future specifications MAY\r\n   provide an extension to permit this. ",
    "notes": "The lack of qualification on \"authenticating with a PSK\" implies that the statement applies equally to both external and resumption PSKs.  However, there are two conditions being governed: whether a certificate can be requested during the handshake, and whether a certificate can be requested post-handshake.  The latter of these requires different rules depending on the type of PSK.\r\n\r\nWe know from the analysis of resumption (see https://mailarchive.ietf.org/arch/msg/tls/TugB5ddJu3nYg7chcyeIyUqWSbA/) that combining a PSK handshake of either type with a client certificate is not safe.  Thus, the prohibition on CertificateRequest during the handshake applies equally to both resumption and external PSKs.\r\n\r\nFor post-handshake, Appendix E.1 already discusses the risks of combining PSKs with certificates, citing the same analysis as above.\r\n\r\n   [...]  It is unsafe to use certificate-based client\r\n   authentication when the client might potentially share the same\r\n   PSK/key-id pair with two different endpoints.\r\n\r\nFor this reason an external PSK is not safe to use with post-handshake authentication.  A resumption PSK does not have this property, so the same prohibition doesn't apply.\r\n\r\nSplitting the requirements as proposed makes this split clearer.",
    "submit_date": "2020-06-04",
    "submitter_name": "Martin Thomson",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6401,
    "doc-id": "RFC8446",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.6.2",
    "orig_text": "When the client has sent the \"post_handshake_auth\" extension (see\r\nSection 4.2.6), a server MAY request client authentication at any\r\ntime after the handshake has completed by sending a\r\nCertificateRequest message.  ",
    "correct_text": "When the client has sent the \"post_handshake_auth\" extension (see\r\nSection 4.2.6), a server MAY request client authentication during the \r\nmain handshake and/or at any time after the handshake has completed by \r\nsending a CertificateRequest message.  \r\n\r\n",
    "notes": "4.6.2 is ambiguous as to whether it forbids \"main handshake\" (mid-handshake) client \r\nauthentication when the client has sent  the \"post_handshake_auth\" extension. I think \r\nthe language would be stronger if it were really forbidden, and openssl s_server permits \r\nthis behavior and rfc8740 implies it as well.\r\n\r\nThe \"main handshake\" language is adopted from 4.3.2 but \"main\" could be dropped as \r\n\"handshake\" is not ambiguous in 1.3 due to no renegotiation.",
    "submit_date": "2021-01-20",
    "submitter_name": "Eric Covener",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
