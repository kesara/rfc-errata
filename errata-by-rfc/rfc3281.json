[
  {
    "errata_id": "1479",
    "doc-id": "RFC3281",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.4.6",
    "orig_text": "            SecurityCategory ::= SEQUENCE {\r\n                 type      [0]  IMPLICIT OBJECT IDENTIFIER,\r\n                 value     [1]  ANY DEFINED BY type\r\n            }",
    "correct_text": "           SecurityCategory ::= SEQUENCE {\r\n                 type      [0]  OBJECT IDENTIFIER,\r\n                 value     [1] EXPLICIT ANY DEFINED BY type\r\n            }",
    "notes": "It appears an error in the definition of SecurityCategory was introduced when it was taken from a module with EXPLICIT TAG default into a module with IMPLICIT TAG default.   In particular, the tag on the value MUST be EXPLICIT due to the ANY.  Otherwise the tag of the any would replace the value's tag.\r\n\r\nNote that extra IMPLICIT in the original text is merely extraneous (whereas the missing EXPLICIT is quite problematic).\r\n\r\nIt is also noted that clearance was NOT defined in X.501(1993), but X.500(1997).  However, X.501(2005) may be the best reference for clearance.",
    "submit_date": "2008-07-30",
    "submitter_name": "Kurt Zeilenga",
    "verifier_id": "112",
    "verifier_name": "Tim Polk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "302",
    "doc-id": "RFC3281",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.4.6",
    "orig_text": "   Clearance ::= SEQUENCE {\n           policyId            [0] OBJECT IDENTIFIER,\n           classList           [1] ClassList DEFAULT {unclassified},\n           securityCategories  [2] SET OF SecurityCategory OPTIONAL\n   }",
    "correct_text": "   Clearance ::= SEQUENCE {\n           policyId            OBJECT IDENTIFIER,\n           classList           ClassList DEFAULT {unclassified},\n           securityCategories  SET OF SecurityCategory OPTIONAL\n   }",
    "notes": "The differences in tagging arose due to an unnoticed technical corrigendum (TC-2) being applied to the X.501 document during preparation of RFC 3281. The X.501 format is the correct form and will be included in a future update of RFC 3281. Implementers SHOULD modify their decoding functions to accept either format and, even if claiming RFC 3281 conformance, SHOULD output the (correct) X.501 format pending the issuing of a corrected RFC at which point the incorrect RFC 3281 format will no longer be specified.",
    "submit_date": "2003-03-07",
    "submitter_name": "Stephen Farrell",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "303",
    "doc-id": "RFC3281",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.1",
    "orig_text": "             AttributeCertificateInfo ::= SEQUENCE {\n                  version              AttCertVersion  -- version is v2,",
    "correct_text": "             AttributeCertificateInfo ::= SEQUENCE {\n                  version              AttCertVersion,  -- version is v2,\n",
    "notes": "",
    "submit_date": "2004-08-26",
    "submitter_name": "Russ Housley",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "304",
    "doc-id": "RFC3281",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.1",
    "orig_text": "    The AC then contains the ciphertext inside its signed data.  The\n    EnvelopedData (id-envelopedData) ContentType is used, and the\n    content field will contain the EnvelopedData type.",
    "correct_text": "    Within EnvelopedData, the encapuslatedContentInfo identifies the\n    content type carried withing the ciphertext.  In this case, the \n    contentType field of encapsulatedContentInfo MUST contain\n    id-ct-attrCertEncAttrs, which has the following value:\n\n       attrCertEncAttrs OBJECT IDENTIFIER ::=\n             { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)\n\t     pkcs9(9)\n               id-smime(16) id-ct(1) 14 }\n",
    "notes": "\n",
    "submit_date": "2002-07-30",
    "submitter_name": "Russ Housley",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "710",
    "doc-id": "RFC3281",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.3.2",
    "orig_text": "   Note: [X.509-2000] defines the extension syntax as a \"SEQUENCE OF\r\n   Targets\".  Conforming AC issuer implementations MUST only produce one\r\n   \"Targets\" element.  Confirming AC users MUST be able to accept a\r\n   \"SEQUENCE OF Targets\".  If more than one Targets element is found in\r\n   an AC, the extension MUST be treated as if all Target elements had\r\n   been found within one Targets element.",
    "correct_text": "   Note: [X.509-2000] defines the extension syntax as a \"SEQUENCE OF\r\n   Targets\".  Conforming AC issuer implementations MUST only produce one\r\n   \"Targets\" element.  Conforming AC users MUST be able to accept a\r\n   \"SEQUENCE OF Targets\".  If more than one Targets element is found in\r\n   an AC, the extension MUST be treated as if all Target elements had\r\n   been found within one Targets element.",
    "notes": "Confirming -> Conforming",
    "submit_date": "2006-12-20",
    "submitter_name": "Gidon Moont",
    "verifier_id": "2",
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  }
]
