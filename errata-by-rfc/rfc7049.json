[
  {
    "errata_id": 3764,
    "doc-id": "RFC7049",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "2.4.2",
    "orig_text": "   C2                        -- Tag 2\r\n      29                     -- Byte string of length 9\r\n         010000000000000000  -- Bytes content",
    "correct_text": "   C2                        -- Tag 2\r\n      49                     -- Byte string of length 9\r\n         010000000000000000  -- Bytes content",
    "notes": "Major type 2, length 9 is encoded as 0x49, not 0x29.",
    "submit_date": "2013-10-24",
    "submitter_name": "Peter Occil",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3770,
    "doc-id": "RFC7049",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 3.6,
    "orig_text": "   ...\r\n   needed encoding (such as encoding \"0\" as 0b000_11101 followed by two\r\n   bytes of 0x00) as long as the application can decode an integer of\r\n   ...",
    "correct_text": "   ...\r\n   needed encoding (such as encoding \"0\" as 0b000_11001 followed by two\r\n   bytes of 0x00) as long as the application can decode an integer of\r\n   ...",
    "notes": "Additional information value for 2-byte unsigned integer is 25, which encodes as 0b11001.",
    "submit_date": "2013-10-29",
    "submitter_name": "Peter Klavins",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4294,
    "doc-id": "RFC7049",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "2.2.1",
    "orig_text": "   BF           -- Start indefinite-length map\r\n      63        -- First key, UTF-8 string length 3\r\n         46756e --   \"Fun\"\r\n      F5        -- First value, true\r\n      63        -- Second key, UTF-8 string length 3\r\n         416d74 --   \"Amt\"\r\n      21        -- -2\r\n      FF        -- \"break\"",
    "correct_text": "   BF           -- Start indefinite-length map\r\n      63        -- First key, UTF-8 string length 3\r\n         46756e --   \"Fun\"\r\n      F5        -- First value, true\r\n      63        -- Second key, UTF-8 string length 3\r\n         416d74 --   \"Amt\"\r\n      21        -- Second value, -2\r\n      FF        -- \"break\"",
    "notes": "This is only a break in phrasing consistency.  There is no technical error.",
    "submit_date": "2015-03-07",
    "submitter_name": "Eric Myhre",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4409,
    "doc-id": "RFC7049",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "  The sorting rules are:\r\n\r\n      *  If two keys have different lengths, the shorter one sorts\r\n         earlier;\r\n\r\n      *  If two keys have the same length, the one with the lower value\r\n         in (byte-wise) lexical order sorts earlier.",
    "correct_text": "  The sorting rules are:\r\n\r\n      *  If the major types are different, the one with the lower value\r\n          in numerical order sorts earlier.\r\n\r\n      *  If two keys have different lengths, the shorter one sorts\r\n         earlier;\r\n\r\n      *  If two keys have the same length, the one with the lower value\r\n         in (byte-wise) lexical order sorts earlier.",
    "notes": "As the rules are currently written,  The integer -257 would be sorted after the integer 16 because has a length of 2 rather than a length of 1.  First rule says shorter keys sort first.  However the text above says the sorting is based on the byte representation of the key.\n --VERIFIER NOTES-- \n   This report has been rejected because this is a change in documented behavior\r\nthat would require working groupconsensus.  That said, this was taken into account\r\nby the working group during the production of the updated version of RFC 7049.",
    "submit_date": "2015-07-06",
    "submitter_name": "Jim Schaad",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-07-17 15:07:10"
  },
  {
    "errata_id": 4963,
    "doc-id": "RFC7049",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "   same CBOR output, the following four rules would suffice:\r\n\r\n   o  Integers must be as small as possible.\r\n\r\n      *  0 to 23 and -1 to -24 must be expressed in the same byte as the\r\n         major type;\r\n\r\n      *  24 to 255 and -25 to -256 must be expressed only with an\r\n         additional uint8_t;\r\n\r\n      *  256 to 65535 and -257 to -65536 must be expressed only with an\r\n         additional uint16_t;\r\n\r\n      *  65536 to 4294967295 and -65537 to -4294967296 must be expressed\r\n         only with an additional uint32_t.\r\n\r\n   o  The expression of lengths in major types 2 through 5 must be as\r\n      short as possible.  The rules for these lengths follow the above\r\n      rule for integers.\r\n\r\n   o  The keys in every map must be sorted lowest value to highest.\r\n      Sorting is performed on the bytes of the representation of the key\r\n      data items without paying attention to the 3/5 bit splitting for\r\n      major types.  (Note that this rule allows maps that have keys of\r\n      different types, even though that is probably a bad practice that\r\n      could lead to errors in some canonicalization implementations.)\r\n      The sorting rules are:\r\n\r\n      *  If two keys have different lengths, the shorter one sorts\r\n         earlier;\r\n\r\n      *  If two keys have the same length, the one with the lower value\r\n         in (byte-wise) lexical order sorts earlier.\r\n\r\n   o  Indefinite-length items must be made into definite-length items.",
    "correct_text": "   same CBOR output, the following four rules would suffice:\r\n\r\n   1.  Integers must be as small as possible.\r\n\r\n      *  0 to 23 and -1 to -24 must be expressed in the same byte as the\r\n         major type;\r\n\r\n      *  24 to 255 and -25 to -256 must be expressed only with an\r\n         additional uint8_t;\r\n\r\n      *  256 to 65535 and -257 to -65536 must be expressed only with an\r\n         additional uint16_t;\r\n\r\n      *  65536 to 4294967295 and -65537 to -4294967296 must be expressed\r\n         only with an additional uint32_t.\r\n\r\n   2. The expression of lengths in major types 2 through 5 must be as\r\n      short as possible.  The rules for these lengths follow the above\r\n      rule for integers.\r\n\r\n   3. The expression of the tag in major type 6 must be as short as \r\n      possible.  The rules for the tag value follow the above rule for\r\n      integers.\r\n\r\n   4. The expression of a simple type must be as short as possible. The \r\n      rules for simple types follow the above rules for integers.\r\n\r\n   5. Indefinite-length items must be made into definite-length items.\r\n\r\n   6. The keys in every map must be sorted lowest value to highest.\r\n      Sorting is performed byte-for-byte on the binary representation\r\n      of the key data items, without restrictions on keys having a \r\n      common major/minor type.\r\n\r\n      If two keys of differing binary lengths are compared, the item \r\n      with the shortest length sorts first.\r\n\r\n      Note that this rule allows maps to have keys of different major \r\n      types, even though that may be considered a bad practice that\r\n      could lead to errors in some canonicalization implementations. \r\n      For example, negative integers may binary sort out of order\r\n      with respect to positive integers.\r\n\r\n",
    "notes": "Several recommended changes, some editorial some technical:\r\n\r\n- The items are numbered to indicate an appropriate order. This is recommended because converting items to minimal size and making indefinite-length items into definite length must be done before sorting map entries\r\n\r\n- Rules were added for reducing the size of tags (major type 6) and simple types (major type 7).\r\n\r\n- Within the sorting section for map entries:\r\n  - The original comment about 3/5 bit splitting was unclear, whether it was implying some transform was necessary before sorting the items. This was reworked to indicate that the keys were sorted by binary representation.\r\n  - The quoted note about mixed types is made a non-quoted comment. An example is given of negative and positive integers.\n --VERIFIER NOTES-- \n   This report has been rejected because this is a change in documented behavior\r\nthat would require working groupconsensus.  That said, this was taken into account\r\nby the working group during the production of the updated version of RFC 7049.",
    "submit_date": "2017-03-12",
    "submitter_name": "David Waite",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-07-17 15:07:50"
  },
  {
    "errata_id": 4964,
    "doc-id": "RFC7049",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.9,
    "orig_text": "*  If two keys have different lengths, the shorter one sorts\r\n         earlier;",
    "correct_text": "<removed>",
    "notes": "I would recommend this rule be struck for the following reasons, and a simple binary comparison regardless of length is used\r\n\r\n1. It does not affect sorting order of single type entries, if the other rules around using minimal size are followed. This is because the ranges for representable values based on the 5-bit additional information are consistently increasing. In particular, minimal sized non-negative integers will sort in numerical order in either case\r\n\r\n2. It does not affect text sorting. A block of text is length-prefixed already, which means that the bytes representing length will already sort shorter strings ahead of all longer strings\r\n\r\n3. Using a simple binary comparison will group a mixed-type map by major type. All string keys will be together, for instance. As an example, a 1-6 character string value today could sort in the middle of a group of integer keys (for sufficiently large integers)\r\n\r\n4. For keys which are arrays of items, the shortest length breaks the ability for sorted order to mean anything. For example, an [int x, int y] key will sort by x value then y value if straight binary comparison is used, but will sort in a different manner if length-based sorting is involved due to the potential for large `y`.\r\n\r\nThis is the use case which I personally am hitting, as my keys are composed of an array with the first element as epoch time.\r\n\r\n5. It is not necessary to deal with mixed-length values. Due to several factors including termination of indefinite length items, it is not possible to append binary data to a well-formed CBOR value to get a different well-formed CBOR value. Thus all well-formed keys, if compared byte-for-byte, *will* differ without the need to zero-pad the data.\n --VERIFIER NOTES-- \n   This report has been rejected because this is a change in documented behavior\r\nthat would require working groupconsensus.  That said, this was taken into account\r\nby the working group during the production of the updated version of RFC 7049.",
    "submit_date": "2017-03-12",
    "submitter_name": "David Waite",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-07-17 15:08:16"
  },
  {
    "errata_id": 5434,
    "doc-id": "RFC7049",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "E.6",
    "orig_text": "   |               |                         |                         |\r\n   | UBJSON        | 61 02 42 01 61 02 42 02 | 61 ff 42 01 61 02 42 02 |\r\n   |               | 42 03                   | 42 03 45                |\r\n   |               |                         |                         |\r\n",
    "correct_text": "   |               |                         |                         |\r\n   | UBJSON        | 5B 23 55 02 55 01 5B 23 | 5B 55 01 5B 55 02 55 03 |\r\n   |               | 55 02 55 02 55 03       | 5D 5D                   |\r\n   |               |                         |                         |\r\n",
    "notes": "According to UBJSON type specification available at\r\nhttp://ubjson.org/type-reference/ arrays are encoded with square-brackets '[' and ']', or with '[' followed by '#' to specify the element count.",
    "submit_date": "2018-07-22",
    "submitter_name": "LAMBERT David",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-07-17 15:09:04"
  },
  {
    "errata_id": 5763,
    "doc-id": "RFC7049",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 2.4,
    "orig_text": "A tag always applies to the item that is directly followed by it.",
    "correct_text": "A tag always applies to the item that directly follows it.",
    "notes": "The 'it' in the original text refers to the tag, so the sentence reads that the tag follows the item.  In fact, the item follows the tag.",
    "submit_date": "2019-06-26",
    "submitter_name": "John Visosky",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-07-17 15:09:25"
  },
  {
    "errata_id": 5917,
    "doc-id": "RFC7049",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "simple(24)                   | 0xf818  ",
    "correct_text": null,
    "notes": "This example violates RFC 7049 section 2.3 Floating-Point Numbers and Values with No Content.  \r\n\r\nThe incorrect example in Appendix A clearly uses a value <32 which is not allowed.\r\n\r\nFirst, RFC 7049 section 2.3 has a table that shows:\r\n | 24          | Simple value (value 32..255 in following byte)   |\r\n\r\nNext, RFC 7049 section 2.3 says:\r\nAs with all other major types, the 5-bit value 24 signifies a single-\r\nbyte extension: it is followed by an additional byte to represent the\r\nsimple value.  (To minimize confusion, only the values 32 to 255 are\r\nused.)\r\n\r\nWikipedia is also currently incorrect by having an interpretation based on the incorrect example from RFC 7049 Appendix A instead of the text from RFC 7049 Section 2.3.\r\n\r\nCredits: This problem was first reported at https://github.com/fxamacker/cbor/issues/46",
    "submit_date": "2019-11-24",
    "submitter_name": "Faye Amacker",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-11-24 01:28:32"
  }
]
