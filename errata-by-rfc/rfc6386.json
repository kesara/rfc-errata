[
  {
    "errata_id": "3395",
    "doc-id": "RFC6386",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "20.16./p.239",
    "orig_text": "   void\r\n   vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,\r\n                                unsigned int            partition,\r\n                                unsigned int            row,\r\n                                unsigned int            start_col,\r\n                                unsigned int            num_cols)\r\n   {\r\n       struct token_decoder *tokens = &ctx->tokens[partition];\r\n       short              coeffs = tokens->coeffs + 25 * 16 * start_col;",
    "correct_text": "   void\r\n   vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,\r\n                                unsigned int            partition,\r\n                                unsigned int            row,\r\n                                unsigned int            start_col,\r\n                                unsigned int            num_cols)\r\n   {\r\n       struct token_decoder *tokens = &ctx->tokens[partition];\r\n       short              *coeffs = tokens->coeffs + 25 * 16 * start_col;",
    "notes": "It seems \"coeffs\" should be a pointer to a short instead of a short.",
    "submit_date": "2012-10-30",
    "submitter_name": "Thomas Butter",
    "verifier_id": "126",
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5534",
    "doc-id": "RFC6386",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "19.1",
    "orig_text": "unsigned char *c = pbi->source;\r\nunsigned int tmp;\r\n\r\ntmp = (c[2] << 16) | (c[1] << 8) | c[0];\r\n\r\nkey_frame = tmp & 0x1;\r\nversion = (tmp >> 1) & 0x7;\r\nshow_frame = (tmp >> 4) & 0x1;\r\nfirst_part_size = (tmp >> 5) & 0x7FFFF;",
    "correct_text": "unsigned char *c = pbi->source;\r\nunsigned int tmp;\r\n\r\ntmp = (c[2] << 16) | (c[1] << 8) | c[0];\r\n\r\nkey_frame = !(tmp & 0x1);\r\nversion = (tmp >> 1) & 0x7;\r\nshow_frame = (tmp >> 4) & 0x1;\r\nfirst_part_size = (tmp >> 5) & 0x7FFFF;",
    "notes": "In section 9.1, where the frame tag is described, the field for the key frame is defined as \"A 1-bit frame type (0 for key frames, 1 for interframes).\"\r\n\r\nThe code block in section 19.1 interprets the bit in the opposite way: 1 for key frames and 0 for interframes.",
    "submit_date": "2018-10-18",
    "submitter_name": "Ard Oerlemans",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "7370",
    "doc-id": "RFC6386",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "19.1",
    "orig_text": "The start_code is a constant 3-byte pattern having value 0x9d012a.",
    "correct_text": "The start_code is a constant 3-byte pattern having value 0x2a019d.",
    "notes": "The bytes in the file are 9D 01 2A, but if they are read little-endian like `tmp = (c[2] << 16) | (c[1] << 8) | c[0];` as is done for frame_tag just before, then start_code will end up as 0x2a019d in an uint32_t.\r\n\r\nAlternatively, it could say \"...having value 0x9d 0x01 0x2a\".",
    "submit_date": "2023-02-25",
    "submitter_name": "Nico Weber",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
