[
  {
    "errata_id": 4358,
    "doc-id": "RFC7233",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 4,
    "orig_text": "The 206 (Partial Content) status code indicates that the server is\r\nsuccessfully fulfilling a range request for the target resource by\r\ntransferring one or more parts of the selected representation that\r\ncorrespond to the satisfiable ranges found in the request's Range\r\nheader field (Section 3.1).",
    "correct_text": "The 206 (Partial Content) status code indicates that the server is\r\nsuccessfully fulfilling a range request for the target resource by\r\ntransferring one or more parts of the selected representation that\r\ncorrespond to the satisfiable ranges found in the request's Range\r\nheader field (Section 3.1). A response may chose to satisfy only\r\npart of a requested range.\r\n",
    "notes": "Firefox and Chrome already behave as if the \"Corrected Text\"\r\nstatement is true.\r\n\r\nIt may be desirable if for example a user returns to a\r\nhtml5 video with auto play, pauses the video and is only\r\ninterested in responding to a comment on the page. In this example\r\nit would be unnecessarily costly to transfer the whole 128GB when\r\nthe user only consumes a few MB.\r\n\r\nAlternative: maybe it should only be true if last-byte-pos is\r\nabsent.\r\n\r\n----- Verifier Notes -----\r\nThe reporter is uncertain of the meaning and asks that it be clarified, one way or the other.  A future update of the document might consider clarifying wording.",
    "submit_date": "2015-05-07",
    "submitter_name": "Tim",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4391,
    "doc-id": "RFC7233",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 2.1,
    "orig_text": "   If a valid byte-range-set includes at least one byte-range-spec with\r\n   a first-byte-pos that is less than the current length of the\r\n   representation, or at least one suffix-byte-range-spec with a\r\n   non-zero suffix-length, then the byte-range-set is satisfiable.\r\n   Otherwise, the byte-range-set is unsatisfiable.\r\n",
    "correct_text": "   If a valid byte-range-set includes at least one byte-range-spec with\r\n   a first-byte-pos that is less than the current length of the\r\n   representation, or at least one suffix-byte-range-spec with a\r\n   non-zero suffix-length and the current length of the representation\r\n   is non-zero, then the byte-range-set is satisfiable. Otherwise, the\r\n   byte-range-set is unsatisfiable.\r\n",
    "notes": "Asking for a range that includes trailing bytes (e.g., Range: bytes=-1) when the entity is zero bytes is, as stated here, satisfiable, and yet the service would be forced to yield a 206 code and there is no valid representation of Content-Range header, since you cannot specify a range with no length using the byte range type, the none range type is specified in section 2.3 with a meaning for Accept-Ranges only, and there are no other acceptable ranges in the IANA registry.\r\n\r\nThe alternative would be that we could overload the use of the none range and return 206 with Content-Length: 0, Content-Range: none for these requests for final bytes.\n --VERIFIER NOTES-- \nIt also says, in the same section:\r\n\r\n   If the selected representation is shorter than the specified\r\n   suffix-length, the entire representation is used.\r\n\r\nSo the response for the posited request is 200 (not 206).",
    "submit_date": "2015-06-11",
    "submitter_name": "Nathan Herring",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4472,
    "doc-id": "RFC7233",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 2.1,
    "orig_text": "   o  The first and last bytes only (bytes 0 and 9999):\r\n\r\n        bytes=0-0,-1",
    "correct_text": "   o  The first and last bytes only (bytes 0 and 9999):\r\n\r\n        bytes=0-1,-1",
    "notes": "If the first byte is requested the offset must be 1.\n --VERIFIER NOTES-- \nThe reporter has retracted this after more testing, saying that \"The sentence 'the byte positions specified are inclusive' seems to explain it,\" though he thinks it could be explained more clearly and directly.",
    "submit_date": "2015-09-13",
    "submitter_name": "Florian Best",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4664,
    "doc-id": "RFC7233",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 4.4,
    "orig_text": "The 416 (Range Not Satisfiable) status code indicates that none of\r\nthe ranges in the request's Range header field (Section 3.1) overlap\r\nthe current extent of the selected resource or that the set of ranges\r\nrequested has been rejected due to invalid ranges or an excessive\r\nrequest of small or overlapping ranges.",
    "correct_text": "The 416 (Range Not Satisfiable) status code indicates that none of\r\nthe ranges in the request's Range header field (Section 3.1) overlap\r\nthe current extent of the selected representation or that the set of\r\nranges requested has been rejected due to invalid ranges or an excessive\r\nrequest of small or overlapping ranges.",
    "notes": "The overlap may depend on the representation, not only the resource, as is the case with byte ranges.",
    "submit_date": "2016-04-13",
    "submitter_name": "Amichai Rothman",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4665,
    "doc-id": "RFC7233",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 3.1,
    "orig_text": null,
    "correct_text": "If all of the preconditions are true and the target representation\r\nlength is zero, the server SHOULD send a 200 (OK) response.",
    "notes": "An empty representation is unsatisfiable according to section 2.1, but not unsatisfiable according to section 4.4 if the first-byte-pos is zero. An empty 200 response is the simplest solution to this contradiction, since it is a valid response anyway (if the server chooses to ignore the Range header), clients already handle it properly, it provides all necessary information to the client, and stating it explicitly can prevent subtle edge-case pitfalls in both the RFC and its implementations.\n --VERIFIER NOTES-- \n Mark Nottingham: this is not an erratum. Please raise an issue here:\r\n <https://github.com/httpwg/http11bis/issues>",
    "submit_date": "2016-04-13",
    "submitter_name": "Amichai Rothman",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4681,
    "doc-id": "RFC7233",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 2.1,
    "orig_text": "byte-range-set  = 1#( byte-range-spec / suffix-byte-range-spec )\r\n",
    "correct_text": "byte-range-set = *( \",\" OWS ) ( byte-range-spec /\r\n    suffix-byte-range-spec ) *( OWS \",\" [ OWS ( byte-range-spec /\r\n    suffix-byte-range-spec ) ] )\r\n",
    "notes": "The document contains two ABNF definitions for \"byte-range-set\".  They appear in Section 2.1 \"Byte Ranges\" and Appendix D \"Collected ABNF\".\r\n\r\nThe two definitions are different.  It seems like the definition in Appendix D is the correct one.\n --VERIFIER NOTES-- \nAlexey: As per comment from Julian: \"Both are correct. See first sentence of Appendix D.\"",
    "submit_date": "2016-04-29",
    "submitter_name": "Kannan Goundan",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4682,
    "doc-id": "RFC7233",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 2.1,
    "orig_text": "byte-range-set= 1#( byte-range-spec / suffix-byte-range-spec )",
    "correct_text": "According to the \"1#element\" rule, the expansion would be:\r\n\r\n    byte-range-set = ( byte-range-spec /\r\n        suffix-byte-range-spec ) *( OWS \",\" OWS ( byte-range-spec /\r\n        suffix-byte-range-spec ) )\r\n\r\nBut Appendix D has the definition:\r\n\r\n    byte-range-set = *( \",\" OWS ) ( byte-range-spec /\r\n        suffix-byte-range-spec ) *( OWS \",\" [ OWS ( byte-range-spec /\r\n        suffix-byte-range-spec ) ] )\r\n",
    "notes": "This is a followup to my original report: <http://www.rfc-editor.org/errata_search.php?rfc=7233&eid=4681>\r\n\r\nMy original report was incorrect because I didn't notice the difference between \"1*element\" and \"1#element\".  Thanks to Julian Reschke for pointing this out to me.\r\n\r\nAfter looking up the \"1#element\" rule <https://tools.ietf.org/html/rfc7230#section-7>, it looks like Section 2.1 and Appendix D are more similar, but not exactly equivalent.\r\n\r\nThe Appendix D version of the rule seems to allow extra commas and OWS.  \r\nI'm trying to write strict parsing code for this header and am not sure which definition to follow.\r\n\r\nP.S. I hope I didn't screw up again.  I apologize for wasting your time (again) if I did.\n --VERIFIER NOTES-- \n See HTTPBIS mailing list discussion.",
    "submit_date": "2016-05-03",
    "submitter_name": "Kannan Goundan",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4707,
    "doc-id": "RFC7233",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "Appendix C",
    "orig_text": "The following core rules are included by reference, as defined in\r\nAppendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return),\r\nCRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double\r\nquote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any\r\n8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII\r\ncharacter).",
    "correct_text": "The following core rules are included by reference, as defined in\r\nAppendix B.1 of [RFC5234]: ALPHA (letters), CHAR (single character),\r\nCR (carriage return),\r\nCRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double\r\nquote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any\r\n8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII\r\ncharacter).",
    "notes": "CHAR is used in Section 4.2 but not mentioned here.",
    "submit_date": "2016-06-09",
    "submitter_name": "Julian Reschke",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5474,
    "doc-id": "RFC7233",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.4.",
    "orig_text": "For byte ranges, failing to overlap the current extent means that the\r\n   first-byte-pos of all of the byte-range-spec values were greater than\r\n   the current length of the selected representation.",
    "correct_text": "For byte ranges, failing to overlap the current extent means that the\r\n   first-byte-pos of all of the byte-range-spec values were greater than\r\n   or equal to the current length of the selected representation.\r\n   ^^^^^^^^^^^",
    "notes": "If the length of the representation is 500 bytes, then the range of the entire representation is 0-499. Then a range starting at byte position 500 fails to overlap the representation.",
    "submit_date": "2018-08-21",
    "submitter_name": "Kalin Gyokov",
    "verifier_id": 116,
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5620,
    "doc-id": "RFC7233",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 4.2,
    "orig_text": "Content-Range       = byte-content-range\r\n                    / other-content-range\r\n\r\nother-content-range = other-range-unit SP other-range-resp\r\nother-range-resp    = *CHAR",
    "correct_text": null,
    "notes": "Due to the loose definition of \"other-content-range\" invalid \"byte content range\" values are possible.\r\n\r\nFor example, following invalid header value is not valid according to \"byte-content-range\" (as \"complete-length\" or \"*\" is missing) but is yet allowed by \"other-content-range\".\r\n\r\nContent-Range: bytes 42-1233/\r\n\r\nThe problem might be solved by excluding \"bytes-unit\" in \"other-range-unit\".",
    "submit_date": "2019-02-01",
    "submitter_name": "Armin Abfalterer",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-11-12 17:13:18"
  }
]
