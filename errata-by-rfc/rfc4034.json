[
  {
    "errata_id": "1062",
    "doc-id": "RFC4034",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "6.2",
    "orig_text": "   3.  if the type of the RR is NS, MD, MF, CNAME, SOA, MB, MG, MR, PTR,\r\n       HINFO, MINFO, MX, HINFO, RP, AFSDB, RT, SIG, PX, NXT, NAPTR, KX,\r\n       SRV, DNAME, A6, RRSIG, or NSEC, all uppercase US-ASCII letters in\r\n       the DNS names contained within the RDATA are replaced by the\r\n       corresponding lowercase US-ASCII letters;",
    "correct_text": "[not supplied]",
    "notes": "Compare with RFC 3597 (section 7):\r\n\r\n   \"As a courtesy to implementors, it is hereby noted that the complete\r\n   set of such previously published RR types that contain embedded\r\n   domain names, and whose DNSSEC canonical form therefore involves\r\n   downcasing according to the DNS rules for character comparisons,\r\n   consists of the RR types NS, MD, MF, CNAME, SOA, MB, MG, MR, PTR,\r\n   HINFO, MINFO, MX, HINFO, RP, AFSDB, RT, SIG, PX, NXT, NAPTR, KX, SRV,\r\n   DNAME, and A6.\"\r\n\r\nAlmost exactly the same list.  One HINFO too much is no issue,\r\nbut if this actually should be TXT it's a real typo.\r\n\r\nneither TXT nor HINFO contain domain names in RDATA, so it's a bug in both\r\nRFC 3597 and 4034, although one that doesn't hurt. One could also argue that the list lacks NSAP-PTR, but then that's as obsolete as MD ans MF.",
    "submit_date": "2005-09-13",
    "submitter_name": "Peter Koch",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "193",
    "doc-id": "RFC4034",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "In Appendix B.1, it says: ",
    "orig_text": "                                                              For a\n   DNSKEY RR with algorithm 1, the key tag is defined to be the most\n   significant 16 bits of the least significant 24 bits in the public\n   key modulus (in other words, the 4th to last and 3rd to last octets\n   of the public key modulus).",
    "correct_text": "                                                              For a\n   DNSKEY RR with algorithm 1, the key tag is defined to be the most\n   significant 16 bits of the least significant 24 bits in the public\n   key modulus (in other words, the 3rd to last and 2nd to last octets\n   of the public key modulus).\n",
    "notes": "",
    "submit_date": "2005-06-21",
    "submitter_name": "Donald E. Eastlake III",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2681",
    "doc-id": "RFC4034",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "B",
    "orig_text": "   The key tag is the same for all DNSKEY algorithm types except\r\n   algorithm 1 (please see Appendix B.1 for the definition of the key\r\n   tag for algorithm 1).  The key tag algorithm is the sum of the wire\r\n   format of the DNSKEY RDATA broken into 2 octet groups.  First, the\r\n   RDATA (in wire format) is treated as a series of 2 octet groups.\r\n   These groups are then added together, ignoring any carry bits.\r\n",
    "correct_text": "   The key tag is the same for all DNSKEY algorithm types except\r\n   algorithm 1 (please see Appendix B.1 for the definition of the key\r\n   tag for algorithm 1).  The key tag algorithm is the sum of the wire\r\n   format of the DNSKEY RDATA broken into 2 octet groups.  First, the\r\n   RDATA (in wire format) is treated as a series of 2 octet groups.\r\n   These groups are then added together with at least 32-bit precision,\r\n   retaining any carry bits. The carry bits are then added to the result,\r\n   and finally, only the lower 16 bits of the result are used as the key \r\n   tag.\r\n\r\n",
    "notes": "This change comes from the example implementation. The accumulator, ac, is required (\"assumed\") to be 32-bits or larger, and the carry bits are added to the accumulator before returning:\r\n\r\n    ac += (ac >> 16) & 0xFFFF;",
    "submit_date": "2011-01-05",
    "submitter_name": "Guillaume Bailey",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2824",
    "doc-id": "RFC4034",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "3.1.3",
    "orig_text": "   The value of the Labels field MUST NOT count either the null (root)\r\n   label that terminates the owner name or the wildcard label (if\r\n   present).",
    "correct_text": "   The value of the Labels field MUST NOT count either the null (root)\r\n   label that terminates the owner name or the leftmost label if\r\n   it is a wildcard.",
    "notes": "In RFC 4035, section 2.2, describing the same count uses this: ... \"and not counting the leftmost label if it is a wildcard\" to omit the leading wildcard label.  (In 4034, the wildcard label is defined as \"*\" earlier in the same problematic section.)\r\n\r\nThe text in 4034 could be confused with having to count \"wildcard labels\" in the middle of a name, such as in name.*.tld.  The reason for suggesting this errata is for compliance considerations.\n --VERIFIER NOTES-- \nAll wildcard labels start with * in the leftmost label. No other kind of wildcard label exists.\r\n\r\nFrom RFC 1034:\r\n\r\n4.3.3. Wildcards\r\n\r\nIn the previous algorithm, special treatment was given to RRs with owner\r\nnames starting with the label \"*\".\r\n",
    "submit_date": "2011-06-06",
    "submitter_name": "Edward Lewis",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3045",
    "doc-id": "RFC4034",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "Updates",
    "orig_text": "Updates: 1034, 1035, 2136, 2181, 2308, 3225,                   M. Larson\r\n         3007, 3597, 3226                                       VeriSign\r\n",
    "correct_text": "Updates: 1034, 1035, 2136, 2181, 2308, 3225,                   M. Larson\r\n         3597, 3226                                             VeriSign\r\n",
    "notes": "4033, 4034 and 4035 all list 3007 as being updated but none do so.",
    "submit_date": "2011-12-07",
    "submitter_name": "Mark Andrews",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4552",
    "doc-id": "RFC4034",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "Appendix B",
    "orig_text": "These groups are then added together, ignoring any carry bits.",
    "correct_text": "These groups are then added together with at least 32-bit precision,\r\nretaining any carry bits.\r\nThe carry bits are then added to the result, and finally, only the lower\r\n16 bits of the result are used as the key tag. Note that this means any\r\ncarries generated during the addition of the carry bits are ignored.\r\nThis, in turn, means that the keytag calculation is often the same as\r\nreduction modulo 65535, but not always.\r\n",
    "notes": "Errata 2681 already proposes a fix to Appendix B, however the proposed fix is not quite clear. The first part of the corrected text is from 2681.\r\n\r\nIts worth pointing this out because a naive analysis says in fact the keytag is exactly the same as reduction modulo 65535, and this has already wasted a fair amount of time.\r\n\r\nIt is also worth pointing out, perhaps, that this is a poor choice of algorithm for this particular application as it interacts badly with the properties of keys.",
    "submit_date": "2015-12-04",
    "submitter_name": "Ben Laurie",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  }
]
