[
  {
    "errata_id": 2197,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.5.",
    "orig_text": "A time field is an unsigned four-octet number containing the number\r\nof seconds elapsed since midnight, 1 January 1970 UTC.\r\n",
    "correct_text": "A time field is an unsigned four-octet number containing the number\r\nof seconds elapsed since midnight, 1 January 1970 UTC, ignoring leap\r\nseconds.",
    "notes": "And I did not yet talk about relativity theory.\n --VERIFIER NOTES-- \nThe OpenPGP time is an integer denoting UTC time. An implementation is free to display with or without leap seconds just as it might display said time in a time zone.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2198,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.7.1.3.",
    "orig_text": "Initially, one or more hash contexts are set up as with the other S2K\r\nalgorithms, depending on how many octets of key data are needed.\r\nThen the salt, followed by the passphrase data, is repeatedly hashed\r\nuntil the number of octets specified by the octet count has been\r\nhashed.",
    "correct_text": "Initially, one or more hash contexts are set up as with the other S2K\r\nalgorithms, depending on how many octets of key data are needed.\r\nThen the concatenation of salt and passphrase data is repeated\r\nsufficiently often and concatenated. The concatenation is truncated\r\nto the number of octets specified by the octet count. The truncated\r\nconcatenation is hashed.",
    "notes": "Did I get it right? If not, clearify it.\r\nThere are a lot of interpretations of the fuzzy instruction.\r\nE.g. it could be repeat{data:=truncate(concatenate(hash(data)))} until\r\nthe octet count is exceeded. And it is still unclear weather you have to\r\ncount for each hash context separately and weather you have to count the\r\npreloads, too.\n --VERIFIER NOTES-- \nSubmitter does not even know if the erratum is correct.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2199,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "3.7.2.1.",
    "orig_text": "For compatibility, when an S2K specifier is used, the special value\r\n254 or 255 is stored in the position where the hash algorithm octet\r\nwould have been in the old data structure.  This is then followed\r\nimmediately by a one-octet algorithm identifier, and then by the S2K\r\nspecifier as encoded above.",
    "correct_text": "For compatibility, when an S2K specifier is used, the special value\r\n254 or 255 is stored in the position where the cipher algorithm octet\r\nwould have been in the old data structure.  This is then followed\r\nimmediately by a one-octet cipher algorithm identifier, and then by\r\nthe S2K specifier as encoded above.",
    "notes": "The paragraph before says:\r\nOlder versions of PGP just stored a cipher algorithm octet preceding\r\nthe secret data or a zero to indicate that the secret data was\r\nunencrypted.  The MD5 hash function was always used to convert the\r\npassphrase to a key for the specified cipher algorithm.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2200,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "3.7.2.1.",
    "orig_text": "This last possibility, the cipher algorithm number with an implicit\r\nuse of MD5 and IDEA, is provided for backward compatibility;",
    "correct_text": "This last possibility, the cipher algorithm number with an implicit\r\nuse of MD5, is provided for backward compatibility;",
    "notes": "The cipher algorithm is determined by the number. There is no implicit\r\nuse of IDEA.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2201,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.2.",
    "orig_text": "   The first octet of the packet header is called the \"Packet Tag\".  It\r\n   determines the format of the header and denotes the packet contents.\r\n   The remainder of the packet header is the length of the packet.\r\n   ...\r\n              +---------------+\r\n         PTag |7 6 5 4 3 2 1 0|\r\n              +---------------+\r\n         Bit 7 -- Always one\r\n         Bit 6 -- New packet format if set",
    "correct_text": "   The first octet of the packet header encodes the packet format and\r\n   the \"Packet Tag\".  It determines the format of the header and denotes\r\n   the packet contents. The remainder of the packet header is the length\r\n   of the packet body.\r\n   ...\r\n              +---------------+\r\n              |7 6 5 4 3 2 1 0|\r\n              +---------------+\r\n         Bit 7 -- Always one\r\n         Bit 6 -- New packet format if set",
    "notes": "Only a part of the first octet (depending on the packet format, i.e.\r\ndepending on bit 6 of the first octet) is the Packet Tag.\r\nThe packet consists of header and body. The encoded length is the length\r\nof the packet body.\n --VERIFIER NOTES-- \nThe suggestion is incorrect. The first octet of the header is called the packet tag. The packet tag contains other information besides tag information, but it is nonetheless called (and has always been called) the packet tag.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2202,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.4.1.",
    "orig_text": "   0 - The packet has a one-octet length.  The header is 2 octets long.\r\n\r\n   1 - The packet has a two-octet length.  The header is 3 octets long.\r\n\r\n   2 - The packet has a four-octet length.  The header is 5 octets long.",
    "correct_text": "   0 - The packet body has a one-octet length.  The header is 2 octets\r\n       long.\r\n\r\n   1 - The packet body has a two-octet length.  The header is 3 octets\r\n       long.\r\n\r\n   2 - The packet body has a four-octet length.  The header is 5 octets\r\n       long.",
    "notes": "The packet consists of header and body. The encoded length is the length\r\nof the packet body.\n --VERIFIER NOTES-- \nThe language is clear in the document. The Body Length refers to the length of the body. Colloquially, the document calls this the packet length, but OpenPGP is hardly unique in being a TLV record system in which the length is the length of the value, not of the Tag, Length, and Value.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2203,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.4.2.",
    "orig_text": "   1. A one-octet Body Length header encodes packet lengths of up to 191\r\n      octets.\r\n\r\n   2. A two-octet Body Length header encodes packet lengths of 192 to\r\n      8383 octets.\r\n\r\n   3. A five-octet Body Length header encodes packet lengths of up to\r\n      4,294,967,295 (0xFFFFFFFF) octets in length.  (This actually\r\n      encodes a four-octet scalar number.)\r\n\r\n   4. When the length of the packet body is not known in advance by the\r\n      issuer, Partial Body Length headers encode a packet of\r\n      indeterminate length, effectively making it a stream.",
    "correct_text": "   1. A one-octet Body Length header encodes packet body lengths of up\r\n      to 191 octets.\r\n\r\n   2. A two-octet Body Length header encodes packet body lengths of 192\r\n      to 8383 octets.\r\n\r\n   3. A five-octet Body Length header encodes packet body lengths of up\r\n      to 4,294,967,295 (0xFFFFFFFF) octets in length.  (This actually\r\n      encodes a four-octet scalar number.)\r\n\r\n   4. When the length of the packet body is not known in advance by the\r\n      issuer, Partial Body Length headers encode a packet of\r\n      indeterminate length, effectively making it a stream.",
    "notes": "The packet consists of header and body. The encoded length is the length\r\nof the packet body.\n --VERIFIER NOTES-- \nThe language is clear in the document. The Body Length refers to the length of the body. Colloquially, the document calls this the packet length, but OpenPGP is hardly unique in being a TLV record system in which the length is the length of the value, not of the Tag, Length, and Value.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2204,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.1.",
    "orig_text": "   The recipient of the message finds a session key that is encrypted\r\n   to their public key, decrypts the session key, and then uses the\r\n   session key to decrypt the message.",
    "correct_text": "   The recipient of the message finds a Public-Key Encrypted Session Key\r\n   packet that contains the session key encrypted with the recipient's\r\n   public key, decrypts the session key, and then uses the session key\r\n   to decrypt the message.",
    "notes": "There is only one session key, the session key, not a session key.\r\nThe recipient is singular.\r\nEncrypted with public key, will be decrypted with secret key. Encrypted\r\n(with the public key) to some cipher.\n --VERIFIER NOTES-- \nThe suggestion is more precise, but harder to read.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2205,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.1.",
    "orig_text": "   The value \"m\" in the above formulas is derived from the session key\r\n   as follows.  First, the session key is prefixed with a one-octet\r\n   algorithm identifier that specifies the symmetric encryption\r\n   algorithm used to encrypt the following Symmetrically Encrypted Data\r\n   Packet.  Then a two-octet checksum is appended, which is equal to the\r\n   sum of the preceding session key octets, not including the algorithm\r\n   identifier, modulo 65536.  This value is then encoded as described in\r\n   PKCS#1 block encoding EME-PKCS1-v1_5 in Section 7.2.1 of [RFC3447] to\r\n   form the \"m\" value used in the formulas above.  See Section 13.1 of\r\n   this document for notes on OpenPGP's use of PKCS#1.",
    "correct_text": "?",
    "notes": "That is how to derive m from the session key and the algorithm\r\nidentifier.\r\nBut how to derive the session key and the algorithm identifier from m?\n --VERIFIER NOTES-- \nNot actionable. No actual erratum.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2206,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "5.1.",
    "orig_text": "A Public-Key Encrypted Session Key packet holds the session key used \r\nto encrypt a message.",
    "correct_text": "A Public-Key Encrypted Session Key (PKESK) packet holds the session \r\nkey used to encrypt a message.",
    "notes": "The acronym PKESK is not defined.\r\n\r\nTweaked the suggestion to reword the 1st sentence in 5.1 to define it.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2207,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.",
    "orig_text": "   Note that if an implementation is creating an encrypted and signed\r\n   message that is encrypted to a V3 key, it is reasonable to create a\r\n   V3 signature.",
    "correct_text": "   Note that if an implementation is creating an encrypted and signed\r\n   message that is encrypted with a V3 key, it is reasonable to create a\r\n   V3 signature.",
    "notes": "Encrypted with a key to some cipher.\n --VERIFIER NOTES-- \nI think we can accept that encrypting implicitly means there’s a cipher involved.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2208,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "5.2.1.",
    "orig_text": "   This signature is a statement by a signing subkey, indicating that\r\n   it is owned by the primary key and subkey.",
    "correct_text": "   This signature is a statement by a signing subkey, indicating that\r\n   it is owned by the primary key.",
    "notes": "The subkey does not own itself.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2209,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.2.",
    "orig_text": "     - One-octet length of following hashed material.  MUST be 5.\r\n\r\n         - One-octet signature type.\r\n\r\n         - Four-octet creation time.",
    "correct_text": "     - Six-octet with the following three items.\r\n\r\n         - One-octet length of the remaining two items which are\r\n           included in the hash.  MUST be 5.\r\n\r\n         - One-octet signature type.\r\n\r\n         - Four-octet creation time.",
    "notes": "It is not the lenght of hashed material, but it is the length of the\r\nnext two items, which are included in the hash. And these three items\r\nbelong together and have six-octet length.\n --VERIFIER NOTES-- \nErratum is incorrect.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2210,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.2.",
    "orig_text": "        - Two-octet field holding left 16 bits of signed hash value.",
    "correct_text": "        - Two-octet field holding the first 16 bits of signed hash\r\n          value.",
    "notes": "left is misleading. It could be remaining (from leave). And there are\r\ncultures where the last letters of a line are on the left side.\r\nThe convention is high digit before (not left of) low digit (which may\r\nbe odd for Arabs).\n --VERIFIER NOTES-- \nThe erratum makes good point that “left” is used where “first” or “high-order” might have been a better term. However, given that we know that we use Network Byte Order, “left” is a reasonable synonym for “first.” The IETF works in English and NBO; the comments about Arabs are well-taken, but pedantic and add no value.\r\n\r\nAdditionally, a search of other RFCs shows that we are not alone in using “left” to mean “high-order.” While this may be idiomatic rather than well-defined, our research shows it’s an IETF idiom as much as an OpenPGP idiom.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2211,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.2.",
    "orig_text": "   The details of the calculation are different for DSA signatures than\r\n   for RSA signatures.",
    "correct_text": "   The details of the calculation are different for DSA signatures from\r\n   that for RSA signatures.",
    "notes": "different from, not different than\n --VERIFIER NOTES-- \nOur research shows that this is a matter of opinion -- in US English grammar, the “different than” is acceptable this way. Jon prefers “different from” (the suggested erratum) and David “different than.” Thus our agreed resolution is to reject, as this is debate over usage, not an actual erratum.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2212,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.3.",
    "orig_text": "     - Two-octet field holding the left 16 bits of the signed hash\r\n       value.\r\n   ...\r\n   The left 16 bits of the hash are included in the Signature packet to\r\n   provide a quick test to reject some invalid signatures.",
    "correct_text": "     - Two-octet field holding the high 16 bits of the signed hash\r\n       value.\r\n   ...\r\n   The high 16 bits (first two octets) of the hash are included in the\r\n   Signature packet to provide a quick test to reject some invalid\r\n   signatures.",
    "notes": "Use exactly the sentence from 5.2.2.\r\n\r\nleft is misleading. It could be remaining (from leave). And there are\r\ncultures where the last letters of a line are on the left side.\r\nThe convention is high digit before (not left of) low digit (which may\r\nbe odd for Arabs).\n --VERIFIER NOTES-- \nLike errata 2210, but here Constantin corrects to “high” rather than “first.” I don’t believe either is so misleading as to warrant a change.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2213,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.3.",
    "orig_text": "     - Two-octet scalar octet count for following hashed subpacket data.\r\n     - Hashed subpacket data set (zero or more subpackets).\r\n     - Two-octet scalar octet count for the following unhashed subpacket\r\n       data. \r\n     - Unhashed subpacket data set (zero or more subpackets).",
    "correct_text": "     - Two-octet scalar octet count for following hashincluded subpacket\r\n       data.\r\n     - Hashincluded subpacket data set (zero or more subpackets).\r\n     - Two-octet scalar octet count for the following not hashincluded\r\n       subpacket data. \r\n     - Not hashincluded subpacket data set (zero or more subpackets).",
    "notes": "The first field does not contain a hash. But it is included in the hash.\r\nUnhashing is the reverse of hashing, which is hopefully unfeasible.\n --VERIFIER NOTES-- \nThis is incorrect.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2214,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "5.2.3.",
    "orig_text": "   The concatenation of the data being signed and the signature data\r\n   from the version number through the hashed subpacket data (inclusive)\r\n   is hashed.  The resulting hash value is what is signed.  The left 16\r\n   bits of the hash are included in the Signature packet to provide a\r\n   quick test to reject some invalid signatures.\r\n\r\n   There are two fields consisting of Signature subpackets.  The first\r\n   field is hashed with the rest of the signature data, while the second\r\n   is unhashed.",
    "correct_text": "   The concatenation of the data being signed and the signature data from\r\n   the version number through the hashed subpacket data (inclusive), plus\r\n   a six-octet trailer (see section 5.2.4) is hashed.  The resulting hash\r\n   value is converted to the signature.  The left 16 bits of the hash are\r\n   included in the Signature packet to provide a quick test to reject\r\n   some invalid signatures.\r\n\r\n   There are two fields consisting of Signature subpackets.  The first\r\n   field (together with the preceding parts of the signature) is\r\n   included in the hash, while the second is not.",
    "notes": "There are six more octets (see 5.2.4.).\r\nThe data being signed is signed. The hash value is not signed, but\r\nconverted into the signature.\r\nThe first field is not hashed (does not contain a hash), but it is\r\nhashincluded. It is not true that the rest of the signature data is used\r\nin the hash. (This formulation is such strange for accuracy.)\r\nUnhashing is the reverse of hashing, which is hopefully unfeasible.\r\n\r\nModified text.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2215,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.3.1.",
    "orig_text": "   An implementation SHOULD ignore any subpacket of a type that it does\r\n   not recognize.\r\n\r\n   Bit 7 of the subpacket type is the \"critical\" bit.  If set, it\r\n   denotes that the subpacket is one that is critical for the evaluator\r\n   of the signature to recognize.  If a subpacket is encountered that is\r\n   marked critical but is unknown to the evaluating software, the\r\n   evaluator SHOULD consider the signature to be in error.",
    "correct_text": "   Bit 7 of the subpacket type is the \"critical\" bit.  If set, it\r\n   denotes that the subpacket is one that is critical for the evaluator\r\n   of the signature to recognize.  If a subpacket is encountered that is\r\n   marked critical but is unknown to the evaluating software, the\r\n   evaluator SHOULD consider the signature to be in error.\r\n\r\n   An implementation SHOULD ignore any subpacket of a type that it does\r\n   not recognize.",
    "notes": "The explanation for recognizing should come before recognizing is used.\n --VERIFIER NOTES-- \nThe existing text explains the rule of thumb, and then the exception. The suggestion would be more confusing than the original.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2216,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "5.2.3.3.",
    "orig_text": "   Subpackets that appear in a certification self-signature\r\n   apply to the user name, and subpackets that appear in the subkey\r\n   self-signature apply to the subkey.",
    "correct_text": "   Subpackets that appear in a certification self-signature\r\n   apply to the User ID, and subpackets that appear in the subkey\r\n   self-signature apply to the subkey.",
    "notes": "User ID, not user name",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2217,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.3.18.",
    "orig_text": "   Note also that since this is a URI, the key server can actually be a\r\n   copy of the key retrieved by ftp, http, finger, etc.",
    "correct_text": "?",
    "notes": "Nonsense. The key server is not a copy of a key.\r\nI do not get the point. What should be noted?\r\n\r\nModified to editorial.\n --VERIFIER NOTES-- \nNot actionable. No actual erratum. To answer the question, this text reminds the reader that a URI can refer to a static entity, as well as a query to a server. Yes, this is arguably superfluous, but it is there because of the WG’s rough consensus.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2218,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.2.4.",
    "orig_text": "   All signatures are formed by producing a hash over the signature\r\n   data, and then using the resulting hash in the signature algorithm.\r\n\r\n   For binary document signatures (type 0x00), the document data is\r\n   hashed directly.  For text document signatures (type 0x01), the\r\n   document is canonicalized by converting line endings to <CR><LF>,\r\n   and the resulting data is hashed.\r\n\r\n   When a signature is made over a key, the hash data starts with the\r\n   octet 0x99, followed by a two-octet length of the key, and then body\r\n   of the key packet.  (Note that this is an old-style packet header for\r\n   a key packet with two-octet length.)  A subkey binding signature\r\n   (type 0x18) or primary key binding signature (type 0x19) then hashes\r\n   the subkey using the same format as the main key (also using 0x99 as\r\n   the first octet).  Key revocation signatures (types 0x20 and 0x28)\r\n   hash only the key being revoked.\r\n\r\n   A certification signature (type 0x10 through 0x13) hashes the User\r\n   ID being bound to the key into the hash context after the above\r\n   data.  A V3 certification hashes the contents of the User ID or\r\n   attribute packet packet, without any header.  A V4 certification\r\n   hashes the constant 0xB4 for User ID certifications or the constant\r\n   0xD1 for User Attribute certifications, followed by a four-octet\r\n   number giving the length of the User ID or User Attribute data, and\r\n   then the User ID or User Attribute data.\r\n\r\n   When a signature is made over a Signature packet (type 0x50), the\r\n   hash data starts with the octet 0x88, followed by the four-octet\r\n   length of the signature, and then the body of the Signature packet.\r\n   (Note that this is an old-style packet header for a Signature packet\r\n   with the length-of-length set to zero.)  The unhashed subpacket data\r\n   of the Signature packet being hashed is not included in the hash, and\r\n   the unhashed subpacket data length value is set to zero.\r\n\r\n   Once the data body is hashed, then a trailer is hashed.  A V3\r\n   signature hashes five octets of the packet body, starting from the\r\n   signature type field.  This data is the signature type, followed by\r\n   the four-octet signature time.  A V4 signature hashes the packet body\r\n   starting from its first field, the version number, through the end\r\n   of the hashed subpacket data.  Thus, the fields hashed are the\r\n   signature version, the signature type, the public-key algorithm, the\r\n   hash algorithm, the hashed subpacket length, and the hashed\r\n   subpacket body.\r\n\r\n   V4 signatures also hash in a final trailer of six octets: the\r\n   version of the Signature packet, i.e., 0x04; 0xFF; and a four-octet,\r\n   big-endian number that is the length of the hashed data from the\r\n   Signature packet (note that this number does not include these final\r\n   six octets).\r\n\r\n   After all this has been hashed in a single hash context, the\r\n   resulting hash field is used in the signature algorithm and placed\r\n   at the end of the Signature packet.",
    "correct_text": "   All signatures are formed by producing a hash over the signature\r\n   data, and then using the resulting hash in the signature algorithm.\r\n\r\n   The signature data is the concatenation of a body and a trailer.\r\n\r\n   For binary document signatures (type 0x00), the document data is\r\n   is the sinature data body.  For text document signatures (type 0x01),\r\n   the document is canonicalized by converting line endings to <CR><LF>,\r\n   and the resulting data is the sinature data body.\r\n\r\n   When a signature is made over one key, the signature data body is a\r\n   Public-Key packet (see 5.5.) in the old packet format with two-octet\r\n   body length (octet 0x99, followed by the two-octet body length,\r\n   followed by the Public-Key packet body).  The signature data body of\r\n   a subkey binding signature (type 0x18) or of a primary key binding\r\n   signature (type 0x19) is the concatination of the Public-Key packet\r\n   of the main key and a Public-Key (not a Public-Subkey packet) packet\r\n   of the subkey in the format discribed above.  The signature data body\r\n   of a Key Revocation signatures (type 0x20 or 0x28) is the Public-Key\r\n   packet of the key being revoked in the format described above.\r\n\r\n   The signature data body for a V3 certification signature (type 0x10\r\n   through 0x13) is the concatination of the key packet in the format\r\n   described above and the body of a User ID packet (see 5.11.).  The\r\n   signature data body for a V4 certification signature (type 0x10\r\n   through 0x13) is the concatenation of the key packet in the format\r\n   descibed above, either the constant 0xB4 for User ID certification or\r\n   the constant 0xD1 for User Attribute certification (User Attribute\r\n   packets are not a required part of the OpenPGP standard.  Except as\r\n   noted, a User Attribute packet may be used anywhere that a User ID\r\n   packet may be used. (see 5.12.)),  a four-octet number giving the\r\n   length of the User ID Packet body, and the User ID Packet body.\r\n   (0xB4 starts an old-style packet header of a User ID packet with\r\n   one-octet body length and 0xD1 starts the new-style packet header of\r\n   a User Attribute packet.  But the body length is encoded\r\n   differently.)\r\n\r\n   When a signature is made over a Signature packet (type 0x50), the to\r\n   signed Signature packet is trimmed by leaving out the not\r\n   hashincluded subpacket data and setting the not hashincluded\r\n   subpacket data length to zero.  The body of the signature data is the\r\n   octet 0x88, followed by the four-octet-length of the to be signed\r\n   Signature packet body, followed by the to be signed Signature packet\r\n   body.  (0x88 starts an old-style packet header of a Signature packet\r\n   with one-octet body length.  But the body length is encoded\r\n   differently.)\r\n\r\n   The signature data trailer for a V3 signature are five octets of the\r\n   signature packet body, starting from the signature type field. This\r\n   data is the signature type followed by the four-octet signature time.\r\n   The signature data trailer for a V4 signature is the concatenation\r\n   of a part of the signature packet body starting from the first field,\r\n   the version number, through the end of the hashincluded subpacket\r\n   data, one more time the version number (0x04), 0xFF, and a four-octet\r\n   number of the length of the part included from the signature packet.",
    "notes": "The original is nearly unintelligible. Key, key packet, key packet body,\r\netc are confused until a signature hashes the User ID into a hash\r\ncontext (sic!).\r\n\r\nThe 0x99 for all public-keys and the differently encoded body lenght for\r\nUser ID packets and User Attribute packets is really odd.\r\nProposal:\r\nA Flag and a Feature for a new encoding of the signature body.  Usage of\r\na the actual new-style packet headers with 0xFF and four-octet body\r\nlength.\r\n\r\nChanged to editorial.\n --VERIFIER NOTES-- \nAs complex as the RFC’s text may be, it’s been through the IETF process including people actually coding to it. I don’t find the change any less complex and might contain errors.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2219,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "5.3.",
    "orig_text": "   The message is encrypted with a session key, and the session key is\r\n   itself encrypted and stored in the Encrypted Session Key packet or\r\n   the Symmetric-Key Encrypted Session Key packet.",
    "correct_text": "   The message is encrypted with a session key, and the session key is\r\n   itself encrypted and stored in the Public-Key Encrypted Session Key\r\n   packet or the Symmetric-Key Encrypted Session Key packet.",
    "notes": "The word `Public-Key' is missing.\r\n\r\nChanged to editorial",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2220,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.5.3.",
    "orig_text": "     - A Public-Key or Public-Subkey packet, as described above.",
    "correct_text": "     - A Public-Key or Public-Subkey packet body, as described above.",
    "notes": "There is no Public-Key packet header in the Secret-Key packet body.\r\n\r\nChanged to editorial.\n --VERIFIER NOTES-- \nSimilar to Errata 2202 and 2203, it is an idiom of the document to say “packet” when it might be more precise to say “packet body.” It is, however, clear. If there are inconsistencies in this idiom, they’d make reasonable errata.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2221,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.5.3.",
    "orig_text": "     - If the string-to-key usage octet is zero or 255, then a two-octet\r\n       checksum of the plaintext of the algorithm-specific portion (sum\r\n       of all octets, mod 65536).",
    "correct_text": "     - If the string-to-key usage octet is not 254, then a two-octet\r\n       checksum of the plaintext of the algorithm-specific portion (sum\r\n       of all octets, mod 65536).",
    "notes": "Without the values values of 1 to 253 the following\r\n     Note that for all other values, a two-octet checksum is required.\r\nis not just a note.\r\n\r\nChanged to editorial.\n --VERIFIER NOTES-- \nThe RFC is correct.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2222,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "5.5.3.",
    "orig_text": "   Implementations MUST use a string-to-key specifier; the simple hash\r\n   is for backward compatibility and is deprecated, though\r\n   implementations MAY continue to use existing private keys in the old\r\n   format.",
    "correct_text": "   Implementations MUST generate a string-to-key specifier; the simple\r\n   hash is for backward compatibility and is deprecated, though\r\n   implementations MAY continue to use existing private keys in the old\r\n   format.",
    "notes": "MUST use and MAY continue to use the opposite is a contradiction.\r\n\r\nChanged to editorial.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2223,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.5.3.",
    "orig_text": "       This checksum or hash is encrypted together with the\r\n       algorithm-specific fields (if string-to-key usage octet is not\r\n       zero).",
    "correct_text": "       For V4 keys this checksum or hash is encrypted together with the\r\n       algorithm-specific fields (if string-to-key usage octet is not\r\n       zero).",
    "notes": "The following text says:\r\n   With V3 keys, the checksum is stored in the clear.  With V4 keys,\r\n   the checksum is encrypted like the algorithm-specific data.\r\n\r\nChanged to editorial.\n --VERIFIER NOTES-- \nText describing V3 keys precedes this text.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2224,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.5.3.",
    "orig_text": "   Encryption/decryption of the secret data is done in CFB mode using\r\n   the key created from the passphrase and the Initial Vector from the\r\n   packet.  A different mode is used with V3 keys (which are only RSA)\r\n   than with other key formats.  With V3 keys, the MPI bit count prefix\r\n   (i.e., the first two octets) is not encrypted.  Only the MPI non-\r\n   prefix data is encrypted.  Furthermore, the CFB state is\r\n   resynchronized at the beginning of each new MPI value, so that the\r\n   CFB block boundary is aligned with the start of the MPI data.\r\n\r\n   With V4 keys, a simpler method is used.  All secret MPI values are\r\n   encrypted in CFB mode, including the MPI bitcount prefix.",
    "correct_text": "   Encryption/decryption of the secret data is done in CFB mode using\r\n   the key created from the passphrase and the Initial Vector from the\r\n   packet.\r\n\r\n   A different mode is used with V3 keys (which are only RSA)\r\n   than with other key formats.  With V3 keys, the MPI bit count prefix\r\n   (i.e., the first two octets) is not encrypted.  Only the MPI non-\r\n   prefix data is encrypted.  Furthermore, the CFB state is\r\n   resynchronized at the beginning of each new MPI value, so that the\r\n   CFB block boundary is aligned with the start of the MPI data.\r\n\r\n   With V4 keys, a simpler method is used.  All secret MPI values are\r\n   encrypted in CFB mode, including the MPI bitcount prefix.",
    "notes": "It is unclear if the Furthermore belongs only to V3 keys.\r\n\r\nChanged to editorial.\n --VERIFIER NOTES-- \nText is in a paragraph describing V3 keys.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2225,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.9.",
    "orig_text": "   If the special name \"_CONSOLE\" is used, the message is considered to\r\n   be \"for your eyes only\".",
    "correct_text": "   If the special name \"_CONSOLE_\" is used, the message is considered to\r\n   be \"for your eyes only\".",
    "notes": "If the name is actually \"_CONSOLE\", you should explicitly mention it.\n --VERIFIER NOTES-- \nErratum is wrong.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2226,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "5.9.",
    "orig_text": "       These should be converted to native line endings by the receiving\r\n       software.",
    "correct_text": "       These SHOULD be converted to native line endings by the receiving\r\n       software.",
    "notes": "This is a SHOULD of [RFC2119].\r\n\r\nChanged to editorial.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2227,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.12.",
    "orig_text": "   A User ID packet consists of UTF-8 text that is intended to represent\r\n   the name and email address of the key holder.",
    "correct_text": "   A User ID packet body consists of UTF-8 text that is intended to\r\n   represent the name and email address of the key holder.\r\nor\r\n   A User ID packet contains UTF-8 text that is intended to represent\r\n   the name and email address of the key holder.",
    "notes": "Yes, it is pedantic. But the packet consists of header and body.\n --VERIFIER NOTES-- \nSimilar to errata 2220 etc. It is indeed pedantic as submitter notes.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2228,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.13.",
    "orig_text": "   The plaintext of the data to be encrypted is passed through the SHA-1\r\n   hash function, and the result of the hash is appended to the\r\n   plaintext in a Modification Detection Code packet.  The input to the\r\n   hash function includes the prefix data described above; it includes\r\n   all of the plaintext, and then also includes two octets of values\r\n   0xD3, 0x14.  These represent the encoding of a Modification Detection\r\n   Code packet tag and length field of 20 octets.",
    "correct_text": "   The concatination of the prefix data descibed above, the plaintext to\r\n   be encrypted and two octets of values 0xD3, 0x14 (These represent the\r\n   encoding of a Modification Detection Code packet tag and length field\r\n   of 20 octets) is passed through the SHA-1 hash function.",
    "notes": "The text is misleading and contradicting.\n --VERIFIER NOTES-- \nErratum is incorrect.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2229,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.13.",
    "orig_text": "      Suffice it to say that many people consider properties such as\r\n      deniability to be as valuable as integrity.",
    "correct_text": "      It is sufficient to say that many people consider properties such\r\n      as deniability to be as valuable as integrity.",
    "notes": "Is that an imperative?\n --VERIFIER NOTES-- \nSuggestion isn’t grammatical.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2230,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.14.",
    "orig_text": "   The Modification Detection Code packet MUST be the last\r\n   packet in the plaintext data that is encrypted in the Symmetrically\r\n   Encrypted Integrity Protected Data packet, and MUST appear in no\r\n   other place.",
    "correct_text": "   The Modification Detection Code packet MUST be the last\r\n   packet in the plaintext data that is encrypted in the Symmetrically\r\n   Encrypted Integrity Protected Data packet, and MUST NOT appear in any\r\n   other place.",
    "notes": "'MUST appear in no other place' postulates an existence in the nowhere.\n --VERIFIER NOTES-- \nOn its surface, a good suggestion, but lacks the force of the original.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2231,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5.14.",
    "orig_text": "   A Modification Detection Code packet MUST have a length of 20 octets.",
    "correct_text": "   A Modification Detection Code packet MUST have a body length of 20\r\n   octets.",
    "notes": "The packet consists of header and body.\n --VERIFIER NOTES-- \nSimilar to errata 2220 etc. It is indeed pedantic as submitter notes.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2232,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "6.3.",
    "orig_text": "   The encoded output stream must be represented in lines of no more\r\n   than 76 characters each.",
    "correct_text": "   The encoded output stream MUST be represented in lines in according\r\n   to the following algorithm.\r\n   Choose a maximal line width w not greater than 76.  Insert after each\r\n   w characters a line break.  If the last = (the beginning of the\r\n   encoded checksum) is not at the beginning of a line, one line break\r\n   MAY be inserted before the last =.",
    "notes": "The old formulation allows lines of different length and even empty\r\nlines.\n --VERIFIER NOTES-- \nThe submitter describes legal, correct behavior, and amends the text to disallow it.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2233,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "6.4.",
    "orig_text": "   In Radix-64 data, characters other than those in the table, line\r\n   breaks, and other white space probably indicate a transmission error,\r\n   about which a warning message or even a message rejection might be\r\n   appropriate under some circumstances.  Decoding software must ignore\r\n   all white space.\r\n\r\n   Because it is used only for padding at the end of the data, the\r\n   occurrence of any \"=\" characters may be taken as evidence that the\r\n   end of the data has been reached (without truncation in transit).  No\r\n   such assurance is possible, however, when the number of octets\r\n   transmitted was a multiple of three and no \"=\" characters are\r\n   present.",
    "correct_text": "   In Radix-64 data, characters other than those in the table, line\r\n   breaks earlier than defined by the first line's length without\r\n   following '=' or '-', line breaks at the beginning of a line, and\r\n   other white space probably indicate a transmission error, about which\r\n   a warning message or even a message rejection might be appropriate\r\n   under some circumstances.  After that check, decoding software must\r\n   ignore all white space.\r\n\r\n   The boundary between encoded data and encoded checksum is before the\r\n   last '=' of a sequence of one, two or three '='.",
    "notes": "Might reject and must ignore is a contradiction.\r\nThere is always at least one '=', i.e. the beginning of the encoded\r\nchecksum.\r\n\r\nChanged to editorial.\n --VERIFIER NOTES-- \nThere is no contradiction. The implementation must ignore all whitespace, and must reject all bogus ‘=’ characters.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2234,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "6.5.",
    "orig_text": "    Examples of Radix-64",
    "correct_text": "    Examples of base64",
    "notes": "Radix-64 has a checksum, too.\r\n\r\nChanged to editorial.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2235,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 8,
    "orig_text": "   If two characters in the sequence are separated\r\n   by '-', this is shorthand for the full list of ASCII characters\r\n   between them (e.g., '[0-9]' matches any decimal digit).",
    "correct_text": "   If two characters in the sequence are separated by '-', this is\r\n   shorthand for the full list of ASCII characters between them (e.g.,\r\n   '[0-9]' matches any decimal digit).  The collation sequence is UTF-8.",
    "notes": "UTF-8 has the collation sequence of unicode.  You probably do not want\r\nto have the system's locale involved.\r\n\r\nMaybe a hint on greediness of regex is nessessary, too.\r\n\r\nChanged to editorial.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2236,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 11,
    "orig_text": "11.  Packet Composition\r\n\r\n(the headline)",
    "correct_text": "11.  Packet Sequence Composition",
    "notes": "It is about the composition of a sequence of packets, not about the\r\ncomposition of a packet.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2237,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "11.1.",
    "orig_text": "   User Attribute packets and User ID packets may be freely intermixed\r\n   in this section, so long as the signatures that follow them are\r\n   maintained on the proper User Attribute or User ID packet.",
    "correct_text": "   User Attribute packets and User ID packets may be freely intermixed\r\n   in this section, so long as the signatures that follow them are\r\n   maintained on the proper User Attribute or User ID packet, and as\r\n   long the first one is a User ID packet.",
    "notes": "The first one must be a User ID packet and must not be a User Attribute\r\npacket.\n --VERIFIER NOTES-- \nThe RFC is correct. It says that they may be freely intermixed, to denote that they may be freely intermixed.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2238,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "11.1.",
    "orig_text": "   After the User ID packet or Attribute packet, there may be zero or\r\n   more Subkey packets.",
    "correct_text": "   After the sequence with the User ID packets and User Attribute\r\n   packets, there may be zero or more Subkey packets.",
    "notes": "The Subkey packets come after all User ID packets and User Attribute\r\npackets.\r\n\r\nChanged to editorial.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2239,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "12.1.",
    "orig_text": "   Entries in square brackets are optional and ellipses indicate\r\n   repetition.\r\n   ...\r\n           Primary-Key\r\n              [Revocation Self Signature]\r\n              [Direct Key Signature...]\r\n               User ID [Signature ...]\r\n              [User ID [Signature ...] ...]\r\n              [User Attribute [Signature ...] ...]\r\n              [[Subkey [Binding-Signature-Revocation]\r\n                      Primary-Key-Binding-Signature] ...]",
    "correct_text": "   Entries in square brackets are optional, vertical bar separates\r\n   alternatives, and ellipses indicate repetition.\r\n   ...\r\n           Primary-Key\r\n              [Revocation Self Signature]\r\n              [Direct Key Signature...]\r\n               User ID [Signature ...]\r\n              [[User ID [Signature ...] |\r\n                      [User Attribute [Signature ...]]...]\r\n              [[Subkey [Binding-Signature-Revocation]\r\n                      Primary-Key-Binding-Signature] ...]",
    "notes": "11.1. says:\r\n   User Attribute packets and User ID packets may be freely intermixed\r\n   in this section, so long as the signatures that follow them are\r\n   maintained on the proper User Attribute or User ID packet, and as\r\n   long the first one is a User ID packet.\r\n\r\nChanged to editorial.\n --VERIFIER NOTES-- \nThe RFC is correct. It says that they may be freely intermixed, to denote that they may be freely intermixed.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2240,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "12.1.",
    "orig_text": "   In the above diagram, if the binding signature of a subkey has been\r\n   revoked, the revoked key may be removed, leaving only one key.",
    "correct_text": "   In the above diagram, if the binding signature of a subkey has been\r\n   revoked, the revoked key may be removed.  Note that this bears the\r\n   danger of importing the subkey again without the Binding Signature\r\n   Revocation.",
    "notes": "If there are more than one subkeys, the removing of one leaves more\r\nthan one key.  And the warning is missing.\r\n\r\nChanged to editorial.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2241,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "12.2.",
    "orig_text": "   The fingerprint of a V3 key is formed by hashing the body (but not\r\n   the two-octet length) of the MPIs that form the key material (public\r\n   modulus n, followed by exponent e) with MD5.",
    "correct_text": "   The fingerprint of a V3 key is formed by hashing the concatenation\r\n   of the bodies of the MPIs (MPI without two-octet length) that form\r\n   the key material (public modulus n, followed by exponent e) with MD5.",
    "notes": "There are two bodies and one hash.\r\n\r\nChanged to editorial.\n --VERIFIER NOTES-- \nIt could have been: \r\n\r\n... by hashing the body (but not the two-octet length) of the two MPIs \r\n                                                              ^^^\r\n\r\nBut, it's clear from the parenthetical that there are two MPIs.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2242,
    "doc-id": "RFC4880",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "13.1.3.",
    "orig_text": "   mL = intended length in octets of the encoded message, at least tLen\r\n        + 11, where tLen is the octet length of the DER encoding T of a\r\n        certain value computed during the encoding operation",
    "correct_text": "   emLen = intended length in octets of the encoded message, at least\r\n        tLen + 11, where tLen is the octet length of the DER encoding T\r\n        of a certain value computed during the encoding operation",
    "notes": "In the following text it is called emLen.\r\n\r\nChanged to editorial.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2243,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "13.9.",
    "orig_text": "   OpenPGP CFB mode uses an initialization vector (IV) of all zeros, and\r\n   prefixes the plaintext with BS+2 octets of random data, such that\r\n   octets BS+1 and BS+2 match octets BS-1 and BS.  It does a CFB\r\n   resynchronization after encrypting those BS+2 octets.\r\n\r\n   Thus, for an algorithm that has a block size of 8 octets (64 bits),\r\n   the IV is 10 octets long and octets 7 and 8 of the IV are the same as\r\n   octets 9 and 10.  For an algorithm with a block size of 16 octets\r\n   (128 bits), the IV is 18 octets long, and octets 17 and 18 replicate\r\n   octets 15 and 16.  Those extra two octets are an easy check for a\r\n   correct key.",
    "correct_text": "   OpenPGP CFB mode uses an initialization vector (IV) of all zeros, and\r\n   prefixes the plaintext with BS+2 octets of random data, such that\r\n   octets BS+1 and BS+2 match octets BS-1 and BS.  It does a CFB\r\n   resynchronization after encrypting those BS+2 octets.\r\n\r\n   Thus, for an algorithm that has a block size of 8 octets (64 bits),\r\n   the virtual IV is 10 octets long and octets 7 and 8 of the virtual IV\r\n   are the same as octets 9 and 10.  For an algorithm with a block size\r\n   of 16 octets (128 bits), the virtual IV is 18 octets long, and octets\r\n   17 and 18 replicate octets 15 and 16. Those extra two octets are an\r\n   easy check for a correct key.\"",
    "notes": "'IV' is used in a contradicting manner.\r\n\r\nChanged to editorial.\r\n\r\nFrom Jon. C.: This is a marvelous re-wording of a confusing process. I really like the “virtual IV” mentioned. However, the suggested change omitted the final sentence, which is the whole reason for the virtual IV. I have restored that sentence.",
    "submit_date": "2010-04-28",
    "submitter_name": "Constantin Hagemeier",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2270,
    "doc-id": "RFC4880",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "5.2.2",
    "orig_text": "       SHA224:     0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,\r\n                   0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05,\r\n                   0x00, 0x04, 0x1C\r\n",
    "correct_text": "       SHA224:     0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,\r\n                   0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05,\r\n                   0x00, 0x04, 0x1C\r\n",
    "notes": "The second byte as published in 4880 is 0x31 but should be 0x2d.\r\n\r\nHal Finney noted this once, but I didn't see it entered in as an errata.",
    "submit_date": "2010-05-18",
    "submitter_name": "David Shaw",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2271,
    "doc-id": "RFC4880",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 6.5,
    "orig_text": "   Input data:  0x14FB9C03D97E\r\n   Hex:     1   4    F   B    9   C     | 0   3    D   9    7   E\r\n   8-bit:   00010100 11111011 10011100  | 00000011 11011001 11111110\r\n   6-bit:   000101 001111 101110 011100 | 000000 111101 100111 111110\r\n   Decimal: 5      15     46     28       0      61     37     62\r\n   Output:  F      P      u      c        A      9      l      +\r\n",
    "correct_text": "   Input data:  0x14FB9C03D97E\r\n   Hex:     1   4    F   B    9   C     | 0   3    D   9    7   E\r\n   8-bit:   00010100 11111011 10011100  | 00000011 11011001 01111110\r\n   6-bit:   000101 001111 101110 011100 | 000000 111101 100101 111110\r\n   Decimal: 5      15     46     28       0      61     37     62\r\n   Output:  F      P      u      c        A      9      l      +\r\n",
    "notes": "This example shows the conversion of 0x14FB9C03D97E into Radix-64.  The problem is in the last byte, where '7E' is shown in binary as 11111110.  That of course should be 01111110.  The error is carried through in the 6-bit rendering of that data where the next-to-last 6-bit group 100111 should actually be 100101.  The decimal rendering as well as the output (character) line is correct.",
    "submit_date": "2010-05-18",
    "submitter_name": "David Shaw",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3298,
    "doc-id": "RFC4880",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "5.2.4",
    "orig_text": "Key revocation signatures (types 0x20 and 0x28) hash only the key being revoked.",
    "correct_text": "Primary key revocation signatures (type 0x20) hash only the key being revoked.\r\nSubkey revocation signature (type 0x28) hash first the primary key and then the\r\nsubkey being revoked.",
    "notes": "This amendment to subkey revocation signatures is intended to align the spec with existing implementations.  (it also makes the subkey revocation signatures more symmetric with the subkey binding signatures).\r\n\r\nGnuPG (all known versions with subkey support) hashes both keys, as does PGP (tested at version 6.5.8).  I'm unaware of any other OpenPGP implementation that actually complies with the spec as written for subkey revocations.\r\n\r\nThis was apparently noticed (but apparently ignored) back in 2000 (see point 2 of [0]) and was recently discussed again on the IETF list [1].\r\n\r\n[0] http://www.mhonarc.org/archive/html/ietf-openpgp/2000-12/msg00001.html\r\n[1] http://www.mhonarc.org/archive/html/ietf-openpgp/2012-07/msg00003.html",
    "submit_date": "2012-07-27",
    "submitter_name": "Daniel Kahn Gillmor",
    "verifier_id": 128,
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3725,
    "doc-id": "RFC4880",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.2.3.11.",
    "orig_text": "Some implementations do not represent the interest of a single user\r\n(for example, a key server).  Such implementations always trim local\r\ncertifications from any key they handle.\r\n\r\n",
    "correct_text": "Some implementations do not represent the interest of a single user\r\n(for example, a key server).  Such implementations MUST always trim \r\nlocal certifications from any key they handle.\r\n\r\n",
    "notes": "Inspiration taken from a thread on sks-devel: http://lists.nongnu.org/archive/html/sks-devel/2013-09/msg00022.html\r\n\n --VERIFIER NOTES-- \nAs agreed by the authors, MUST is unnecessary here.",
    "submit_date": "2013-09-14",
    "submitter_name": "Kwadronaut",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5491,
    "doc-id": "RFC4880",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 6.1,
    "orig_text": "#define CRC24_POLY 0x1864CFBL",
    "correct_text": "#define CRC24_POLY 0x864CFBL",
    "notes": "In the C reference implementation of CRC-24, the generator used does not match the specification in Section 6, though the final masking step avoids a functional difference.",
    "submit_date": "2018-09-04",
    "submitter_name": "Marco Bellaccini",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  }
]
