[
  {
    "errata_id": 163,
    "doc-id": "RFC4226",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": 9,
    "orig_text": "   Oracle AuthO()\n   --------------\n      A = ALG(K,C)\n      C = C + 1\n      Return O to B",
    "correct_text": "   Oracle AuthO()\n   --------------\n      A = ALG(K,C)\n      C = C + 1\n      Return A to B\n             ^^",
    "notes": "\nSection A.4.1, Paragraph 3, Lemma 1 definition, top of page 19\n\nThe description of Lemma 1 defines P_ {N,m} (z) using the term Z_ {n}\nand it should actually be Z_ {N}.\n           P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{n}]\nShould be:\n           P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{N}]\n                                                              ^^^\n\nSection E.2, Paragraph 4, bottom of page 32\n    32^8 > 10^12 so the security of an 8-alphanumeric HOTP code is\n   significantly better than a 9-digit HOTP value.\nShould be:\n    32^8 > 10^12 so the security of an 8-alphanumeric HOTP code is\n   significantly better than a 12-digit HOTP value.\n                               ^^\n\nIn Author's Addresses, Page 35, David Naccache's contact information should be:\n\n    David Naccache\n   ENS, DI\n   45 rue d'Ulm\n   75005 Paris, France\n   and\n   Information Security Group,\n   Royal Holloway,\n   University of London, Egham,\n   Surrey TW20 0EX, UK\n\n   EMail: david.naccache@ens.fr, david.naccache@rhul.ac.uk\n\n",
    "submit_date": "2005-12-26",
    "submitter_name": "M'Raihi, David",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 834,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "E.4",
    "orig_text": "   1) C-client >= C-server\r\n   2) C-client - C-server <= s\r\n   3) Check that HOTP client is valid HOTP(K,C-Client)\r\n   4) If true, the server sets C to C-client + 1 and client is\r\n      authenticated                           ^^^\r\n                              ^^^             ^^^",
    "correct_text": "   1) C-client >= C-server\r\n   2) C-client - C-server <= s\r\n|  3) Check that HOTP client is valid HOTP(K,C-client)\r\n|  4) If true, the server sets C-server to C-client + 1 and client is\r\n      authenticated",
    "notes": "Lines up with Errata ID 2402.\r\n\r\nThe enumeration in Appendix E.4, on page 34, contains inconsistent\r\nvariable namings (cf. [Errata ID 2402]!).\r\nTo make it self-consistent, change as detailed.",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2400,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 5.3,
    "orig_text": "   The reason for masking the most significant bit of P is to avoid\r\n   confusion about signed vs. unsigned modulo computations.  Different\r\n   processors perform these operations differently, and masking out the\r\n|  signed bit removes all ambiguity.\r\n       ^^\r\n   Implementations MUST extract a 6-digit code at a minimum and possibly\r\n   7 and 8-digit code.  Depending on security requirements, Digit = 7 or\r\n   more SHOULD be considered in order to extract a longer HOTP value.",
    "correct_text": "   The reason for masking the most significant bit of P is to avoid\r\n   confusion about signed vs. unsigned modulo computations.  Different\r\n   processors perform these operations differently, and masking out the\r\n|  sign bit removes all ambiguity.\r\n\r\n   Implementations MUST extract a 6-digit code at a minimum and possibly\r\n|  7 and 8-digit codes.  Depending on security requirements, Digit = 7\r\n   or more SHOULD be considered in order to extract a longer HOTP value.",
    "notes": "Editorial fixes.\r\n\r\nre: the text of Section 5.3, in the 2nd and 3rd paragraph on page 7.",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2401,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.1",
    "orig_text": "   Let IntDiv(a,b) denote the integer division algorithm that takes\r\n|  input integers a, b where a >= b >= 1 and returns integers (q,r)\r\n|\r\n   the quotient and remainder, respectively, of the division of a by b.\r\n   (Thus, a = bq + r and 0 <= r < b.)",
    "correct_text": "   Let IntDiv(a,b) denote the integer division algorithm that takes\r\n|  input integers a, b where  b >= 1  and returns integers (q,r), the\r\n   quotient and remainder, respectively, of the division of a by b.\r\n   (Thus, a = bq + r and 0 <= r < b.)",
    "notes": "inappropriate restriction specified + formatting flaw.\r\n\r\nOn page 17, Appendix A.1:\r\nThe restriction  \"a >= b\"  is not necessary and in fact inappropriate; the additional blank line seems to be an artifact of the editing process.  Thus, the above text should better read [as above].\r\n",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2402,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.3",
    "orig_text": "   The scenario we are considering is that a user and server share a key\r\n   K for ALG.  Both maintain a counter C, initially zero, and the user\r\n   authenticates itself by sending ALG(K,C) to the server.  The latter\r\n   accepts if this value is correct.\r\n\r\n   In order to protect against accidental increment of the user counter,\r\n   the server, upon receiving a value z, will accept as long as z equals\r\n   ALG(K,i) for some i in the range C,...,C + s-1, where s is the\r\n   resynchronization parameter and C is the server counter.  If it\r\n   accepts with some value of i, it then increments its counter to i+1.\r\n   If it does not accept, it does not change its counter value.",
    "correct_text": "   The scenario we are considering is that a user and server share a key\r\n|  K for ALG.  Both maintain a counter C and C', respectively, initially\r\n   zero, and the user authenticates itself by sending ALG(K,C) to the\r\n   server.  The latter accepts if this value is correct.\r\n\r\n   In order to protect against accidental increment of the user counter,\r\n   the server, upon receiving a value z, will accept as long as z equals\r\n|  ALG(K,i) for some i in the range C',...,C' + s-1, where s is the\r\n|  resynchronization parameter and C' is the server counter.  If it\r\n   accepts with some value of i, it then increments its counter to i+1.\r\n   If it does not accept, it does not change its counter value.",
    "notes": "conflicting naming of variables.\r\n\r\nre: the text of the 2nd and 3rd paragraph of Appendix A.3, on page 18 \r\n\r\nIn Appendix A.3, unfortunately the necessary distinction between\r\nthe counter value kept with the user and the counter value kept\r\nat the server is not preserved in the variable names introduced.\r\nThis leads to significant confusion.\r\n\r\nI hereby propose a 'minimally invasive' text modification as\r\n[shown] (Cf. Appendix E.3 for another notation).\r\n",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2403,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "A.3",
    "orig_text": "                                                    ...  It wins if the\r\n   server accepts this accumulator.\r\n                       ^^^^^^^^^^^",
    "correct_text": "                                                    ...  It wins if the\r\n   server accepts this authenticator.",
    "notes": "typo. near the bottom of page 18, the 2nd-to-last paragraph of Appendix A.3\r\n(on that page).",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2404,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.3",
    "orig_text": "   Oracle AuthO()\r\n   --------------\r\n      A = ALG(K,C)\r\n      C = C + 1\r\n      Return O to B\r\n\r\n   Oracle VerO(A)\r\n   --------------\r\n      i = C\r\n      While (i <= C + s - 1 and Win == FALSE) do\r\n         If A == ALG(K,i) then Win = TRUE; C = i + 1\r\n         Else i = i + 1\r\n      Return Win to B",
    "correct_text": "   Oracle AuthO()\r\n   --------------\r\n      A = ALG(K,C)\r\n      C = C + 1\r\n|     Return A to B\r\n\r\n   Oracle VerO(A)\r\n   --------------\r\n|     i = C'\r\n|     While (i <= C' + s - 1 and Win == FALSE) do\r\n|        If A == ALG(K,i) then Win = TRUE; C' = i + 1\r\n         Else i = i + 1\r\n      Return Win to B",
    "notes": "another typo, and continuation of Errata ID 2402.\r\n\r\nStill in Appendix A.3, the text on the upper half of page 19 contains\r\na wrong (undefined) variable name 'O' which should be 'A' instead,\r\nand it should be adapted according to [Errata ID 2402].",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2405,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.4.1",
    "orig_text": "(6)  [ typos in mathematical text ]\r\n\r\nLemma 1 and its proof in Appendis A.4.1, on page 20, contains\r\nseveral typos.\r\n\r\nIn Lemma 1, the line,\r\n\r\n          P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{n}]\r\n                                                              ^^^\r\nshould read:\r\n\r\n          P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{N}]\r\n\r\nThis corrects the use of an undefined variable, n, by using the\r\nvariable N as expected from the LHS term.\r\n\r\nIn the Proof of Lemma 1, the case distinction for z contains an\r\nimproper relational operator at two places.\r\nTo adjust to the possible range of values (cf. item (2) above!),\r\nthe formula parts:\r\n\r\n   P_{N,m}(z)  =  [ ... ]\r\n\r\n                = mq/N * 1/m +\r\n                   (N - mq)/N * 1 / (N - mq)     if 0 <= z < N - mq\r\n|                  0                             if N - mq <= z <= m\r\n                                                               ^^^^\r\n                = q/N +\r\n                   r/N * 1 / r                   if 0 <= z < N - mq\r\n|                  0                             if r <= z <= m\r\n                                                          ^^^^\r\nshould be modified to read:\r\n\r\n   P_{N,m}(z)  =  [ ... ]\r\n\r\n                = mq/N * 1/m +\r\n                   (N - mq)/N * 1 / (N - mq)     if 0 <= z < N - mq\r\n|                  0                             if N - mq <= z < m\r\n\r\n                = q/N +\r\n                   r/N * 1 / r                   if 0 <= z < N - mq\r\n|                  0                             if r <= z < m",
    "correct_text": "see above\r\n",
    "notes": "typos",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2406,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "99Appendix A.4.3 says:",
    "orig_text": "   Proposition 2 ------------- Suppose m = 10^Digit < 2^31, and let\r\n   (q,r) = IntDiv(2^31,m).  Let B be any adversary attacking HOTP-IDEAL\r\n   using v verification oracle queries and a <= 2^c - s authenticator\r\n   oracle queries.  Then [...]\r\n",
    "correct_text": "  Proposition 2\r\n  -------------\r\n\r\n  Suppose m = 10^Digit < 2^31, and let (q,r) = IntDiv(2^31,m).  Let B\r\n  be any adversary attacking HOTP-IDEAL using v verification oracle\r\n  queries and a <= 2^c - s authenticator oracle queries.  Then  [...]",
    "notes": "",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Tim Polk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2407,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "A.5",
    "orig_text": "   Let T denotes the time to perform one computation of H.  [...]\r\n               ^",
    "correct_text": "   Let T denote the time to perform one computation of H.  [...]",
    "notes": "typo. within Appendix A.5, in the lower half of page 23, the text for\r\n\"Assumption 1\".",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2408,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "C",
    "orig_text": "       // These are used to calculate the check-sum digits.\r\n|      //                                0  1  2  3  4  5  6  7  8  9\r\n       private static final int[] doubleDigits =\r\n                       { 0, 2, 4, 6, 8, 1, 3, 5, 7, 9 };",
    "correct_text": "       // These are used to calculate the check-sum digits.\r\n|      //                0  1  2  3  4  5  6  7  8  9\r\n       private static final int[] doubleDigits =\r\n                       { 0, 2, 4, 6, 8, 1, 3, 5, 7, 9 };",
    "notes": "formatting.\r\n\r\nIn Appendix C, the source text in the upper half of page 28\r\ncontains an improperly formatted comment -- obviously intended\r\nto illustrate the subsequent declaration, the comment must be\r\naligned with that declaration.",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2409,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "C",
    "orig_text": "In Appendix C, the source code on page 30 (lower half) and\r\npage 31 contains improperly indented lines.\r\n\r\nThe following three line groups should be indented by 6 more character\r\npositions to make them conformant to RFC style 'nice' format:\r\n\r\n- on page 30:\r\n\r\n     String result = null;\r\n     int digits = addChecksum ? (codeDigits + 1) : codeDigits;\r\n\r\n- on page 30:\r\n\r\n     if ( (0<=truncationOffset) &&\r\n            (truncationOffset<(hash.length-4)) ) {\r\n         offset = truncationOffset;\r\n     }\r\n\r\n- on page 31:\r\n\r\n     if (addChecksum) {\r\n         otp =  (otp * 10) + calcChecksum(otp, codeDigits);\r\n     }\r\n     result = Integer.toString(otp);\r\n     while (result.length() < digits) {\r\n         result = \"0\" + result;\r\n     }\r\n     return result;",
    "correct_text": " [see above]",
    "notes": "[ further formatting (indentation) issues ]",
    "submit_date": "2006-01-18",
    "submitter_name": "Alfred Hoenes",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4994,
    "doc-id": "RFC4226",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 7.2,
    "orig_text": "The HOTP client (hardware or software token) increments its counter\r\nand then calculates the next HOTP value HOTP client.  If the value\r\nreceived by the authentication server matches the value calculated by\r\nthe client, then the HOTP value is validated.  In this case, the\r\nserver increments the counter value by one.\r\n\r\nIf the value received by the server does not match the value\r\ncalculated by the client, the server initiate the resynch protocol\r\n(look-ahead window) before it requests another pass.",
    "correct_text": "The HOTP client (hardware or software token) increments its counter\r\nand then calculates the next HOTP value HOTP client.  If the value\r\nreceived by the authentication server matches the value calculated by\r\nthe server, then the HOTP value is validated.  In this case, the\r\nserver increments the counter value by one.\r\n\r\nIf the value received by the server does not match the value\r\ncalculated by the server, the server initiate the resynch protocol\r\n(look-ahead window) before it requests another pass.",
    "notes": "The OTP value received by the server is the one calculated by the client.",
    "submit_date": "2017-04-14",
    "submitter_name": "Mathias Tausig",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5129,
    "doc-id": "RFC4226",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Appendix D",
    "orig_text": "Count    Hexadecimal    Decimal        HOTP\r\n   0        4c93cf18       1284755224     755224\r\n   1        41397eea       1094287082     287082\r\n   2         82fef30        137359152     359152\r\n   3        66ef7655       1726969429     969429\r\n   4        61c5938a       1640338314     338314\r\n   5        33c083d4        868254676     254676\r\n   6        7256c032       1918287922     287922\r\n   7         4e5b397         82162583     162583\r\n   8        2823443f        673399871     399871\r\n   9        2679dc69        645520489     520489\r\n\r\n",
    "correct_text": "Count     Hexadecimal    Decimal        HOTP\r\n   0         4c93cf18      1284755224    755224\r\n   1         75a48a19      1973717529    717529\r\n   2         bacb7fa       195868666     868666\r\n   3         66c28227      1724023335    023335\r\n   4         2904c900      688179456     179456\r\n   5         237e783d      595490877     490877\r\n   6         3c9cd285      1016910469    910469\r\n   7         24fb960c      620467724     467724\r\n   8         1b3c89f6      456952310     952310\r\n   9         16374098      372719768     719768\r\n",
    "notes": "From https://www.ietf.org/rfc/rfc4226.txt, Appendix D, page 31\r\n\r\na. There is no mention of the parameters that were used to run the reference implementation to provide to test data. These should be: \r\n\r\ncodeDigits: 6, addCheckSum: false, truncationOffset: 0.\r\n\r\nb. The hashes correspond. And the first row of Table2 (i.e for Count==0) correspond, but for Count 1...9 the values for Hex, Decimal and Hotp do not correspond with the values of the reference implementation.\r\n\r\nI am using JDK 1.8.0_144\r\n\r\nAs a test I have done a copy and paste 'as is' from the reference implementation and run it with sysout statements to print the truncation and otp values for each counter.\r\n\r\nThe only changes made are: System.out and use of counter=movingFactor to print the movingFactor. None of which alter the logic. Note the differences in test data were found before adding the debug info.\r\n\r\nPlease see:\r\nhttps://github.com/gerritjvv/cryptoplayground/tree/master/hmac/java/hmac/src/test/java/org/funsec/hmac\r\n\r\nUnitTest method:\r\nhttps://github.com/gerritjvv/cryptoplayground/blob/master/hmac/java/hmac/src/test/java/org/funsec/hmac/HTOPTest.java#L83\r\n\r\nReference Impl:\r\nhttps://github.com/gerritjvv/cryptoplayground/blob/master/hmac/java/hmac/src/test/java/org/funsec/hmac/HOTPRef.java",
    "submit_date": "2017-09-27",
    "submitter_name": "Gerrit Jansen van Vuuren",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5130,
    "doc-id": "RFC4226",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Appendix C",
    "orig_text": " static public String generateOTP(byte[] secret,\r\n                  long movingFactor,\r\n             int codeDigits,\r\n                  boolean addChecksum,\r\n             int truncationOffset)\r\n           throws NoSuchAlgorithmException, InvalidKeyException\r\n       {\r\n           // put movingFactor value into text byte array\r\n     String result = null;\r\n     int digits = addChecksum ? (codeDigits + 1) : codeDigits;\r\n           byte[] text = new byte[8];\r\n           for (int i = text.length - 1; i >= 0; i--) {\r\n               text[i] = (byte) (movingFactor & 0xff);\r\n               movingFactor >>= 8;\r\n           }",
    "correct_text": " static public String generateOTP(byte[] secret,\r\n                  long movingFactor,\r\n             int codeDigits,\r\n                  boolean addChecksum,\r\n             int truncationOffset)\r\n           throws NoSuchAlgorithmException, InvalidKeyException\r\n       {\r\n           // put movingFactor value into text byte array\r\n     String result = null;\r\n     long count = movingFactor;\r\n     int digits = addChecksum ? (codeDigits + 1) : codeDigits;\r\n           byte[] text = new byte[8];\r\n           for (int i = text.length - 1; i >= 0; i--) {\r\n               text[i] = (byte) (count & 0xff);\r\n               count >>= 8;\r\n           }",
    "notes": "method parameters like movingFactor should not be edited or changed in the method logic. This may lead to misunderstanding and bugs when the code is ported to other platforms and or re-implemented. Here movingFactor would be expected to stay constant and can be reused, but the original implementation updates the value to 0, which means any extra logic or updates (even debug statements) would always see movingFactor == 0 no matter what.",
    "submit_date": "2017-09-27",
    "submitter_name": "Gerrit Jansen van Vuuren",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5723,
    "doc-id": "RFC4226",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 7.2,
    "orig_text": "The HOTP client (hardware or software token) increments its counter\r\nand then calculates the next HOTP value HOTP client.",
    "correct_text": "The HOTP client (hardware or software token) increments its counter\r\nand then calculates the next HOTP value.",
    "notes": "Stray \"HOTP client\" at the end of the sentence (for no reason).",
    "submit_date": "2019-05-18",
    "submitter_name": "Adam Sorini",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5792,
    "doc-id": "RFC4226",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 5.3,
    "orig_text": "Implementations MUST extract a 6-digit code at a minimum and possibly\r\n7 and 8-digit code.  Depending on security requirements, Digit = 7 or\r\nmore SHOULD be considered in order to extract a longer HOTP value.",
    "correct_text": "Implementations MUST extract a 6-digit code at a minimum and possibly\r\n7, 8 and 9-digit code.  Depending on security requirements, Digit = 7\r\nor more SHOULD be considered in order to extract a longer HOTP value.\r\nThe code MUST NOT exceed 9 digits. ",
    "notes": "Although the detailed description of the dynamic truncation algorithm makes is clear that the code is generated from a 31 bit value, it is not explicitly stated in the main sections of the RFC that nine digits is the maximum number of digits supported by the algorithm.\r\n\r\nThe fact that nine digits is the maximum supported is alluded to in E.2, but this should be made more clear.\r\n\r\nThere are reports that TOTP implementations in the wild are supporting 10 digit codes. That mistaken behavior would be better discouraged by clarifying the limit of digits to 9.",
    "submit_date": "2019-07-24",
    "submitter_name": "Jeffrey Goldberg",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 6181,
    "doc-id": "RFC4226",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "E.4",
    "orig_text": "   The server accepts if the following are all true, where C-server is\r\n   its own current counter value:\r\n\r\n   1) C-client >= C-server\r\n   2) C-client - C-server <= s\r\n   3) Check that HOTP client is valid HOTP(K,C-Client)\r\n   4) If true, the server sets C to C-client + 1 and client is\r\n      authenticated\r\n\r\n   In this case, there is no need for managing a look-ahead window\r\n   anymore.  The probability of success of the adversary is only v/10^6\r\n   or roughly v in one million.  A side benefit is obviously to be able\r\n   to increase s \"infinitely\" and therefore improve the system usability\r\n   without impacting the security.",
    "correct_text": "   The server accepts if the following are all true, where C-server is\r\n   its own current counter value:\r\n\r\n   1) C-client >= C-server\r\n   2) Check that HOTP client is valid HOTP(K,C-Client)\r\n   3) If true, the server sets C to C-client + 1 and client is\r\n      authenticated\r\n\r\n   In this case, there is no need for managing a look-ahead window\r\n   anymore.  The probability of success of the adversary is only v/10^6\r\n   or roughly v in one million.  A side benefit is obviously to be able\r\n   to increase C-server \"infinitely\" and therefore improve the system usability\r\n   without impacting the security.",
    "notes": "1. Resynchronization should be allowed when C-client - C-server > s.\r\n2. The look-ahead window s should not be increased.\n --VERIFIER NOTES-- \nThe proposed new text provides behavior equivalent to the behavior allowed by the old text with respect to the possibility of resynchronization in the face of large C-client/C-server skew.",
    "submit_date": "2020-05-18",
    "submitter_name": "Yishuai Li",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-05-30 14:52:46"
  }
]
